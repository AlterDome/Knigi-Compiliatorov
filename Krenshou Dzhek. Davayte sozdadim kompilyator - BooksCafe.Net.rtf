{\rtf1\ansi\ansicpg\deff0\deflang1049\deflangfe1049\deftab708{\fonttbl{\f0\fswiss\fprq2\fcharset204{\*\fname Arial CYR;}Arial;}{\f1\froman\fprq2\fcharset204{\*\fname Times New Roman CYR;}Times New Roman;}{\f2\fmodern\fprq1\fcharset204{\*\fname Courier New CYR;}Courier New;}}{\info
{\title Давайте создадим компилятор!}
{\author Джек Креншоу }
}{\fet0 \ftnbj \ftnrstpg \ftnnar}{\stylesheet
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Normal;}
{\s1 \qc\snext0\b\f0\fs32\fi0\li0\ri0  heading 1;}
{\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0  heading 2;}
{\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0  heading 3;}
{\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0  heading 4;}
{\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0  heading 5;}
{\s6 \qc\snext0\s6\f1\b\fs24\fi0  heading 6;}
{\s10 \qj\snext\f1\fs22\b0\i1\li3000\fi400\ri0  Epigraph;}
{\s11 \qj\snext0\f1\fs22\b1\i0\li3000\fi400\ri0  Epigraph Author;}
{\s12 \qj\snext0\f1\fs24\b0\i1\fi567\li0\ri0  Annotation;}
{\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600  Cite;}
{\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600  Cite Author;}
{\s15 \ql\snext0\f1\fs24\b1\i0\li2000\ri600\sb12  Poem Title;}
{\s16 \ql\snext0\f1\fs24\b0\i0\li2000\ri600  Stanza;}
{\s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0  FootNote;}
{\s18 \qj\snext\f1\fs18\b0\i1\li1500\fi400\ri0  FootNote Epigraph;}
{\s18 \qj\snext0\f1\fs18\b1\i0\li1500\fi400\ri0  FootNote Epigraph Author;}
{\s19 \ql\snext0\f1\fs18\b0\i0\li500\ri600  FootNote Stanza;}
{\s20 \qj\snext0\f1\fs18\b0\i0\li300\ri600  FootNote Cite;}
{\s21 \qj\snext0\f1\fs18\b1\i1\li350\ri600  FootNote Cite Author;}
{\s22 \ql\snext0\f1\fs20\b1\i0\li2000\ri600\sb12  FootNote Poem Title;}

}\paperw11906\paperh16838\margl1417\margr850\margt1134\margb1134


\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net" }}{\fldrslt \ul бесплатной электронной библиотеке BooksCafe.Net}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net/author/krenshou_dzhek-1664.html" }}{\fldrslt \ul Все книги автора}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net/book/krenshou_dzhek-davayte_sozdadim_kompilyator-5714.html" }}{\fldrslt \ul Эта же книга в других форматах}}
\par
\par

\s0 \f0\qc\fi0\li0\ri0 Приятного чтения!\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта серия статей является руководством по теории и практике разработки синтаксических анализаторов и компиляторов языков программирования. Прежде чем вы закончите чтение этой книги, мы раскроем все аспекты конструирования компиляторов, создадим новый язык программирования, и построим работающий компилятор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя я по образованию и не специалист в компьютерах, я интересовался компиляторами в течение многих лет. Я покупал и старался разобраться с содержимым практически каждой выпущенной на эту тему книги. И, должен признаться, это был долгий путь. Эти книги написаны для специалистов в компьютерной науке и слишком трудны для понимания большинству из нас. Но с течением лет часть из прочитанного начала доходить до меня. Закрепить полученное позволило то, что я начал самостоятельно пробовать это на своем собственном компьютере. Сейчас я хочу поделиться с вами своими знаниями. После прочтения этой книги вы не станете ни специалистом, ни узнаете всех секретов теории конструирования компиляторов. Я намеренно полностью игнорирую большинство теоретических аспектов этой темы. Вы изучите только практические аспекты, необходимые для создания работающей системы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В течение всей книги я буду проводить эксперименты на компьютере, а вы будете повторять их за мной и ставить свои собственные эксперименты. Я буду использовать Turbo Pascal 4.0 и периодически буду включать примеры, написанные в TP. Эти примеры вы будете копировать себе в компьютер и выполнять. Если у вас не установлен Turbo Pascal вам будет трудно следить за ходом обучения, поэтому я настоятельно рекомендую его поставить. Кроме того, это просто замечательный продукт и для множества других задач!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые тексты программ будут показаны как примеры или как законченные продукты, которые вы можете копировать без необходимости понимания принципов их работы. Но я надеюсь сделать гораздо больше: я хочу научить вас КАК это делается, чтобы вы могли делать это самостоятельно, и не только повторять то что я делаю но и улучшать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такую задачу не решить на одной странице. Я попытаюсь сделать это в нескольких статьях. Каждая статья раскрывает один аспект теории создания компиляторов и может быть изучена в отдельности от всех других. Если вас в настоящее время интересует только какой-то определенный аспект, тогда вы можете обратиться к нужной статье. Каждая статья будет появляться по мере завершения, так что вы должны дождаться последней для того, чтобы считать себя закончившими обучение. Пожалуйста, будьте терпеливы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В общем, каждая книга по теории создания компиляторов раскрывает множество основ, которые мы не будем рассматривать. Типичная последовательность:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • вступление, в котором описывается что такое компилятор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • одна или две главы, описывающие задание синтаксиса с использованием формы Бэкуса-Наура (БНФ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • одна или две главы с описанием лексического анализа, с акцентом на детерминированных и недетерминированных конечных автоматах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • несколько глав по теории синтаксического анализа, начиная с рекурсивного спуска и заканчивая LALR анализаторами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • глава, посвященная промежуточным языкам, с акцентом на P-код и обратную польскую запись.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • множество глав об альтернативных путях для поддержки подпрограмм и передачи параметров, описания типов, и т.д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • завершающая глава по генерации кода, обычно для какого-нибудь воображаемого процессора с простым набором команд.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • финальная глава или две, посвященные оптимизации. Эта глава часто остается непрочитанной, очень часто.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой серии я буду использовать совсем другой подход. Для начала, я не остановлюсь долго на выборе. Я покажу вам путь, который работает. Если же вы хотите изучить возможности, хорошо… я поддержу вас... но я буду держаться того, что я знаю. Я также пропущу большинство тех теорий, которые заставляют людей засыпать. Не поймите меня неправильно: я не преуменьшаю важность теоретических знаний, они жизненно необходимы, когда приходится иметь дело с более сложными элементами какого либо языка. Но необходимо более важные вещи ставить на первое место. Мы же будем иметь дело с методами, 95% которых не требуют много теории для работы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также буду рассматривать только один метод синтаксического анализа: рекурсивный спуск, который является единственным полностью пригодным методом при ручном написании компилятора. Другие методы полезны только в том случае, если у вас есть инструменты типа Yacc, и вам совсем неважно, сколько памяти будет использовать готовый продукт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также возьму страницу из работы Рона Кейна, автора Small C. Поскольку почти все другие авторы компиляторов исторически использовали промежуточный язык подобно P-коду и разделяли компилятор на две части («front end», который производит P-код, и «back end», который обрабатывает P-код, для получения выполняемого объектного кода), Рон показал нам, что очень просто заставить компилятор непосредственно производить выполняемый объектный код в форме языковых утверждений ассемблера. Такой код не самый компактный в мире код... генерация оптимизированного кода – гораздо более трудная работа. Но этот метод работает и работает достаточно хорошо. И чтобы не оставить вас с мыслью, что наш конечный продукт не будет представлять никакой ценности, я собираюсь показать вам как создать компилятор с небольшой оптимизацией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, я собираюсь использовать некоторые приемы, которые мне показались наиболее полезными для того, чтобы понимать, что происходит, не продираясь сквозь дремучий лес. Основным из них является использование односимвольных токенов, не содержащих пробелов, на ранней стадии разработки. Я считаю, что если я могу создать синтаксический анализатор для распознавания и обработки I-T-L, то я смогу сделать тоже и с IF-THEN-ELSE. На втором уроке я покажу вам, как легко расширить простой синтаксический анализатор для поддержки токенов произвольной длины. Следующий прием состоит в том что я полностью игнорирую файловый ввод/вывод, показывая этим что если я могу считывать данные с клавиатуры и выводить результат на экран я могу также делать это и с файлами на диске. Опыт показывает, что как только транслятор заработает правильно очень просто перенаправить ввод/вывод на файлы. Последний прием заключается в том, что я не пытаюсь выполнять коррекцию/восстановление после ошибок. Программа, которую мы будем создавать, будет распознавать ошибки и просто остановится на первой из них, точно также как это происходит в Turbo Pascal. Будут и некоторые другие приемы, которые вы увидите по ходу дела. Большинство из них вы не найдете в каком либо учебнике по компиляторам, но они работают.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несколько слов о стиле программирования и эффективности. Как вы увидите, я стараюсь писать программы в виде маленьких, легко понятных фрагментов. Ни одна из процедур, с которыми мы будем работать, не будет состоять из более чем 15-20 строк. Я горячий приверженец принципа KISS (Keep It Simple, Sidney – Делай это проще, Сидней) в программировании. Я никогда не пытаюсь сделать что-либо сложное, когда можно сделать просто. Неэффективно? Возможно, но вам понравится результат. Как сказал Брайан Керниган, сначала заставьте программу работать, затем заставьте программу работать быстро. Если позднее вы захотите вернуться и подправить что-либо в вашем продукте, вы сможете сделать это т.к. код будет совершенно понятным. Если вы поступаете так, я, тем не менее, убеждаю вас подождать пока программа не будет выполнять все, что вы от нее хотите.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также имею тенденцию не торопиться с созданием модулей до тех пор, пока не обнаружу, что они действительно нужны мне. Попытка предусмотреть все необходимое в будущем может свести вас с ума. В наши время, время экранных редакторов и быстрых компиляторов я буду менять модули тогда, когда почувствую необходимость в более мощном. До тех пор я буду писать только то, что мне нужно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заключительный аспект: Один из принципов, который мы будем применять здесь, заключается в том, что мы не будем никого вводить в заблуждение с P-кодом или воображаемыми ЦПУ, но мы начнем с получения работающего, выполнимого объектного кода, по крайней мере, в виде программы на ассемблере. Тем не менее, вам может не понравиться выбранный мной ассемблер… это – ассемблер для микропроцессора 68000, используемый в моей системе (под SK*DOS). Я думаю, что вы найдете, тем не менее, что трансляция для любого другого ЦПУ, например 80x86, совершенно очевидна, так что я не вижу здесь проблемы. Фактически, я надеюсь что кто-то, кто знает язык 8086 лучше, чем я, предоставит нам эквивалент объектного кода.\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Основа\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждая программа нуждается в некоторых шаблонах … подпрограммы ввода/вывода, подпрограммы сообщений об ошибках и т.д. Программы, которые мы будем разрабатывать, не составляют исключения. Я попытался выполнить их на минимальном уровне, чтобы мы могли сконцентрироваться на более важных вещах и не заблудиться. Код, размещенный ниже, представляет собой минимум, необходимый нам, чтобы что-нибудь сделать. Он состоит из нескольких подпрограмм ввода/вывод, подпрограммы обработки ошибок и скелета – пустой основной программы. Назовем ее Cradle. По мере создания других подпрограмм, мы будем добавлять их к Cradle и добавлять вызовы этих подпрограмм. Скопируйте Cradle и сохраните его, потому что мы будем использовать его неоднократно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует множество различных путей для организации процесса сканирования в синтаксическом анализаторе. В Unix системах авторы обычно используют getc и ungetc. Удачный метод, примененный мной, заключается в использовании одиночного, глобального упреждающего символа. Части процедуры инициализации служит для «запуска помпы», считывая первый символ из входного потока. Никаких других специальных методов не требуется… каждый удачный вызов GetChar считывает следующий символ из потока.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Cradle;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := upcase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скопируйте код, представленный выше, в TP и откомпилируйте. Удостоверьтесь, что программа откомпилировалась и запустилась корректно. Затем переходим к первому уроку, синтаксическому анализу выражений.\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Синтаксический анализ выражений \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Начало\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы прочитали введение, то вы уже в курсе дела. Вы также скопировали программу Cradle в Turbo Pascal и откомпилировали ее. Итак, вы готовы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Целью этой главы является обучение синтаксическому анализу и трансляции математических выражений. В результате мы хотели бы видеть серию команд на ассемблере, выполняющую необходимые действия. Выражение – правая сторона уравнения, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x = 2*y + 3/(4*z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В самом начале я буду двигаться очень маленькими шагами для того, чтобы начинающие из вас совсем не заблудились. Вы также получите несколько хороших уроков, которые хорошо послужат нам позднее. Для более опытных читателей: потерпите. Скоро мы двинемся вперед.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Одиночные цифры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с общей темой этой серии (KISS-принцип, помнишь?), начнем с самого простого случая, который можно себе представить. Это выражение, состоящее из одной цифры.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед тем как начать, удостоверьтесь, что у вас есть базовая копия Cradle. Мы будем использовать ее для других экспериментов. Затем добавьте следующие строки:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 И добавьте строку “Expression;” в основную программу, которая должна выглядеть так:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь запустите программу. Попробуйте ввести любую одиночную цифру. Вы получите результат в виде одной строчки на ассемблере. Затем попробуйте ввести любой другой символ и вы увидите, что синтаксический анализатор правильно сообщает об ошибке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поздравляю! Вы только что написали работающий транслятор!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, я понимаю, что он очень ограничен. Но не отмахивайтесь от него. Этот маленький «компилятор» в ограниченных масштабах делает точно то же, что делает любой большой компилятор: он корректно распознает допустимые утверждения на входном «языке», который мы для него определили, и производит корректный, выполнимый ассемблерный код, пригодный для перевода в объектный формат. И, что важно, корректно распознает недопустимые утверждения, выдавая сообщение об ошибке. Кому требовалось больше?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеются некоторые другие особенности этой маленькой программы, заслуживающие внимания. Во первых, вы видите, что мы не отделяем генерацию кода от синтаксического анализа… как только анализатор узнает что нам нужно, он непосредственно генерирует объектный код. В настоящих компиляторах, конечно, чтение в GetChar должно происходить из файла и затем выполняться запись в другой файл, но этот способ намного проще пока мы экспериментируем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Также обратите внимание, что выражение должно где-то сохранить результат. Я выбрал регистр D0 процессора 68000. Я мог бы выбрать другой регистр, но в данном случае это имеет смысл.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Выражения с двумя цифрами\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, давайте немного улучшим то, что у нас есть. По общему признанию, выражение, состоящее только из одного символа, не удовлетворит наших потребностей надолго, так что давайте посмотрим, как мы можем расширить возможности компилятора. Предположим, что мы хотим обрабатывать выражения вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1+2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или 4-3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или в общем <term> +/– <term> (это часть формы Бэкуса-Наура или БНФ.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы сделать это, нам нужна процедура, распознающая термы и сохраняющая результат, и другая процедура, которая распознает и различает «+» и «-» и генерирует соответствующий код. Но если процедура Expression сохраняет свои результаты в регистре D0, то где процедура Term сохранит свои результаты? Ответ: на том же месте. Мы окажемся перед необходимостью сохранять первый результат процедуры Term где-нибудь, прежде чем мы получим следующий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В основном, что нам необходимо сделать – создать процедуру Term, выполняющую то что раннее выполняла процедура Expression. Поэтому просто переименуйте процедуру Expression в Term и наберите новую версию Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Addop');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем выше Expression наберите следующие две процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда вы закончите, порядок подпрограмм должен быть следующий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Term (старая версия Expression)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Add\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Subtract\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Expression\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь запустите программу. Испробуйте любую комбинацию, которую вы только можете придумать, из двух одиночных цифр, разделенных «+» или «-». Вы должны получить ряд из четырех инструкций на ассемблере. Затем испытайте выражения с заведомыми ошибками в них. Перехватывает анализатор ошибки?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Посмотрите на полученный объектный код. Можно сделать два замечания. Во первых, сгенерированный код не такой, какой бы написали мы. Последовательность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE #n,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,D1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 неэффективна. Если бы мы писали этот код вручную, то, возможно, просто загрузили бы данные напрямую в D1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вывод: код, генерируемый нашим синтаксическим анализатором, менее эффективный, чем код, написанный вручную. Привыкните к этому. Это в известной мере относится ко всем компиляторам. Ученые посвятили целые жизни вопросу оптимизации кода и существуют методы, призванные улучшить качество генерируемого кода. Некоторые компиляторы выполняют оптимизацию достаточно хорошо, но за это приходится платить сложностью и в любом случае это проигранная битва… возможно никогда не придет время, когда хороший программист на ассемблере не смог бы превзойти компилятор. Прежде чем закончится этот урок, я кратко упомяну некоторые способы, которые мы можем применить для небольшой оптимизации, просто, чтобы показать вам, что мы на самом деле сможем сделать некоторые улучшения без излишних проблем. Но запомните, мы здесь для того, чтобы учиться, а не для того, чтобы узнать насколько компактным мы можем сделать код. А сейчас и на протяжении всей этой серии мы старательно будем игнорировать оптимизацию и сконцентрируемся на получении работающего кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но наш код не работает! В коде есть ошибка! Команда вычитания вычитает D1 (первый аргумент) из D0 (второй аргумент). Но это неправильный способ, так как мы получаем неправильный знак результата. Поэтому исправим процедуру Subtract с помощью замены знака следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь наш код даже еще менее эффективен, но по крайней мере выдает правильный ответ! К сожалению, правила, которые определяют значение математических выражений, требуют, чтобы условия в выражении следовали в неудобном для нас порядке. Опять, это только один из фактов жизни, с которыми вы учитесь жить. Все это возвратится снова, чтобы преследовать нас, когда мы примемся за деление.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, на данном этапе мы имеем синтаксический анализатор, который может распознавать сумму или разность двух цифр. Ранее мы могли распознавать только одиночные цифры. Но настоящие выражения могут иметь любую форму (или бесконечность других). Вернитесь и запустите программу с единственным входным символом “1”.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не работает? А почему должен работать? Мы только указали анализатору, что единственным правильными видами выражений являются выражения с двумя термами. Мы должны переписать процедуру Expression так, чтобы она была намного более универсальной и с этого начать создание настоящего синтаксического анализатора.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Общая форма выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В реальном мире выражение может состоять из одного или более термов, разделенных «addops» ('+' или '-'). В БНФ это может быть записано как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <term> [<addop> <term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем применить это определение выражения, добавив простой цикл к процедуре Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['+', '-'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Addop');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта версия поддерживает любое число термов, и это стоило нам только двух дополнительных строк кода. По мере изучения, вы обнаружите, что это характерно для нисходящих синтаксических анализаторов… необходимо только несколько дополнительных строк кода чтобы добавить расширения языка. Это как раз то, что делает наш пошаговый метод возможным. Заметьте также, как хорошо код процедуры Expression соответствует определению БНФ. Это также одна из характеристик метода. Когда вы станете специалистом этого метода, вы сможете превращать БНФ в код синтаксического анализатора примерно с такой же скоростью, с какой вы можете набирать текст на клавиатуре!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, откомпилируйте новую версию анализатора и испытайте его. Как обычно, проверьте что «компилятор» обрабатывает любое допустимое выражение и выдает осмысленное сообщение об ошибке для запрещенных. Четко, да? Вы можете заметить, что в нашей тестовой версии любое сообщение об ошибке выводится вместе с генерируемым кодом. Но запомните, это только потому, что мы используем экран как «выходной файл» в этих экспериментах. В рабочей версии вывод будет разделен… один в выходной файл, другой на экран.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Использование стека\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом месте я собираюсь нарушить свое правило, что я не представлю что-либо сложное, пока это не будет абсолютно необходимо. Прошло достаточно много времени, чтобы не отметить проблему с генерируемым кодом. В настоящее время синтаксический анализатор использует D0 как «основной» регистр, и D1 для хранения частичной суммы. Эта схема работает отлично потому что мы имеем дело только с «addops» (“+” и “-”) и новое число прибавляется по мере появления. Но в общем форме это не так. Рассмотрим, например выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1+(2-(3+(4-5)))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы поместим «1» в D1, то где мы разместим «2»? Так как выражение в общей форме может иметь любую степень сложности, то мы очень быстро используем все регистры!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью есть простое решение. Как и все современные микропроцессоры, 68000 имеет стек, который является отличным местом для хранения переменного числа элементов. Поэтому вместо того, чтобы помещать термы в D0 и D1 давайте затолкнем их в стек. Для тех кто незнаком с ассемблером 68000 – помещение в стек пишется как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –(SP)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и извлечение (SP)+.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, изменим EmitLn в процедуре Expression на\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EmitLn('MOVE D0,-(SP)');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и две строки в Add и Subtract:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EmitLn('ADD (SP)+,D0') и EmitLn('SUB (SP)+,D0')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соответственно. Теперь испытаем компилятор снова и удостоверимся что он работает.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И снова, полученный код менее эффективен, чем был до этого, но это необходимый шаг, как вы увидите.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Умножение и деление\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте возьмемся за действительно серьезные дела. Как вы знаете, кроме операторов «addops» существуют и другие… выражения могут также иметь операторы умножения и деления. Вы также знаете, что существует неявный приоритет операторов или иерархия, связанная с выражениями, чтобы в выражениях типа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2 + 3 * 4,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мы знали, что нужно сначала умножить, а затем сложить. (Видите, зачем нам нужен стек? )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ранние дни технологии компиляторов, люди использовали различные довольно сложные методы для того чтобы правила приоритета операторов соблюдались. Но, оказывается, все же, что ни один из них нам не нужен… эти правила могут быть очень хорошо применены в нашей технике нисходящего синтаксического анализа. До сих пор единственной формой, которую мы применяли для терма была форма одиночной десятичной цифры. В более общей форме мы можем определить терм как произведение показателей (product of factors), то есть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <factor> [ <mulop> <factor ]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что такое показатель? На данный момент это тоже, чем был раннее терм – одиночной цифрой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание: терм имеет ту же форму, что и выражение. Фактически, мы можем добавить это в наш компилятор осторожно скопировав и переименовав. Но во избежание неразберихи ниже приведен полный листинг всех подпрограмм анализатора. (Заметьте способ, которым мы изменяем порядок операндов в Divide.)\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['*', '/'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Mulop');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['+', '-'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Addop');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конфетка! Почти работающий транслятор в 55 строк Паскаля! Получаемый код начинает выглядеть действительно полезным, если не обращать внимание на неэффективность. Запомните, мы не пытаемся создавать сейчас самый компактный код.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Круглые скобки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем закончить эту часть синтаксического анализатора добавив поддержку круглых скобок. Как вы знаете, скобки являются механизмом принудительного изменения приоритета операторов. Так, например, в выражении\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2*(3+4) ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 скобки заставляют выполнять сложение перед умножением. Но, что гораздо более важно, скобки дают нам механизм для определения выражений любой степени сложности, как, например\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1+2)/((3+4)+(5-6))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ключом к встраиванию скобок в наш синтаксический анализатор является понимание того, что не зависимо от того, как сложно выражение, заключенное в скобки, для остальной части мира оно выглядит как простой показатель. Это одна из форм для показателя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= (<expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь появляется рекурсия. Выражение может содержать показатель, который содержит другое выражение, которое содержит показатель и т.д. до бесконечности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложно это или нет, мы должны позаботиться об этом, добавив несколько строчек в процедуру Factor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте снова, как легко мы можем дополнять синтаксический анализатор, и как хорошо код Паскаля соответствует синтаксису БНФ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно, откомпилируйте новую версию и убедитесь, что анализатор корректно распознает допустимые предложения и отмечает недопустимые сообщениями об ошибках.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Унарный минус\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На данном этапе мы имеем синтаксический анализатор, который поддерживает почти любые выражения, правильно? ОК, тогда испробуйте следующее предложение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Опс! Он не работает, не правда ли? Процедура Expression ожидает, что все числа будут целыми и спотыкается на знаке минус. Вы найдете, что +3 также не будет работать, так же как и что-нибудь типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –(3-2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует пара способов для исправления этой проблемы. Самый легкий (хотя и не обязательно самый лучший) способ – вставить ноль в начало выражения, так чтобы -3 стал 0-3. Мы можем легко исправить это в существующей версии Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Addop');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я говорил вам, насколько легко мы сможем вносить изменения! На этот раз они стоили нам всего трех новых строчек Паскаля. Обратите внимание на появление ссылки на новую функцию IsAddop. Как только проверка на addop появилась дважды, я решил выделить ее в отдельную функцию. Форма функции IsAddop должна быть аналогична форме функции IsAlpha. Вот она:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, внесите эти изменения в программу и повторно откомпилируйте. Вы должны также включить IsAddop в базовую копию программы Cradle. Она потребуется нам позже. Сейчас попробуйте снова ввести -1. Вау! Эффективность полученного кода довольно плохая… шесть строк кода только для того, чтобы загрузить простую константу… но, по крайней мере, правильно работает. Запомните, мы не пытаемся сделать замену Turbo Pascal.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На данном этапе мы почти завершили создание структуры нашего синтаксического анализатора выражений. Эта версия программы должна правильно распознавать и компилировать почти любое выражение, которое вы ей подсунете. Она все еще ограничена тем, что поддерживает показатели состоящие только из одной цифры. Но я надеюсь что теперь вы начинаете понимать, что мы можем расширять возможности синтаксического анализатора делая незначительные изменения. Вы возможно даже не будете удивлены, когда услышите, что переменная или даже вызов функции это просто один из видов показателя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующей главе я покажу, как можно легко расширить наш синтаксический анализатор для поддержки всех этих возможностей, и я также покажу как легко мы можем добавить многосимвольные числа и имена переменных. Итак, вы видите, что мы совсем недалеко от действительно полезного синтаксического анализатора.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Слово об оптимизации\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Раннее в этой главе я обещал дать несколько подсказок как мы можем повысить качество генерируемого кода. Как я сказал, получение компактного кода не является главной целью этой книги. Но вам нужно по крайней мере знать, что мы не зря проводим свое время… что мы действительно можем модифицировать анализатор для получения лучшего кода не выбрасывая то, что мы уже сделали к настоящему времени. Обычно небольшая оптимизация не слишком трудна… просто в синтаксический анализатор вставляется дополнительный код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют два основных метода, которые мы можем использовать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Попытаться исправить код после того, как он сгенерирован.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это понятие «щелевой» оптимизации. Основная идея в том, что известно какие комбинации инструкций компилятор собирается произвести и также известно которые из них «плохие» (такие как код для числа -1). Итак, все что нужно сделать – просканировать полученный код, найти такие комбинации инструкций и заменить их на более «хорошие». Это вид макрорасширений наоборот и прямой пример метода сопоставления с образцом. Единственная сложность в том, что может существовать множество таких комбинаций. Этот метод называется «щелевой» оптимизацией просто потому, что оптимизатор работает с маленькой группой инструкций. «Щелевая» оптимизация может драматически влиять на качество кода и не требует при этом больших изменений в структуре компилятора. Но все же за это приходится платить скоростью, размером и сложностью компилятора. Поиск всех комбинаций требует проверки множества условий, каждая из которых является источником ошибки. И, естественно, это требует много времени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В классической реализации «щелевого» оптимизатора, оптимизация выполняется как второй проход компилятора. Выходной код записывается на диск и затем оптимизатор считывает и обрабатывает этот файл снова. Фактически, оптимизатор может быть даже отдельной от компилятора программой. Так как оптимизатор только обрабатывает код в маленьком «окне» инструкций (отсюда и название), лучшей реализацией было бы буферизировать несколько срок выходного кода и сканировать буфер каждый раз после EmitLn.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Попытаться сразу генерировать лучший код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом методе выполняется проверка дополнительных условий перед выводом кода. Как тривиальный пример, мы должны были бы идентифицировать нуль и выдать CLR вместо загрузки, или даже совсем ничего не делать, как в случае с прибавлением нуля, например. Конкретней, если мы решили распознавать унарный минус в процедуре Factor вместо Expression, то мы должны обрабатывать –1 как обычную константу, а не генерировать ее из положительных. Ни одна из этих вещей не является слишком сложной для реализации… просто они требуют включения дополнительных проверок в код, поэтому я не включил их в программу. Как только мы дойдем до получения работающего компилятора, генерирующего полезный выполнимый код, мы всегда сможем вернуться и доработать программу для получения более компактного кода. Именно поэтому в мире существует «Версия 2.0».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует еще один, достойный упоминания, способ оптимизации, обещающий достаточно компактный код без излишних хлопот. Это мое «изобретение», в том смысле, что я нигде не видел публикаций по этому методу, хотя я и не питаю иллюзий что это придумано мной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Способ заключается в том, чтобы избежать частого использования стека, лучше используя регистры центрального процессора. Вспомните, когда мы выполняли только сложение и вычитание, то мы использовали регистры D0 и D1 а не стек? Это работало, потому для этих двух операций стек никогда не использовал более чем две ячейки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, процессор 68000 имеет восемь регистров данных. Почему бы не использовать их как стек? В любой момент своей работы синтаксический анализатор «знает» как много элементов в стеке, поэтому он может правильно ими манипулировать. Мы можем определить частный указатель стека, который следит, на каком уровне мы находимся и адресует соответствующий регистр. Процедура Factor, например, должна загружать данные не в регистр D0, а в тот, который является текущей вершиной стека.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что мы получаем заменяя стек в RAM на локальный стек созданный из регистров. Для большинства выражений уровень стека никогда не превысит восьми, поэтому мы получаем достаточно хороший код. Конечно, мы должны предусмотреть те случаи, когда уровень стека превысит восемь, но это также не проблема. Мы просто позволим стеку перетекать в стек ЦПУ. Для уровней выше восьми код не хуже, чем тот, который мы генерируем сейчас, а для уровней ниже восьми он значительно лучше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я реализовал этот метод, просто для того, чтобы удостовериться в том, что он работает перед тем, как представить его вам. Он работает. На практике вы не можете в действительности использовать все восемь уровней... вам, как минимум, нужен один свободный регистр для изменения порядка операндов при делении. Для выражений, включающих вызовы функций, также необходимо зарезервировать регистр. Но все равно, существует возможность улучшения размера кода для большинства выражений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, вы видите, что получение лучшего кода не настолько трудно, но это усложняет наш транслятор... это сложность, без которой мы можем сейчас обойтись. По этой причине, я очень советую продолжать игнорировать вопросы эффективности в этой книге, усвоив, что мы действительно можем повысить качество кода не выбрасывая того, что уже сделано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующей главе я покажу вам как работать с переменными и вызовами функций. Я также покажу вам как легко добавить поддержку многосимвольных токенов и пробелов.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Снова выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последней главе мы изучили методы, используемые для синтаксического анализа и трансляции математических выражений в общей форме. Мы закончили созданием простого синтаксического анализатора, поддерживающего выражения произвольной сложности с двумя ограничениями:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разрешены только числовые показатели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Числовые показатели ограничены одиночной цифрой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы избавимся от этих ограничений. Мы также расширим то что сделали, добавив операции присваивания и вызовы функций. Запомните, однако, что второе ограничение было главным образом наложено нами самими... выбрано для удобства, чтобы облегчить себе жизнь и сконцентрироваться на фундаментальных принципах. Как вы увидите, от этого ограничения легко освободиться, так что не слишком задерживайтесь на этом. Мы будем использовать это прием пока он служит нам, уверенные в том, что сможем избавиться от него, когда будем готовы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Переменные\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большинство выражений, который мы встречаем на практике, включают переменные, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b * b + 4 * a * c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ни один компилятор нельзя считать достаточно хорошим, если он не работает с ними. К счастью, это тоже очень просто сделать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не забудьте, что в нашем синтаксическом анализаторе в настоящее время существуют два вида показателей: целочисленные константы и выражения в скобках. В нотации БНФ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <number> | (<expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "|" заменяет «или», означая, что любая из этих форм является допустимой. Запомните, также, что у нас нет проблемы в определении каждой их них… предсказывающим символом в одном случае является левая скобка "(" и цифра – в другом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно, не вызовет слишком большого удивления то, что переменная – это просто еще один вид показателя. Так что расширим БНФ следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <number> | (<expression>) | <variable>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И снова, здесь нет неоднозначности: если предсказывающий символ – буква, то это переменная, если цифра то число. Когда мы транслируем число, мы просто генерируем код для загрузки числа, как промежуточных данных, в D0. Сейчас мы делаем то же самое, только для переменной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Небольшое осложнение при генерации кода возникает из того факта, что большинство операционных систем для 68000, включая SK*DOS которую я использую, требуют чтобы код был написан в «переместимой» форме, что в основном означает что все должно быть PC-относительно. Формат для загрузки на этом языке будет следующим:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X(PC),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где X, конечно, имя переменной. Вооружившись этим, изменим текущую версию процедуры Factor следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + GetName + '(PC),D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я уже отмечал, как легко добавлять расширения в синтаксический анализатор благодаря способу его структурирования. Вы можете видеть, что это все еще остается действительным и сейчас. На этот раз это стоило нам всего двух дополнительных строк кода. Заметьте так же, как структура if-then-else точно соответствует синтаксическому уравнению БНФ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, откомпилируйте и протестируйте эту новую версию синтаксического анализатора. Это не слишком сильно повредило, не так ли?\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Функции\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть еще только один распространенный вид показателей, поддерживаемый большинством языков: вызов функции. В действительности, нам пока слишком рано иметь дела с функциями, потому что мы еще не обращались к вопросу передачи параметров. Более того, «настоящий» язык должен включать механизм поддержки более чем одного типа, одним из которых должен быть тип функции. Мы не имеем также и этого. Но все же я хотел бы работать с функциями сейчас по двум причинам. Во-первых, это позволит нам превратить компилятор во что-то очень близкое к конечному виду и, во вторых, это раскроет новую проблему, о которой очень стоит поговорить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До этого момента мы создавали то, что называется «предсказывающим синтаксическим анализатором». Это означает, что в любой точке мы можем, смотря на текущий предсказывающий символ, точно знать, что будет дальше. Но не в том случае когда мы добавляем функции. В каждом языке имеются некоторые правила присваивания имен, по которым составляется допустимый идентификатор. Наши правила пока просты, так как идентификатором является одна из букв "a"…"z". Проблема состоит в том, что имена переменных и имена функций подчиняются одним и тем же правилам. Поэтому как мы можем сказать кто из них кто? Один из способов требует, чтобы каждое из них было объявлено перед тем, как оно используется. Этот метод использует Pascal. Другой способ состоит в том, чтобы функция сопровождалась списком параметров (возможно пустым). Это правило, используемое в C.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока у нас нет механизма описания типов, давайте использовать правила C. Так как у нас также нет и механизма для работы с параметрами, мы можем поддерживать только пустые списки параметров, так что вызовы функций будут иметь следующую форму:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X().\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как мы пока не работаем со списками параметров, для вызова функций не нужно ничего дополнительно, и необходимо только выдавать BSR (вызов) вместо MOVE.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас существуют две варианта для ветки «If IsAlpha» при проверке в процедуре Factor. Давайте обработаем их в отдельной процедуре. Изменим процедуру Factor следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и вставим перед ней новую процедуру\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Ident;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Откомпилируйте и протестируйте эту версию. Обрабатывает ли она все правильные выражения и корректно отмечает неправильные?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важно отметить, что хотя наш анализатор больше не является предсказывающим анализаторов, это немного или совсем не добавляет сложностей при использовании нами метода рекурсивного спуска. В том месте, где процедура Factor находит идентификатор (букву), она не знает, является ли он именем переменной или именем функции, ни выполняет ее обработку. Она просто передает его в Ident и оставляет этой процедуре на рассмотрение. Ident, в свою очередь, просто прячет идентификатор и затем считывает еще один символ для того, чтобы решить с каким типом идентификатора он имеет дело.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запомните этот способ. Это очень мощное понятие и оно должно быть использовано всегда, когда вы встречаетесь с неоднозначной ситуацией, требующей заглядывания вперед. Даже если вам нужно рассмотреть несколько символов вперед, принцип все еще будет работать.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Подробнее об обработке ошибок\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется еще одна важная проблема, которую стоит отметить: обработка ошибок. Обратите внимание, что хотя синтаксический анализатор правильно отбрасывает (почти) каждое некорректное выражение, которое мы ему подбросим, со значимым сообщением об ошибке, в действительности мы не слишком много поработали для того, чтобы это происходило. Фактически во всей программе (от Ident до Expression) есть только два вызова подпрограммы обработки ошибок Expected. Но даже они не являются необходимыми… если вы посмотрите снова на процедуры Term и Expression, то увидите, что эти утверждения не выполнятся никогда. Я поместил их сюда ранее для небольшой подстраховки, но сейчас они более не нужны. Почему бы не удалить их сейчас?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но как мы получали такую хорошую обработку ошибок фактически бесплатно? Просто я тщательно старался избежать чтения символа непосредственно используя GetChar. Взамен я возложил на GetName, GetNum и Match выполнение всей обработки ошибок для меня. Проницательные читатели заметят, что некоторые вызовы Match (к примеру в Add и Subtract) также не нужны… мы уже знаем чем является символ к этому времени… но их присутствие сохраняет некоторую симметрию, и было бы хорошим правилом всегда использовать Match вместо GetChar.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выше я упомянул «почти». Есть случай, когда наша обработка ошибок оставляет желать лучшего. Пока что мы не сказали нашему синтаксическому анализатору как выглядит конец строки или что делать с вложенными пробелами. Поэтому пробел (или любой другой символ, не являющийся частью признаваемого набора символов) просто вызывает завершение работы анализатора, игнорируя нераспознанные символы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно рассудить, что в данном случае это приемлемое поведение. В «настоящем» компиляторе обычно присутствует еще одно утверждение, следующее после того, с которым мы работаем, так что любой символ, не обработанный как часть нашего выражения, будет или использоваться или отвергаться как часть следующего.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это также очень легко исправить, даже если это только временно. Все, что мы должны сделать – постановить, что выражение должно заканчиваться концом строки, то есть, возвратом каретки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы понять о чем я говорю, испробуйте входную строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1+2 <space> 3+4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Видите, как пробел был обработан как признак завершения? Чтобы заставить компилятор правильно отмечать это, добавьте строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if Look <> CR then Expected('Newline');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в основную программу, сразу после вызова Expression. Это отлавливает все левое во входном потоке. Не забудьте определить CR в разделе const:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CR = ^M;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно откомпилируйте программу и проверьте, что она делает то, что нужно.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Присваивание\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, к этому моменту мы имеем синтаксический анализатор, работающий очень хорошо. Я хотел бы подчеркнуть, что мы получили это, используя всего 88 строк выполнимого кода, не считая того, что было в Cradle. Откомпилированный объектный файл занял 4752 байта. Неплохо, учитывая то, что мы не слишком старались сохранять размеры как исходного так и объектного кода. Мы просто придерживались принципа KISS.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, анализ выражений не настолько хорош без возможности что-либо делать с его результатами. Выражения обычно (но не всегда) используются в операциях присваивания в форме:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <Ident> = <Expression>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы находимся на расстоянии вздоха от возможности анализировать операции присваивания, так что давайте сделаем этот последний шаг. Сразу после процедуры Expression добавьте следующую новую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание снова, что код полностью соответствует БНФ. И заметьте затем, что проверка ошибок была безболезненна и обработана GetName и Match.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Необходимость двух строк ассемблера возникает из-за особенности 68000, который требует такого вида конструкции для PC-относительного кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь измените вызов Expression в основной программе на Assigment. Это все, что нужно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фактически мы компилируем операторы присваивания! Если бы это был единственный вид операторов в языке, все, что нам нужно было бы сделать – поместить его в цикл и мы имели бы полноценный компилятор!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, это не единственный вид. Есть также немного таких элементов, как управляющие структуры (ветвления и циклы), процедуры, объявления и т.д. Но не унывайте. Арифметические выражения, с которыми мы имели дело, относятся к самым вызывающим элементам языка. По сравнению с тем, что мы уже сделали, управляющие структуры будут выглядеть простыми. Я расскажу о них в пятой главе. И все другие операторы поместятся в одной строчке, пока мы не забываем принцип KISS.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Многосимвольные токены \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой серии я тщательно ограничивал все, что мы делаем, односимвольными токенами, все время уверяя вас, что не составит проблемы расширить их до многосимвольных. Я не знаю, верили вы мне или нет… я действительно не обвинил бы вас, если бы вы были немного скептичны. Я буду продолжать использовать этот подход и в следующих главах, потому что это позволит избежать сложности. Но я хотел бы поддержать эту уверенность и показать вам, что это действительно легко сделать. В процессе этого мы также предусмотрим обработку вложенных пробелов. Прежде чем вы сделаете следующие несколько изменений, сохраните текущую версию синтаксического анализатора под другим именем. Я буду использовать ее в следующей главе и мы будем работать с односимвольной версией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большинство компиляторов выделяют обработку входного потока в отдельный модуль, называемый лексическим анализатором (сканером). Идея состоит в том, что сканер работает со всей последовательностью символов во входном потоке и возвращает отдельные единицы (лексемы) потока. Возможно придет время, когда мы также захотим сделать что-то вроде этого, но сейчас в этом нет необходимости. Мы можем обрабатывать многосимвольные токены, которые нам нужны, с помощью небольших локальных изменений в GetName и GetNum.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обычно признаком идентификатора является то, что первый символ должен быть буквой, но остальная часть может быть алфавитно-цифровой (буквы и цифры). Для работы с ними нам нужна другая функция:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alphanumeric \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавьте эту функцию в анализатор. Я поместил ее сразу после IsDigit. Вы можете также включить ее как постоянного члена в Cradle.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нам необходимо изменить функцию GetName так, чтобы она возвращала строку вместо символа:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Token: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Token + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := Token;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично измените GetNum следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достаточно удивительно, что это фактически все необходимые изменения! Локальная переменная Name в процедурах Ident и Assignment были первоначально объявлены как «char» и теперь должны быть объявлены как string[8]. (Ясно, что мы могли бы сделать длину строки больше, если бы захотели, но большинство ассемблеров в любом случае ограничивают длину.) Внесите эти изменения и затем откомпилируйте и протестируйте. Сейчас вы верите, что это просто?\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Пробелы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде, чем мы оставим этот синтаксический анализатор на некоторое время, давайте обратимся к проблеме пробелов. На данный момент, синтаксический анализатор выразит недовольство (или просто завершит работу) на одиночном символе пробела, вставленном где-нибудь во входном потоке. Это довольно недружелюбное поведение. Так что давайте немного усовершенствуем анализатор, избавившись от этого последнего ограничения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ключом к облегчению обработки пробелов является введение простого правила для того, как синтаксический анализатор должен обрабатывать входной поток и использование этого правила везде. До настоящего времени, поскольку пробелы не были разрешены, у нас была возможность знать, что после каждого действия синтаксического анализатора предсказывающий символ Look содержит следующий значимый символ, поэтому мы могли немедленно выполнять его проверку. Наш проект был основан на этом принципе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это все еще звучит для меня как хорошее правило, поэтому мы будем его использовать. Это означает, что каждая подпрограмма, которая продвигает входной поток, должна пропустить пробелы и оставить следующий символ (не являющийся пробелом) в Look. К счастью, так как мы были осторожны и использовали GetName, GetNum, и Match для большей части обработки входного потока, только эти три процедуры (плюс Init) необходимо изменить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неудивительно, что мы начинаем с еще одной подпрограммы распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам также нужна процедура, «съедающая» символы пробела до тех пор, пока не найдет отличный от пробела символ:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас добавьте вызовы SkipWhite в Match, GetName и GetNum как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> x then Expected('''' + x + '''')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Token: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := ''; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name'); \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Token + UpCase(Look); \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := Token; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := ''; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer'); \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Value; \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, как я немного реорганизовал Match без изменения функциональности.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, мы должны пропустить начальные пробелы в том месте, где мы «запускаем помпу» в Init:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Внесите эти изменения и повторно откомпилируйте программу. Вы обнаружите, что необходимо переместить Match ниже SkipWhite чтобы избежать сообщение об ошибке от компилятора Pascal. Протестируйте программу как всегда, чтобы удостовериться, что она работает правильно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку мы сделали довольно много изменений в течение этого урока, ниже я воспроизвожу полный текст синтаксического анализатора:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program parse;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alphanumeric \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> x then Expected('''' + x + '''')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Token: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Token + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := Token;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Ident;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name:= GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXS.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['*', '/'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 If Look <> CR then Expected('NewLine');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь синтаксический анализатор закончен. Он получил все возможности, которые мы можем разместить в однострочном «компиляторе». Сохраните его в безопасном месте. В следующий раз мы перейдем к новой теме, но мы все рано будем некоторое время говорить о выражениях. В следующей главе я планирую рассказать немного об интерпретаторах в противоположность компиляторам и показать вам как немного изменяется структура синтаксического анализатора в зависимости от изменения характера принимаемых действий. Информация, которую мы рассмотрим, хорошо послужит нам позднее, даже если вы не интересуетесь интерпретаторами. Увидимся в следующий раз.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Интерпретаторы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В трех первых частях этой серии мы рассмотрели синтаксический анализ и компиляцию математических выражений, постепенно и методично пройдя от очень простых односимвольных «выражений», состоящих из одного терма, через выражения в более общей форме и закончив достаточно полным синтаксическим анализатором, способным анализировать и транслировать операции присваивания с многосимвольными токенами, вложенными пробелами и вызовами функций. Сейчас я собираюсь провести вас сквозь этот процесс еще раз, но уже с целью интерпретации а не компиляции объектного кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если эта серия о компиляторах, то почему мы должны беспокоиться об интерпретаторах? Просто я хочу чтобы вы увидели как изменяется характер синтаксического анализатора при изменении целей. Я также хочу объединить понятия этих двух типов трансляторов, чтобы вы могли видеть не только различия но и сходства.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим следующее присваивание:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x = 2 * y + 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В компиляторе мы хотим заставить центральный процессор выполнить это присваивание во время выполнения. Сам транслятор не выполняет никаких арифметических операций… он только выдает объектный код, который заставит процессор сделать это когда код выполнится. В примере выше компилятор выдал бы код для вычисления значения выражения и сохранения результата в переменной x.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для интерпретатора, напротив, никакого объектного кода не генерируется. Вместо этого арифметические операции выполняются немедленно как только происходит синтаксический анализ. К примеру, когда синтаксический анализ присваивания завершен, x будет содержать новое значение.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод, который мы применяем во всей этой серии, называется «синтаксически-управляемым переводом». Как вы знаете к настоящему времен, структура синтаксического анализатора очень близко привязана к синтаксису анализируемых нами конструкций. Мы создали процедуры на Pascal, которые распознают каждую конструкцию языка. Каждая из этих конструкций (и процедур) связана с соответствующим «действием», которое выполняет все необходимое как только конструкция распознана. В нашем компиляторе каждое действие включает выдачу объектного кода для выполнения позднее во время исполнения. В интерпретаторе каждое действие включает что-то для немедленного выполнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что я хотел бы, чтобы вы увидели, это то, что план… структура… синтаксического анализатора не меняется. Изменяются только действия. Так что, если вы можете написать интерпретатор для данного языка, то вы можете также написать и компилятор, и наоборот. Однако, как вы увидите, имеются и отличия, и значительные. Поскольку действия различны, процедуры, завершающие распознавание, пишутся по-разному. Характерно, что в интерпретаторе завершающие подпрограммы распознавания написаны как функции, возвращающие числовое значение вызвавшей их программе. Ни одна из подпрограмм анализа нашего компилятора не делает этого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш компилятор, фактически, это то, что мы могли бы назвать «чистым» компилятором. Как только конструкция распознана, объектный код выдается немедленно. (Это одна из причин, по которым код не очень эффективный.) Интерпретатор, который мы собираемся построить, является чистым интерпретаторов в том смысле, что здесь нет никакой трансляции типа «токенизации», выполняемой над исходным текстом. Это две крайности трансляции. В реальном мире трансляторы не являются такими чистыми, но стремятся использовать часть каждой методики.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я могу привести несколько примеров. Я уже упомянул один: большинство интерпретаторов, типа Microsoft BASIC, к примеру, транслируют исходный текст (токенизируют его) в промежуточную форму, чтобы было легче выполнять синтаксический анализ в реальном режиме времени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой пример – ассемблер. Целью ассемблера, конечно, является получение объектного кода и он обычно выполняет это по однозначному принципу: одна инструкция на строку исходного кода. Но почти все ассемблеры также разрешают использовать выражения как параметры. В этом случае выражения всегда являются константами, и ассемблер не предназначен выдавать для них объектный код. Скорее он «интерпретирует» выражение и вычисляет соответствующее значение, которое фактически и выдается с объектным кодом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фактически, мы могли бы использовать часть этого сами. Транслятор, который мы создали в предыдущей главе, будет покорно выплевывать объектный код для сложных выражений, даже если каждый терм в выражении будет константой. В этом случае было бы гораздо лучше, если бы транслятор вел себя немного как интерпретатор и просто вычислял соответствующее значение константы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В теории компиляции существует понятие, называемое «ленивой» трансляцией. Идея состоит в том, что вы не просто выдаете код при каждом действии. Фактически, в крайнем случае вы не выдаете что-либо вообще до тех пор, пока это не будет абсолютно необходимо. Для выполнения этого, действия, связанные с подпрограммами анализа, обычно не просто выдают код. Иногда они это делают, но часто они просто возвращают информацию обратно вызвавшей программе. Вооружившись этой информацией, вызывающая программа может затем сделать лучший выбор того, что делать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К примеру, для данного выражения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x = x + 3 – 2 – (5 – 4)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 наш компилятор будет покорно выплевывать поток из 18 инструкций для загрузки каждого параметра в регистры, выполнения арифметических действий и сохранения результата. Ленивая оценка распознала бы, что выражение, содержащее константы, может быть рассчитано во время компиляции и уменьшила бы выражение до\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x = x + 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Даже ленивая оценка была бы затем достаточно умной, чтобы понять, что это эквивалентно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x = x,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что совсем не требует никаких действий. Мы смогли уменьшить 18 инструкций до нуля!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что нет никакой возможности оптимизировать таким способом наш компилятор, потому что каждое действие выполняется в нем немедленно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ленивая оценка выражений может произвести значительно лучший объектный код чем тот который мы могли произвести. Я, тем не менее, предупреждаю вас: это значительно усложняет код синтаксического анализатора, потому что каждая подпрограмма теперь должна принять решение относительно того, выдать объектный код или нет. Ленивая оценка конечно же названа так не потому, что она проще для создателей компиляторов!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как мы действуем в основном по принципу KISS, я не буду более углубляться в эту тему. Я только хочу, чтобы вы знали, что вы можете получить некоторую оптимизацию кода, объединяя методы компиляции и интерпретации. В частности Вы должны знать, что подпрограммы синтаксического анализа в более интеллектуальном трансляторе обычно что-то возвращают вызвавшей их программе и иногда сами ожидают этого. Эта главная причина обсуждения интерпретаторов в этой главе.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Интерпретатор\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, теперь, когда вы знаете почему мы принялись за все это, давайте начнем. Просто для того, чтобы дать вам практику, мы начнем с пустого Сradle и создадим транслятор заново. На этот раз, конечно, мы сможем двигаться немного быстрее.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как сейчас мы собираемся выполнять арифметические действия, то первое, что мы должны сделать – изменить функцию GetNum, которая до настоящего момента всегда возвращала символ (или строку). Лучше если сейчас она будет возвращать целое число. Сделайте копию Cradle (на всякий случай не изменяйте сам Cradle!!) и модифицируйте GetNum следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Ord(Look) – Ord('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем напишите следующую версию Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И, наконец, вставьте\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Writeln(Expression);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в конец основной программы. Теперь откомпилируйте и протестируйте.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все, что эта программа делает – это «анализ» и трансляция «выражения», состоящего из одиночного целого числа. Как обычно, вы должны удостовериться, что она обрабатывает числа от 0 до 9 и выдает сообщение об ошибке для чего-либо другого. Это не должно занять у вас много времени!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте расширим ее, включив поддержку операций сложения. Измените Expression так:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := 0\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value – GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура Expression, конечно, схожа с тем, что мы делали ранее, так что мы не будем иметь слишком много проблем при ее отладке. Тем не менее это была серьезная разработка, не так ли? Процедуры Add и Subtract исчезли! Причина в том, что для выполнения необходимых действий нужны оба аргумента операции. Я мог бы сохранить эти процедуры и передавать в них значение выражения на данный момент, содержащееся в Value. Но мне показалось более правильным оставить Value как строго локальную переменную, что означает, что код для Add и Subtract должен быть помещен вместе. Этот результат наводит на мысль, что хотя разработанная нами структура была хорошей и проверенной для нашей бесхитростной схемы трансляции, она возможно не могла бы использоваться с ленивой оценкой. Эту небольшую интересную новость нам возможно необходимо иметь в виду в будущем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, транслятор работает? Тогда давайте сделаем следующий шаг. Несложно понять, что процедура Term должна выглядеть также. Замените каждый вызов GetNum в функции Expression на вызов Term и затем наберите следующую версию Term:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Term: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['*', '/'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value * GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value div GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь испробуйте. Не забудьте двух вещей: во-первых мы имеем дело с целочисленным делением, поэтому, например, 1/3 выдаст ноль. Во-вторых, даже если мы можем получать на выходе многозначные числа, входные числа все еще ограничены одиночной цифрой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас это выглядит как глупое ограничение, так как мы уже видели как легко может быть расширена функция GetNum. Так что давайте исправим ее прямо сейчас. Вот новая версия:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Value: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := 10 * Value + Ord(Look) – Ord('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы откомпилировали и протестировали эту версию интерпретатора, следующим шагом должна быть установка функции Factor, поддерживающей выражения в скобках. Мы задержимся немного дольше на именах переменных. Сначала измените ссылку на GetNum в функции Term, чтобы вместо нее вызывалась функция Factor. Теперь наберите следующую версию Factor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: integer; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Factor: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это было довольно легко, а? Мы быстро пришли к полезному интерпретатору.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Немного философии\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем двинуться дальше, я бы хотел обратить ваше внимание на кое-что. Я говорю о концепции, которую мы использовали на всех этих уроках, но которую я явно не упомянул до сих пор. Я думаю, что пришло время сделать это, так как эта концепция настолько полезная и настолько мощная, что она стирает все различия между тривиально простым синтаксическим анализатором и тем, который слишком сложен для того, чтобы иметь с ним дело.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ранние дни технологии компиляции люди тратили ужасно много времени на выяснение того, как работать с такими вещами как приоритет операторов… способа, который определяет приоритет операторов умножения и деления над сложением и вычитанием и т.п. Я помню одного своего коллегу лет тридцать назад и как возбужденно он выяснял как это делается. Используемый им метод предусматривал создание двух стеков, в которые вы помещали оператор или операнд. С каждым оператором был связан уровень приоритета и правила требовали, чтобы вы фактически выполняли операцию («уменьшающую» стек) если уровень приоритета на вершине стека был корректным. Чтобы сделать жизнь более интересной оператор типа ")" имел различные приоритеты в зависимости от того, был он уже в стеке или нет. Вы должны были дать ему одно значение перед тем как поместите в стек и другое, когда решите извлечь из стека. Просто для эксперимента я самостоятельно поработал со всем этим несколько лет назад и могу сказать вам, что это очень сложно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы не делали что-либо подобное. Фактически, к настоящему времени синтаксический анализ арифметических выражений должен походить на детскую игру. Как мы оказались настолько удачными? И куда делся стек приоритетов?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подобная вещь происходит в нашем интерпретаторе выше. Вы просто знаете, что для того, чтобы выполнить вычисления арифметических выражений (в противоположность их анализу), должны иметься числа, помещенные в стек. Но где стек?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, в учебниках по компиляторам имеются разделы, где обсуждены стеки и другие структуры. В другом передовом методе синтаксического анализа (LR) используется явный стек. Фактически этот метод очень похож на старый способ вычисления арифметических выражений. Другая концепция – это синтаксическое дерево. Авторы любят рисовать диаграммы из токенов в выражении объединенные в дерево с операторами во внутренних узлах. И снова, где в нашем методе деревья и стеки? Мы не видели ничего такого. Во всех случаях ответ в том, что эти структуры не явные а неявные. В любом машинном языке имеется стек, используемый каждый раз, когда вы вызываете подпрограмму. Каждый раз, когда вызывается подпрограмма, адрес возврата помещается в стек ЦПУ. В конце подпрограммы адрес выталкивается из стека и управление передается на этот адрес. В рекурсивном языке, таком как Pascal, могут также иметься локальные данные, помещенные в стек, и они также возвращаются когда это необходимо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например функция Expression содержит локальный параметр, названный Value, которому присваивается значение при вызове Term. Предположим, при следующем вызове Term для второго аргумента, что Term вызывает Factor, который рекурсивно вызывает Expression снова. Этот «экземпляр» Expression получает другое значение для его копии Value. Что случится с первым значением Value? Ответ: он все еще в стеке и будет здесь снова, когда мы возвратимся из нашей последовательности вызовов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другими словами, причина, по которой это выглядит так просто в том, что мы максимально использовали ресурсы языка. Уровни иерархии и синтаксические деревья присутствуют здесь, все правильно, но они скрыты внутри структуры синтаксического анализатора и о них заботится порядок в котором вызываются различные процедуры. Теперь, когда вы увидели, как мы делаем это, возможно трудно будет придумать как сделать это каким-либо другим способом. Но я могу сказать вам, что это заняло много лет для создателей компиляторов. Первые компиляторы были слишком сложными. Забавно, как работа становится легче с небольшой практикой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вывод из всего того, что я привел здесь, служит и уроком и предупреждением. Урок: дела могут быть простыми если вы приметесь за них с правильной стороны. Предупреждение: смотрите, что делаете. Если вы делаете что-либо самостоятельно и начинаете испытывать потребность в отдельном стеке или дереве, возможно это время спросить себя, правильно ли вы смотрите на вещи. Возможно вы просто не используете возможностей языка так как могли бы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий шаг – добавление имен переменных. Сейчас, однако, мы имеем небольшую проблему. В случае с компилятором мы не имели проблем при работе с именами переменных… мы просто выдавали эти имена ассемблеру и позволяли остальной части программы заботиться о распределении для них памяти. Здесь же, напротив, у нас должна быть возможность извлекать значения переменных и возвращать их как значение функции Factor. Нам необходим механизм хранения этих переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ранние дни персональных компьютеров существовал Tiny Basic. Он имел в общей сложности 26 возможных переменных: одна на каждую букву алфавита. Это хорошо соответствует нашей концепции односимвольных токенов, так что мы испробуем этот же прием. В начале интерпретатора, сразу после объявления переменной Look, вставьте строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Table: Array['A'..'Z'] of integer;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы также должны инициализировать массив, поэтому добавьте следующую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize the Variable Area \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure InitTable;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Table[i] := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы также должны вставить вызов InitTable в процедуру Init. Не забудьте сделать это, иначе результат может удивить вас!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда у нас есть массив переменных, мы можем модифицировать Factor так, чтобы он их использовал. Так как мы не имеем (пока) способа для установки значения переменной, Factor будет всегда возвращать для них нулевые значения, но давайте двинемся дальше и расширим его. Вот новая версия:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: integer; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Factor: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := Table[GetName]\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как всегда откомпилируйте и протестируйте эту версию программы Даже притом, что все переменные сейчас равны нулю, по крайней мере мы можем правильно анализировать законченные выражения, так же как и отлавливать любые неправильно оформленные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я предполагаю вы уже знаете следующий шаг: мы должны добавить операции присваивания, чтобы мы могли помещать что-нибудь в переменные. Сейчас давайте будем «однострочниками», хотя скоро мы сможем обрабатывать множество операторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Операция присваивания похожа на то, что мы делали раньше:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Table[Name] := Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы протестировать ее, я добавил временный оператор write в основную программу для вывода значения A. Затем я протестировал ее с различными присваиваниями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, интерпретируемый язык, который может воспринимать только одну строку программы не имеет большой ценности. Поэтому нам нужно обрабатывать множество утверждений. Это просто означает что необходимо поместить цикл вокруг вызова Assignment. Давайте сделаем это сейчас. Но что должно быть критерием выхода из цикла? Рад, что вы спросили, потому что это поднимает вопрос, который мы были способны игнорировать до сих пор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одной из наиболее сложных вещей в любом трансляторе является определение момента когда необходимо выйти из данной конструкции и продолжить выполнение. Пока это не было для нас проблемой, потому что мы допускали только одну конструкцию… или выражение или операцию присваивания. Когда мы начинаем добавлять циклы и различные виды операторов, вы найдете, что мы должны быть очень осторожны, чтобы они завершались правильно. Если мы помещаем наш интерпретатор в цикл, то нам нужен способ для выхода из него. В прерывании по концу строки нет ничего хорошего, поскольку с его помощью мы переходим к следующей строке. Мы всегда могли позволить нераспознаваемым символам прерывать выполнение, но это приводило бы к завершению каждой программы сообщением об ошибке, что конечно выглядит несерьезно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам нужен завершающий символ. Я выступаю за завершающую точку в Pascal ("."). Небольшое осложнение состоит в том, что Turbo Pascal завершает каждую нормальную строку двумя символами: возврат каретки (CR) и перевод строки (LF). В конце каждой строки мы должны «съедать» эти символы перед обработкой следующей. Естественным способом было бы сделать это в процедуре Match за исключением того, что сообщение об ошибке Match выводит ожидаемые символы, что для CR и LF не будет выглядеть так хорошо. Для этого нам нужна специальная процедура, которую мы, без сомнения, будем использовать много раз. Вот она:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Skip Over a Newline \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вставьте эту процедуру в любом удобном месте… я поместил ее сразу после Match. Теперь перепишите основную программу, чтобы она выглядела следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Look = '.';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что проверка на CR теперь исчезла и что также нет проверки на ошибку непосредственно внутри NewLine. Это нормально… все оставшиеся фиктивные символы будут отловлены в начале следующей операции присваивания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, сейчас мы имеем функционирующий интерпретатор. Однако, это не дает нам много хорошего, так как у нас нет никакого способа для ввода или вывода данных. Уверен что нам помогут несколько подпрограмм ввода/вывода!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда давайте завершим этот урок добавив подпрограммы ввода/вывода. Так как мы придерживаемся односимвольных токенов, я буду использовать знак "?" для замены операции чтения, знак "!" для операции записи и символ, немедленно следующий после них, который будет использоваться как односимвольный «список параметров». Вот эти подпрограммы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Input Routine \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Input;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('?');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Table[GetName]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output Routine \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Output;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Table[GetName]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я полагаю они не очень причудливы… например нет никакого символа приглашения при вводе… но они делают свою работу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующие изменения в основной программе показаны ниже. Обратите внимание, что мы используем обычный прием – оператор выбора по текущему предсказывающему символу, чтобы решить что делать.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '?': Input;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '!': Output;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Look = '.';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вы закончили создание настоящего, работающего интерпретатора. Он довольно скудный, но работает совсем как «большой мальчик». Он включает три вида операторов (и может различить их!), 26 переменных и операторы ввода/вывода. Единственное, в чем он действительно испытывает недостаток – это операторы управления, подпрограммы и некоторые виды функций для редактирования программы. Функции редактирования программ я собираюсь пропустить. В конце концов, мы здесь не для того, чтобы создать готовый продукт, а чтобы учиться. Управляющие операторы мы раскроем в следующей главе, а подпрограммы вскоре после нее. Я стремлюсь продолжать дальше, поэтому мы оставим интерпретатор в его текущем состоянии.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я надеюсь, к настоящему времени вы убедились, что ограничение имен одним символом и обработка пробелов это вещи о которых легко позаботиться, как мы сделали это на последнем уроке. На этот раз, если вам захотелось поиграть с этими расширениями, будьте моим гостем… они «оставлены как упражнение для студента». Увидимся в следующий раз.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Управляющие конструкции\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В четырех первых главах этой серии мы сконцентрировали свое внимание на синтаксическом анализе математических выражений и операций присваивания. В этой главе мы остановимся на новой и захватывающей теме: синтаксическом анализе и трансляции управляющих конструкций таких как, например, операторы IF.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта тема дорога для моего сердца, потому что является для меня поворотной точкой. Я играл с синтаксическим анализом выражений также как мы делали это в этой серии, но я все же чувствовал, что нахожусь еще очень далеко от возможности поддержки полного языка. В конце концов, реальные языки имеют ветвления, циклы, подпрограммы и все такое. Возможно вы разделяли некоторые из этих мыслей. Некоторое время назад, тем не менее, я должен был реализовать управляющие конструкции для структурного препроцессора ассемблера, который я писал. Вообразите мое удивление, когда я обнаружил, что это было гораздо проще, чем синтаксический анализ выражений, через который я уже прошел. Я помню подумал «Эй, это же просто!». После того, как мы закончим этот урок, я готов поспорить, что вы будете думать так же.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 План\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее мы снова начнем с пустого Cradle и, как мы делали уже дважды до этого, будем строить программу последовательно. Мы также сохраним концепцию односимвольных токенов, которая так хорошо служила нам до настоящего времени. Это означает, что «код» будет выглядеть немного забавным с "i" вместо IF, "w" вместо WHILE и т.д. Но это поможет нам узнать основные понятия не беспокоясь о лексическом анализе. Не бойтесь... в конечном счете мы увидим что-то похожее на «настоящий» код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также не хочу, чтобы мы увязли в работе с какими либо операторами кроме ветвлений, такими как операции присваивания, с которыми мы уже работали. Мы уже показали, что можем обрабатывать их, так что нет никакого смысла таскать этот лишний багаж в течение предстоящих занятий. Вместо этого я буду использовать анонимный оператор «other» для замены неуправляющих операторов. Мы должны генерировать для них некоторый обьектный код (мы возвращаемся к компиляции а не интерпретации), так что за неимением чего-либо другого я буду просто повторять входной символ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, тогда, начав с еще одной копии Cradle, давайте определим процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an «Other» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь включим ее вызов в основную программу таким образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запустите программу и посмотрите, что вы получили. Не очень захватывающе, не так ли? Но не зацикливайтесь на этом, это только начало, результат будет лучше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, что нам нужно – это возможность работать с более чем одним оператором, так как однострочные ветвления довольно ограничены. Мы делали это на последнем занятии по интерпретации, но сейчас давайте будем немного более формальными. Рассмотрите следующую БНФ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program> ::= <block> END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= [ <statement> ]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это означает, что программа определена как блок, завершаемый утверждением END. Блок, в свою очередь, состоит из нуля или более операторов. Пока у нас есть только один вид операторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что является признаком окончания блока? Это просто любая конструкция, не являющаяся оператором «other». Сейчас это только утверждение END.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вооружившись этими идеями, мы можем приступать к созданию нашего синтаксического анализатора. Код для program (мы должны назвать его DoProgram, иначе Pascal будет ругаться) следующий:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> 'e' then Expected('End');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что я выдаю ассемблеру команду «END», что своего рода расставляет знаки препинания в выходном коде и заставляет чувствовать, что мы анализируем здесь законченную программу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код для Block:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Из формы процедуры вы видите, что мы собираемся постепенно ее расширять!)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, вставьте эти подпрограммы в вашу программу. Замените вызов Block в основной программе на вызов DoProgram. Теперь испытайте ее и посмотрите как она работает. Хорошо, все еще не так много, но мы становимся все ближе.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Немного основ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем мы начнем определять различные управляющие конструкции, мы должны положить немного более прочное основание. Во-первых, предупреждаю: я не буду использовать для этих конструкций тот же самый синтаксис с которым вы знакомы по Паскалю или Си. К примеру синтаксис Паскаль для IF такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF <condition> THEN <statement>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (где <statement>, конечно, может быть составным.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис C аналогичен этому:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF ( <condition> ) <statement>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вместо этого я буду использовать нечто более похожее на Ada:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF <condition> <block> ENDIF\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другими словами, конструкция IF имеет специфический символ завершения. Это позволит избежать висячих else Паскаля и Си и также предотвращает необходимость использовать скобки \{\} или begin-end. Синтаксис, который я вам здесь показываю, фактически является синтаксисом языка KISS, который я буду детализировать в следующих главах. Другие конструкции также будут немного отличаться. Это не должно быть для вас большой проблемой. Как только вы увидите, как это делается, вы поймете, что в действительности не имеет большого значения, какой конкретный синтаксис используется. Как только синтаксис определен, включить его в код достаточно просто.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, все конструкции, с которыми мы будем иметь дело, включают передачу управления, что на уровне ассемблера означает условные и/или безусловные переходы. К примеру простой оператор IF:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF <condition> A ENDIF B...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 должен быть переведен в:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если условие не выполнено то переход на L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L: B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно, что нам понадобятся несколько процедур, которые помогут нам работать с этими переходами. Ниже я определил две из них. Процедура NewLabel генерирует уникальные метки. Это сделано с помощью простого способа называть каждую метку 'Lnn', где nn – это номер метки, начинающийся с нуля. Процедура PostLabel просто выводит метки в соответствующем месте.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот эти две подпрограммы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что мы добавили новую глобальную переменную LCount, так что вы должны изменить раздел описания переменных в начале программы, следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lcount: integer; \{ Label Counter \}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Также добавьте следующий дополнительный инициализирующий код в Init:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount := 0;\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Не забудьте сделать это, иначе ваши метки будут выглядеть действительно странными!).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом месте я также хотел бы показать вам новый вид нотации. Если вы сравните форму оператора IF, указанную выше, с ассемблерным кодом, который должен быть получен, то вы можете увидеть, что существуют некоторые определенные действия, связанные с каждым ключевым словом в операторе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF: Сначала получить условие и выдать код для него. Затем создать уникальную метку и выдать переход если условие ложно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDIF: Выдать метку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти действия могут быть показаны очень кратко, если мы запишем синтаксис таким образом: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <condition> \{ Condition; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = NewLabel; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Emit(Branch False to L); \} \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDIF \{ PostLabel(L) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это пример синтаксически-управляемого перевода. Мы уже делали все это... мы просто никогда прежде не записывали это таким образом. Содержимое фигурных скобок представляет собой действия, которые будут выполняться. Хорошо в этом способе представления то, что он не только показывает что мы должны распознать, но также и действия, которые мы должны выполнить и в каком порядке. Как только мы получаем такой синтаксис, код возникает почти сам собой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Почти единственное, что осталось сделать – конкретизировать то, что мы подразумеваем под «Переход если условие ложно».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я полагаю, что должен быть код, выполняющийся для <condition>, который будет выполнять булеву алгебру и вычислять некоторый результат. Он также должен установить флажки условий, соответствующие этому результату. Теперь, обычным соглашением для булевых переменных является использование 0000 для представления значения «ложь» и какого-либо другого значения (кто-то использует FFFF, кто-то 0001) для представления «истины».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процессор 68000 устанавливает флажки условий всякий раз, когда любые данные перемещаются или рассчитываются. Если данные равны 0000 (что соответствует условию ложь, запомните) будет установлен флажок ноль. Код для «перехода по нулю» – BEQ. Таким образом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEQ <=> Переход если ложь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BNE <=> Переход если истина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По природе вещей большинство ветвлений, которые мы увидим, будут BEQ... мы будем обходить вокруг кода, который должен выполняться когда условие истинно.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Оператор IF\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После этого небольшого пояснения метода мы наконец готовы начать программирование синтаксического анализатора для условного оператора. Фактически, мы уже почти сделали это! Как обычно я буду использовать наш односимвольный подход, с символом "i" вместо «IF» и "e" вместо «ENDIF» (также как и END... это двойственная природа не вызывает никакого беспорядка). Я также пока полностью пропущу символ для условия ветвления, который мы все еще должны определить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код для DoIf:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавьте эту подпрограмму в вашу программу и измените Block так, чтобы он ссылался на нее как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'o': Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на обращение к процедуре Condition. В конечном итоге мы напишем подпрограмму, которая сможет анализировать и транслировать любое логическое условие которое мы ей дадим. Но это уже тема для отдельной главы (фактически следующей). А сейчас давайте просто заменим ее макетом, который выдает некоторый текст. Напишите следующую подпрограмму:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Condition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ This version is a dummy \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Procedure Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('<condition>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вставьте эту процедуру в вашу программу как раз перед DoIf. Теперь запустите программу. Испробуйте строку типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 aibece\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, синтаксический анализатор, кажется, распознает конструкцию и вставляет объектный код в правильных местах. Теперь попробуйте набор вложенных IF:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 aibicedefe\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Он начинает все более походить на настоящий, не так ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда у нас есть общая идея (и инструменты такие как нотация и процедуры NewLabel и PostLabel) проще пареной репы расширить синтаксический анализатор для поддержки и других конструкций. Первое (а также и одно из самых сложных) это добавление условия ELSE в IF. В БНФ это выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF <condition> <block> [ ELSE <block>] ENDIF\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложность возникает просто потому, что здесь присутствует необязательное условие, которого нет в других конструкциях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующий выходной код должен быть таким: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <condition> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEQ L1 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BRA L2 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1: <block> \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2: ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это приводит нас к следующей синтаксически управляемой схеме перевода:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <condition> \{ L1 = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Emit(BEQ L1) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ELSE \{ Emit(BRA L2);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L1) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDIF \{ PostLabel(L2) \} \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравнение этого со случаем IF без ELSE дает нам понимание того, как обрабатывать обе эти ситуации. Код ниже выполняет это. (Обратите внимание, что использую "l" вместо «ELSE» так как "e" имеет другое назначение):\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы получили его. Законченый анализатор/транслятор в 19 строк кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас протестируйте его. Испробуйте что-нибудь типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 aiblcede\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работает? Теперь, только для того, чтобы убедиться, что мы ничего не испортили и случай с IF без ELSE тоже будет обрабатываться, введите\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 aibece\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь испробуйте несколько вложенных IF. Испытайте что-нибудь на ваш выбор, включая несколько неправильных утверждений. Только запомните, что 'e' не является допустимым оператором «other».\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Оператор WHILE\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий вид оператора должен быть простым, так как мы уже имеем опыт. Синтаксис, который я выбрал для оператора WHILE следующий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WHILE <condition> <block> ENDWHILE\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Знаю, знаю, мы действительно не нуждаемся в отдельных видах ограничителей для каждой конструкции... вы можете видеть, что фактически в нашей односимвольной версии 'e' используется для всех из них. Но я также помню множество сессий отладки в Паскале, пытаясь отследить своенравный END который по мнению компилятора я хотел поместить где-нибудь еще. По своему опыту знаю, что специфичные и уникальные ключевые слова, хотя они и добавляются к словарю языка, дают небольшую защиту от ошибок, которая стоит дополнительной работы создателей компиляторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь рассмотрите, во что должен траслироваться WHILE: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1: <condition>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEQ L2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BRA L1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и прежде, сравнение этих двух представлений дает нам действия, необходимые на каждом этапе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WHILE \{ L1 = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L1) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <condition> \{ Emit(BEQ L2) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDWHILE \{ Emit(BRA L1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L2) \} \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код выходит непосредственно из синтаксиса:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('w');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как мы получили новый оператор, мы должны добавить его вызов в процедуру Block:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Никаких других изменений не требуется.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, протестируйте новую программу. Заметьте, что на этот раз код <condition> находится внутри верхней метки, как раз там, где нам надо. Попробуйте несколько вложенных циклов. Испробуйте циклы внутри IF и IF внутри циклов. Если вы немного напутаете то, что вы должны набирать, не смущайтесь: вы пишите ошибки и в других языках, не правда ли? Код будет выглядеть более осмысленным, когда мы получим полные ключевые слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я надеюсь, что к настоящему времени вы начинаете понимать, что это действительно просто. Все, что нам необходимо было сделать для того, чтобы создать новую конструкцию, это разработать ее синтаксически-управляемый перевод. Код возникает из него, и это не влияет на другие подпрограммы. Как только вы почувствуете это, вы увидите, что можете добавлять новые конструкции почти также быстро, как вы можете их придумывать.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Оператор LOOP\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы могли бы остановиться на этом и иметь работающий язык. Много раз было показано, что языка высокого уровня всего с двумя конструкциями IF и WHILE достаточно для написания структурного кода. Но раз уж мы начали, то давайте немного расширим репертуар.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта конструкция даже проще, так как она совсем не имеет проверки условия... это бесконечный цикл. Имеет ли смысл такой цикл? Немного сам по себе, но позднее мы собираемся добавить команду BREAK, которая даст нам способ выхода из цикла. Она делает язык значительно более богатым, чем Паскаль, который не имеет команды выхода из цикла и также позволяет избежать забавных конструкций типа WHILE(1) или WHILE TRUE в C и Паскале.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис прост:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LOOP <block> ENDLOOP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксически управляемый перевод:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LOOP \{ L = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDLOOP \{ Emit(BRA L \} \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующий код показан ниже. Так как мы уже использовали "l" для ELSE на этот раз я использовал последнюю букву "p" как «ключевое слово».\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a LOOP Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После того, как вы вставите эту подпрограмму, не забудьте добавить строчку в Block для ее вызова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 REPEAT-UNTIL\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется одна конструкция, которую я взял напрямую из Паскаля. Синтаксис:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 REPEAT <block> UNTIL <condition>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и синтаксически-управляемый перевод:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 REPEAT \{ L = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UNTIL\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <condition> \{ Emit(BEQ L) \}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Как обычно, код вытекает отсюда довольно легко:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a REPEAT Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('r');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('u');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и прежде, мы должны добавить вызов DoRepeat в Block. Хотя на этот раз есть различия. Я решил использовать "r" вместо REPEAT (естественно), но я также решил использовать "u" вместо UNTIL. Это означает, что "u" должен быть добавлен к множеству символов в условии while. Это символы, которые сигнализируют о выходе из текущего блока... символы «follow», на жаргоне разработчиков компиляторов.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l', 'u']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'r': DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Цикл FOR\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цикл FOR очень удобен, но он тяжел для трансляции. Не столько потому, что сама конструкция трудна... в конце концов это всего лишь цикл... но просто потому, что она трудна для реализации на ассемблере. Как только код придуман, трансляция достаточно проста.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фаны Си любят цикл FOR этого языка (фактически он проще для кодирования), но вместо него я выбрал синтаксис очень похожий на синтаксис из старого доброго Бейсика:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOR <ident> = <expr1> TO <expr2> <block> ENDFOR\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложность трансляции цикла «FOR» зависит от выбранного вами способа его реализации, от пути, которым вы решили определять правила обработки ограничений. Рассчитывается ли expr2 каждый раз при прохождении цикла, например, или оно обрабатывается как постоянное ограничение? Всегда ли вы проходите цикл хотя бы раз, как в Fortran, или нет. Все становится проще, если вы приверженец точки зрения что эта конструкция эквивалентна:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> = <expr1>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 TEMP = <expr2>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WHILE <ident> <= TEMP\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDWHILE \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что с этим определением цикла <block> не будет выполнен вообще если <expr1> изначально больше чем <expr2>.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код 68000, необходимый для этого, сложней чем все что мы делали до сих пор. Я сделал несколько попыток, помещая и счетчик и верхний предел в стек, в регистры и т.д. В конечном итоге я остановился на гибридном варианте размещения, при котором счетчик помещается в памяти (поэтому он может быть доступен внутри цикла) а верхний предел – в стеке. Оттранслированный код получился следующий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> ; получить имя счетчика цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expr1> ; получить начальное значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LEA <ident>(PC),A0 ; обратиться к счетчику цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SUBQ #1,D0 ; предварительно уменьшить его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,(A0) ; сохранить его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expr1> ; получить верхний предел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; сохранить его в стеке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1: LEA <ident>(PC),A0 ; обратиться к счетчику цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE (A0),D0 ; извлечь его в D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADDQ #1,D0 ; увеличить счетчик\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,(A0) ; сохранить новое значение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CMP (SP),D0 ; проверить диапазон\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BLE L2 ; пропустить если D0 > (SP)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BRA L1 ; цикл для следующего прохода\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2: ADDQ #2,SP ; очистить стек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ничего себе! Это же куча кода... строка, содержащая <block> кажется совсем потерявшейся. Но это лучшее из того, что я смог придумать. Я полагаю, чтобы вам помочь, вы должны иметь в виду что в действительности это всего лишь шестнадцать слов, в конце концов. Если кто-нибудь сможет оптимизировать это лучше, пожалуйста дайте мне знать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, подпрограмма анализа довольно проста теперь, когда у нас есть код:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a FOR Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoFor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('f');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (A0),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BGT ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как в этой версии синтаксического анализатора у нас нет выражений, я использовал тот же самый прием что и для Condition и написал подпрограмму:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ This version is a dummy \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('<expr>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте его. Снова, не забудьте добавить вызов в Block. Так как у нас нет возможности ввода для фиктивной версии Expression, типичная входная строка будет выглядеть так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 afi=bece\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, генерируется много кода, не так ли? Но, по крайней мере, это правильный код.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Оператор DO\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из-за всего этого мне захотелось иметь более простую версию цикла FOR. Причина появления всего этого кода выше состоит в необходимости иметь счетчик цикла, доступный как переменная внутри цикла. Если все, что нам нужно это считающий цикл, позволяющий нам выполнить что-то определенное число раз, но не нужен непосредственный доступ к счетчику, имеется более простое решение. Процессор 68000 имеет встроенную команду «уменьшить и переход если не ноль», которая является идеальной для подсчета. Для полноты давайте добавим и эту конструкцию. Это будет наш последний цикл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис и его перевод:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DO\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expr> \{ Emit(SUBQ #1,D0);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = NewLabel;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PostLabel(L);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Emit(MOVE D0,-(SP) \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ENDDO \{ Emit(MOVE (SP)+,D0;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Emit(DBRA D0,L) \} \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это гораздо проще! Цикл будет выполняться <expr> раз. Вот код:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a DO Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Dodo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('d');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DBRA D0,' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думаю вы согласитесь, что это гораздо проще, чем классический цикл FOR. Однако, каждая конструкция имеет свое назначение.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Оператор BREAK\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ранее я обещал вам оператор BREAK для сопровождения цикла LOOP. Им я в некотором роде горд. На первый взгляд BREAK кажется действительно сложным. Моим первым подходом было просто использовать его как дополнительный ограничитель в Block и разделить все циклы на две части точно также как я сделал это для ELSE оператора IF. Но, оказывается, это не работает, потому что оператор BREAK редко находится на том же самом уровне, что и сам цикл. Наиболее вероятное место для BREAK – сразу после IF, что приводило бы к выходу из конструкции IF, а не из окружающего цикла. Неправильно. BREAK должен выходить из внутреннего LOOP даже если он вложен в несколько уровней IF.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Моей следующей мыслью было просто сохранять в какой-то глобальной переменной, метку окончания самого вложенного цикла. Это также не работает, потому что может возникнуть прерывание из внутренного цикла с последующим прерыванием из внешнего. Сохранение метки для внутреннего цикла затерло бы метку для внешного. Так глобальная переменная превратилась в стек. Дело становилось грязным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда я решил последовать своему собственному совету. Помните последний урок, когда я показал вам как хорошо служит нам неявный стек синтаксического анализатора с рекурсивным спуском. Я сказал, что если вы начинаете видеть потребность во внешнем стеке, возможно вы делаете что-то неправильно. Действительно возможно заставить рекурсию, встроенную в наш синтаксический анализатор, позаботиться обо всем и это решение настолько простое, что кажется удивительным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Секрет состоит в том, чтобы заметить, что каждый оператор BREAK должен выполняться внутри блока... и ни в каком другом месте. Так что все, что мы должны сделать это передать в Block адрес выхода из самого внутреннего цикла. Затем он может передать этот адрес подпрограмме, транслирующей инструкцию Break. Так как оператор IF не изменяет уровень цикла, процедура DoIf не должна делать что-либо за исключением передачи метки в ее блок (оба из них). Так как циклы изменяют уровень, каждый цикл просто игнорирует любую метку выше его и передает свою собственную метку выхода дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это проще показать вам чем описывать. Я продемонстрирую это с самым простым циклом, циклом LOOP:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a LOOP Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что теперь DoLoop имеет две метки а не одну. Вторая дает команде BREAK адрес перехода Если в цикле нет BREAK, то мы зря потратили метку и немного загромоздили код, но не нанесли никакого вреда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте также, что процедура Block теперь имеет параметр, который для циклов всегда будет адресом выхода. Новая версия Block:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l', 'u']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'r': DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'f': DoFor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'd': DoDo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'b': DoBreak(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова заметьте, что все что Block делает с меткой это передает ее в DoIf и DoBreak. Циклы не нуждаются в ней, потому что они в любом случае передают свою собственную метку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Новая версия DoIf:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block(L: string); Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь единственное, что изменяется, это добавляется параметр у процедуры Block. Оператор IF не меняет уровень вложенности цикла, поэтому DoIf просто передает метку дальше. Независимо от того, сколько уровней вложенности IF мы имеем, будет использоваться та же самая метка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь не забудьте, что DoProgram также вызывает Block и теперь необходимо передавать ей метку. Попытка выхода из внешнего блока является ошибкой, поэтому DoProgram передает пустую метку, которая перехватывается DoBreak:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a BREAK \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBreak(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if L <> '' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('No loop to break from');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block('');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> 'e' then Expected('End');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот код позаботится почти обо всем. Испытайте его, посмотрите, сможете ли вы «сломать» («break») его (каламбур). Аккуратней однако. К настоящему времени мы использовали так много букв, что трудно придумать символ, который не представляет сейчас какое либо зарезервированное слово. Не забудьте, перед тем, как вы протестируете программу, вы должны будете исправить каждый случай появления Block в других циклах для включения нового параметра. Сделайте это точно так же, как я сделал это для LOOP.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я сказал выше «почти». Есть одна небольшая проблема: если вы внимательно посмотрите на код, генерируемый для DO, вы увидите, что если вы прервете этот цикл, то значение счетчика все еще остается в стеке. Мы должны исправить это! Позор... это была одна из самых маленьких наших подпрограмм, но это не помогло. Вот новая версия, которая не имеет этой проблемы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a DO Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Dodo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('d');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DBRA D0,' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Две дополнительные инструкции SUBQ и ADDQ заботятся о сохранении стека в правильной форме.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту мы создали ряд управляющих конструкций... в действительности более богатый набор чем предоставляет почти любой другой язык программирования. И, за исключением цикла FOR, это было довольно легко сделать. Но даже этот цикл был сложен только потому, что сложность заключалась в ассемблере.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я завершаю на этом урок. Чтобы можно было обернуть наш продукт красной ленточкой, в действительности мы должны иметь настоящие ключевые слова вместо этих игрушечных односимвольных. Вы уже видели, что расширить компилятор для поддержки многосимвольных слов не трудно, но в этом случае возникнут большие различия в представлении нашего входного кода. Я оставлю этот небольшой кусочек для следующей главы. В этой главе мы также рассмотрим логические выражения, так что мы сможем избавиться от фиктивной версии Condition, которую мы здесь использовали. Увидимся.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для справочных целей привожу полный текст синтаксического анализатора для этого урока:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Branch;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lcount: integer; \{ Label Counter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Condition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('<condition>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('<expr>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block(L: string); Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('w');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a LOOP Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a REPEAT Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('r');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('u');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a FOR Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoFor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('f');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (A0),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BGT ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a DO Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Dodo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('d');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DBRA D0,' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUBQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADDQ #2,SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a BREAK \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBreak(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an «Other» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l', 'u']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'r': DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'f': DoFor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'd': DoDo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'b': DoBreak(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block('');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> 'e' then Expected('End');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Булевы выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В пятой части этой серии мы рассмотрели управляющие конструкции и разработали подпрограммы синтаксического анализа для трансляции их в объектный код. Мы закончили с хорошим, относительно богатым набором конструкций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, когда мы оставили синтаксический анализатор, в наших возможностях существовал один большой пробел: мы не обращались к вопросу условия ветвления. Чтобы заполнить пустоту, я представил вам фиктивную подпрограмму анализа Сondition, которая служила только как заменитель настоящей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одним из дел, которыми мы займемся на этом уроке, будет заполнение этого пробела посредством расширения Condition до настоящего анализатора/транслятора.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 План\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы собираемся подойти к этой главе немного по-другому, чем к любой другой. В других главах мы начинали немедленно с экспериментов, используя компилятор Pascal, выстраивая синтаксические анализаторы от самых элементарных начал до их конечных форм, не тратя слишком много времени на предварительное планирование. Это называется кодированием без спецификации и обычно к нему относятся неодобрительно. Раньше мы могли избегать планирования, потому что правила арифметики довольно хорошо установлены... мы знаем, что означает знак "+" без необходимости подробно это обсуждать. То же самое относится к ветвлениям и циклам. Но способы, которыми языки программирования реализуют логику, немного отличаются от языка к языку. Поэтому прежде, чем мы начнем серьезное кодирование, лучше мы сперва примем решение что же мы хотим. И способ сделать это находится на уровне синтаксических правил БНФ (грамматики).\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Грамматика\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторое время назад мы реализовали синтаксические уравнения БНФ для арифметических выражений фактически даже не записав их все в одном месте. Пришло время сделать это. Вот они:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <unary op> <term> [<addop> <term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <factor> [<mulop> factor]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <integer> | <variable> | ( <expression> )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Запомните, преимущества этой грамматики в том, что она осуществляет такую иерархию приоритетов операторов, которую мы обычно ожидаем для алгебры.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На самом деле, пока мы говорим об этом, я хотел бы прямо сейчас немного исправить эту грамматику. Способ, которым мы обрабатываем унарный минус, немного неудобный. Я нашел, что лучше записать грамматику таким образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <term> [<addop> <term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <signed factor> [<mulop> factor]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <signed factor> ::= [<addop>] <factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <integer> | <variable> | (<expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это возлагает обработку унарного минуса на Factor, которому он в действительности и принадлежит.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это не означает, что вы должны возвратиться назад и переписать программы, которые вы уже написали, хотя вы свободны сделать так, если хотите. Но с этого момента я буду использовать новый синтаксис.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, возможно, для вас не будет ударом узнать, что мы можем определить аналогичную грамматику для булевой алгебры. Типичный набор правил такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-expression>::= <b-term> [<orop> <b-term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-term> ::= <not-factor> [AND <not-factor>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <not-factor> ::= [NOT] <b-factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-factor> ::= <b-literal> | <b-variable> | (<b-expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что в этой грамматике оператор AND аналогичен "*", а OR (и исключающее OR) – "+". Оператор NOT аналогичен унарному минусу. Эта иерархия не является абсолютным стандартом... некоторые языки, особенно Ada, обрабатывают все логические операторы как имеющие одинаковый уровень приоритета... но это кажется естественным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите также внимание на небольшое различие способов, которыми обрабатываются NOT и унарный минус. В алгебре унарный минус считается идущим со всем термом и поэтому никогда не появляется более одного раза в данном терме. Поэтому выражение вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a * -b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или еще хуже:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a – -b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не разрешены. В булевой алгебре наоборот, выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a AND NOT b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет точный смысл и показанный синтаксис учитывает это.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Операторы отношений\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, предполагая что вы захотите принять грамматику, которую я показал здесь, мы теперь имеем синтаксические правила и для арифметики и для булевой алгебры. Сложность возникает когда мы должны объединить их. Почему мы должны сделать это? Ну, эта тема возникла из-за необходимости обрабатывать «предикаты» (условия), связанные с управляющими операторами такими как IF. Предикат должен иметь логическое значение, то есть он должен быть оценен как TRUE или FALSE. Затем ветвление выполняется или не выполняется в зависимости от этого значения. Тогда то, что мы ожидаем увидеть происходящим в процедуре Condition, будет вычисление булевого выражения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но имеется кое-что еще. Настоящее булево выражение может действительно быть предикатом управляющего оператора... подобно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF a AND NOT b THEN ....\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но более часто мы видим, что булева алгебра появляется в таком виде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF (x >= 0) and (x <= 100) THEN...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь два условия в скобках являются булевыми выражениями, но индивидуальные сравниваемые термы: x, 0 и 100 являются числовыми по своей природе. Операторы отношений >= и <= являются катализаторами, с помощью которых булевские и арифметические компоненты объединяются вместе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, в примере выше сравниваемые термы являются просто термами. Однако, в общем случае, каждая сторона может быть математическим выражением. Поэтому мы можем определить отношение как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <relation> ::= <expression> <relop> <expression>,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где выражения, о которых мы говорим здесь – старого числового типа, а операторы отношений это любой из обычных символов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 =, <> (или !=), <, >, <= и >=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы подумаете об этом немного, то согласитесь, что так как этот вид предиката имеет логическое значение, TRUE или FALSE, это в действительности просто еще один вид показателя. Поэтому мы можем расширить определение булевого показателя следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-factor> ::= <b-literal>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 | <b-variable>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 | (<b-expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 | <relation>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот эта связь! Операторы отношений и отношения, которые они определяют, служат для объединения двух типов алгебры. Нужно заметить, что это подразумевает иерархию, в которой арифметическое выражение имеет более высокий приоритет, чем булевский показатель и, следовательно, чем все булевы операторы. Если вы выпишите уровни приоритета для всех операторов, вы прийдете к следующему списку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уровень Синтаксический элемент Оператор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 0 factor literal, variable\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1 signed factor unary minus\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2 term *, /\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3 expression +, -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 4 b-factor literal, variable, relop\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 5 not-factor NOT\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 6 b-term AND\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 7 b-expression OR, XOR\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы захотим принять столько уровней приоритета, эта грамматика кажется приемлемой. К несчастью, она не будет работать! Грамматика может быть великолепной в теории, но она может совсем не иметь смысла в практике нисходящего синтаксического анализатора. Чтобы увидеть проблему рассмотрите следующий фрагмент кода:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF ((((((A + B + C) < 0 ) AND....\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда синтаксический анализатор анализирует этот код он знает, что после того, как он рассмотрит токен IF следующим должно быть булево выражение. Поэтому он может приступить к началу вычисления такого выражения. Но первое выражение в примере является арифметическим выражением A + B + C. Хуже того, в точке, в которой анализатор прочитал значительную часть входной строки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF ((((((A ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 он все еще не имеет способа узнать с каким видом выражения он имеет дело. Так не пойдет, потому что мы должны иметь две различных программы распознавания для этих двух случаев. Ситуация может быть обработана без изменения наших определений но только если мы захотим принять произвольное количество возвратов (backtracking) чтобы избавить наш путь от неверных предположений. Ни один из создателей компиляторов в здравом уме не согласился бы на это.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Происходит то, что красота и элегантность грамматики БНФ столкнулась лицом к лицу с реальностью технологии компиляции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы работать с этой ситуацией создатели компиляторов должны идти на компромиссы, так чтобы один анализатор мог бы поддерживать грамматику без возвратов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Исправление грамматики\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема, с которой мы столкнулись, возникает потому, что наше определение и арифметических и булевых показателей позволяет использовать выражения в скобках. Так как определения рекурсивны, мы можем закончить с любым числом уровней скобок и синтаксический анализатор не может знать с каким видом выражения он имеет дело.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение просто, хотя и приводит к глубоким изменениям нашей грамматики. Мы можем разрешить круглые скобки только в одном виде показателей. Способ сделать это значительно изменяется от языка к языку. Это то место, где не существует соглашения или договора способного нам помочь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда Никлаус Вирт разработал Паскаль, его желанием было ограничить количество уровней приоритета (меньше подпрограмм синтаксического анализа, в конце концов). Так операторы OR и исключающее OR рассматриваются просто как Addop и обрабатываются на уровне математического выражения. Аналогично AND рассматривается подобно Mulop и обрабатывается с Term. Уровни приоритета:\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что имеется только один набор синтаксических правил, применимый к обоим видам операторов. Тогда согласно этой грамматике выражения типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x + (y AND NOT z) DIV 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 являются совершенно допустимыми. И, фактически, они таковыми являются... настолько, насколько синтаксический анализатор в этом заинтересован. Паскаль не позволяет смешивать арифметические и логические переменные, и подобные вещи скорее перехватываются на семантическом уровне, когда придет время генерировать для них код, чем на синтаксическом уровне.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Авторы C взяли диаметрально противоположный метод: они обрабатывают операторы как разные и C имеет что-то гораздо более похожее на наши семь уровней приоритета. Фактически, в C имеется не менее 17 уровней! Дело в том, что C имеет также операторы '=', '+=' и их родственников '<<', '>>', '++', '–' и т.д. Как ни странно, хотя в C арифметические и булевые операторы обрабатываются раздельно, то переменные нет... в C нет никаких булевых или логических переменных, так что логическая проверка может быть сделана на любом целочисленном значении.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы сделаем нечто среднее. Я склонен обычно придерживаться Паскалевского подхода, так как он кажется самым простым с точки зрения реализации, но это приводит к некоторым странностям, которые я никогда очень сильно не любил, как например в выражении:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF (c >= 'A') and (c <= 'Z') then ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 скобки обязательны. Я никогда не мог понять раньше почему, и ни мой компилятор, ни любой человек также не объясняли этого достаточно хорошо. Но сейчас мы все можем видеть, что оператор «and», имеющий приоритет как у оператора умножения, имеет более высокий приоритет, чем у операторов отношения, поэтому без скобок выражение эквивалентно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF c >= ('A' and c) <= 'Z' then\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что не имеет смысла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае, я решил разделить операторы на различные уровни, хотя и не столько много как в C.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-expression> ::= <b-term> [<orop> <b-term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-term> ::= <not-factor> [AND <not-factor>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <not-factor> ::= [NOT] <b-factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-factor> ::= <b-literal> | <b-variable> | <relation>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <relation> ::= | <expression> [<relop> <expression]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <term> [<addop> <term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <signed factor> [<mulop> factor]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <signed factor>::= [<addop>] <factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <integer> | <variable> | (<b-expression>)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта грамматика приводит к тому же самому набору семи уровней, которые я показал ранее. Действительно, это почти таже самая грамматика... я просто исключил заключенное в скобки b-выражение как возможный b-показатель и добавил отношение как допустимую форму b-показателя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть одно тонкое, но определяющее различие, которое заставляет все это работать. Обратите внимание на квадратные скобки в определении отношения. Это означает, что relop и второе выражение являются необязательными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Странным последствием этой грамматики (которое присутствует и в C) является то, что каждое выражения потенциально является булевым выражение. Синтаксический анализатор всегда будет искать булевское выражение, но «уладит» все до арифметического. Честно говоря, это будет замедлять синтаксический анализатор потому что он должен пройти через большее количество вызовов процедур. Это одна из причин, почему компиляторы Паскаля обычно быстрее выполяют компиляцию, чем компиляторы C. Если скорость для вас – больное место, придерживайтесь синтаксиса Паскаля.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Синтаксический анализатор\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы прошли через процесс принятия решений, мы можем поспешить с разработкой синтаксического анализатора. Вы делали это со мной несколько раз до этого, поэтому вы знаете последовательность: мы начнем с новой копии Cradle и будем добавлять процедуры одна за другой. Так что давайте сделаем это.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы начинаем, как и в случае с арифметикой, работая с булевыми литералами а не с переменными. Это дает нам новый вид входного токена, поэтому нам также нужна новая программа распознавания и новая процедура для чтения экземпляров этого типа токенов. Давайте начнем, определив эти две новые процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Literal \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsBoolean(c: char): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsBoolean := UpCase(c) in ['T', 'F'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Boolean Literal \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetBoolean: Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var c: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsBoolean(Look) then Expected('Boolean Literal');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetBoolean := UpCase(Look) = 'T';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Внесите эти подпрограммы в вашу программу. Вы можете протестировать их, добавив в основную программу оператор печати:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WriteLn(GetBoolean);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Откомпилируйте программу и протестируйте ее. Как обычно пока не очень впечатляет но скоро будет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы работали с числовыми данными, мы должны были организовать генерацию кода для загрузки значений в D0. Нам необходимо сделать то же самое и для булевых данных. Обычным способом кодирования булевых переменных является использование 0 для представления FALSE и какого-либо другого значения для TRUE. Многие языки, как например C, используют для его представления целое число 1. Но я предпочитаю FFFF (или -1) потому что побитовое NOT также возвратит логическое NOT. Итак, нам теперь нужно выдать правильный ассемблерный код для загрузки этих значений. Первая засечка на синтаксическом анализаторе булевых выражений (BoolExpression, конечно):\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsBoolean(Look) then Expected('Boolean Literal');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if GetBoolean then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #-1,D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавьте эту процедуру в ваш анализатор и вызовите ее из основной программы (заменив оператор печати, который вы только что там поместили). Как вы можете видеть, мы все еще не имеем значительной части синтаксического анализатора, но выходной код начинает выглядеть более реалистичным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, конечно, мы должны расширить определение булевого выражения. У нас уже есть правило в БНФ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <b-expression> ::= <b-term> [<orop> <b-term>]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я предпочитаю Паскалевскую версию «orop» – OR и XOR. Но так как мы сохраняем односимвольные токены, я буду кодировать их знаками '|' и '~'. Следующая версия BoolExpression – почти полная копия арифметической процедуры Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Boolean OR \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('|');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('OR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Exclusive Or \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('~');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOrOp(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Обратите внимание на новую процедуру IsOrOp, которая также является копией, на этот раз IsAddOp:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, переименуйте старую версию BoolExpression в BoolTerm, затем наберите код, представленный выше. Откомпилируйте и протестируйте эту версию. К этому моменту выходной код начинает выглядеть довольно хорошим. Конечно, нет большого смысла от булевой алгебры над постоянными значениями, но скоро мы расширим булевы типы, с которыми мы работаем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно вы уже предположили, какой будет следующий шаг: булевская версия Term.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переименуйте текущую процедуру BoolTerm в NotFactor, и введите следующую новую версию BoolTerm. Заметьте, что она намного более простая, чем числовая версия, так как здесь нет эквивалента деления.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = '&' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('&');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы почти дома. Мы транслируем сложные булевые выражения, хотя только и для постоянных значений. Следующий шаг – учесть NOT. Напишите следующую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Factor with NOT \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '!' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR #-1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И переименуйте предыдущую процедуру в BoolFactor. Теперь испытайте компилятор. К этому времени синтаксический анализатор должен обрабатывать любое булевое выражение, которое вы позаботитесь ему подкинуть. Работает? Отлавливает ли он неправильно сформированные выражения?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы следили за тем, что мы делали в синтаксическом анализаторе для математических выражений вы знаете что далее мы расширили определение показателя для включения переменных и круглых скобок. Мы не должны делать это для булевого показателя, потому что об этих маленьких вещах позаботится наш следующий шаг. Необходима только одна дополнительная строка в BoolFactor, чтобы позаботиться об отношениях:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsBoolean(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if GetBoolean then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #-1,D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы могли бы задаться вопросом, когда я собираюсь предоставить булевские переменные и булевские выражения в скобках. Отвечаю: никогда. Помните, ранее мы убрали их из грамматики. Прямо сейчас я собираюсь кодировать грамматику, которую мы уже согласовали. Сам компилятор не может видеть разницы между булевыми переменными или выражениями и арифметическими переменными или выражениями... все это будет обрабатываться в Relation в любом случае.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, понадобится некоторый код для Relation. Однако, я не чувствую себя комфортно, добавляя еще код, не проверив сперва тот, который мы уже имеем. Так что давайте сейчас просто напишем фиктивную версию Relation, которая ничего не делает за исключением того, что съедает текущий символ и выводит небольшое сообщение:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Relation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('<Relation>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, наберите этот код и испытайте его. Все старые дела все еще должны работать... у вас должна быть возможность генерировать код для AND, OR и NOT. Кроме того, если вы наберете любой алфавитный символ, вы должны получить небольшой заменитель <Relation>, где должен быть булев показатель. Вы получили это? Отлично, тогда давайте перейдем к полной версии Relation.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы получить ее, тем не менее, сначала мы должны положить небольшое основание. Вспомните, что отношение имеет форму:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <relation> ::= | <expression> [<relop> <expression]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как у нас появился новый вид операторов, нам также понадобится новая логическая функция для ее распознавания. Эта функция показана ниже. Из-за ограничения в один символ, я придерживаюсь четырех операторов, которые могут быть закодированы такими символами («не равно» закодировано как "#").\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вспомните, что мы используем нуль или -1 в регистре D0 для представления логического значения и также то, что операторы цикла ожидают, что будет установлен соответствующий флаг. При реализации всего этого для 68000 все становится немного сложным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как операторы цикла выполняются только по флажкам, было бы хорошо (а также довольно эффективно) просто установить эти флажки и совсем ничего не загружать в D0. Это было бы прекрасно для циклов и ветвлений, но запомните, что отношения могут быть использованы везде, где могут быть использованы булевы показатели. Мы можем сохранять его результат в булевой переменной. Так как мы не можем знаеть пока как будет использоваться результат, мы должны учесть оба случая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравнение числовых данных достаточно просто... 68000 имеет команду для этого... но она устанавливает флажки а не значение. Более того, всегда будут устанавливаться те же самые флажки (ноль если равно, и т.д.), в то время, как нам необходим по-разному установленный флажок нуля для каждого различного оператора отношения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение заключается в инструкции Scc процессора 68000, которая устанавливает значение байта в 0000 или FFFF (забавно как это работает!) в зависимости от результата определенного условия. Если мы сделаем байтом результата регистр D0, мы получим необходимое логическое значение.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К сожалению, имеется одно заключительное осложнение: в отличие от почти всех других команд в наборе 68000, Scc не сбрасывает флажки условий в соответствии с сохраняемыми данными. Поэтому мы должны сделать последний шаг, проверить D0 и установить соответствующим образом флажки. Это должно быть похоже на оборот вокруг луны для получения того, что мы хотим: мы сначала выполняем проверку, затем проверяем флажки, чтобы установить данные в D0, затем тестируем D0 чтобы установить флажки снова. Это окольный путь, но это самый простой способ получить правильные флажки и, в конце концов, это всего лишь пара инструкций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я мог бы упомянуть здесь, что эта область, по моему мнению, показывает самые большие различия между эффективностью вручную написанного на ассемблере и сгенерированного компилятором кода. Мы уже видели, что мы теряем эффективность при арифметических операциях, хотя позже я планирую показать вам как ее немного улучшить. Мы также видели, что управляющие конструкции сами по себе могут быть реализованы довольно эффективно... обычно очень сложно улучшить код, сгенерированный для IF или WHILE. Но практически каждый компилятор, который я когда-либо видел, генерирует ужасный код, по сравнению с ассемблером, для вычисления булевых функций и особенно отношений. Причина как раз в том, о чем я упомянул выше. Когда я пишу код на ассемблере, я двигаюсь вперед и выполняю проверку наиболее удобным для меня способом, и затем подготавливаю ветвление так чтобы переход был выполнен на нужную ветку. Фактически, я «подстраиваю» каждое ветвление под ситуацию. Компилятор не может сделать этого (практически) и он также не может знать, что нам не нужно сохранять результат проверки как булевскую переменную. Поэтому он должен генерировать код по очень строгим правилам и часто заканчивает сохранением результата как булевой переменной, которая никогда не будет использована для чего-либо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае мы теперь готовы рассмотреть код для Relation. Он показан ниже с сопровождающими процедурами:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Equals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SEQ D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Not Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotEquals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('#');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SNE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('<');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Greater Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Relation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsRelop(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': Equals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '#': NotEquals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '<': Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('TST D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь этот вызов Expression выглядит знакомым! Вот где редактор вашей системы оказывается полезным. Мы уже генерировали код для Expression и его близнецов на предыдущих уроках. Теперь вы можете скопировать их в ваш файл. Не забудьте использовать односимвольную версию. Просто чтобы быть уверенным, я продублировал арифметические процедуры ниже. Если вы наблюдательны, вы также увидите, что я их немного изменил чтобы привести в соответствие с последней версией синтаксиса. Эти изменения не являются необходимыми, так что вы можете предпочесть оставить все как есть до тех пор, пока не будете уверены, что все работает.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Ident;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name:= GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate the First Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '+' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '-' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #-' + GetNum + ',D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXS.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['*', '/'] do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вы получили что-то... синтаксический анализатор, который может обрабатывать и арифметику и булеву алгебру и их комбинации через использование операторов отношений. Я советую вам сохранить копию этого синтаксического анализатора в безопасном месте для будущих обращений, потому что на нашем следующем шаге мы собираемся разделить его.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объединение с управляющими конструкциями\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас давайте возвратимся назад к файлу который мы создали ранее и который выполняет синтаксический анализ управляющих конструкций. Помните небольшие фиктивные процедуры Condition и Expression? Теперь вы знаете, что в них должно находиться!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я предупреждаю вас, вы собираетесь сделать некоторые творческие изменения, поэтому потратьте ваше время и сделайте это правильно. Вы должны скопировать все процедуры из анализатора логики от Ident до BoolExpression в синтаксический анализатор управляющих конструкций. Вставьте их в текущей позиции Condition. Затем удалите эту процедуру, так же как и фиктивную Expression. Затем замените каждый вызов Condition на обращение к BoolExpression. Наконец скопируйте процедуры IsMulop, IsOrOp, IsRelop, IsBoolean, и GetBoolean на место. Этого достаточно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Откомпилируйте полученную программу и протестируйте ее. Так как мы не использовали эту программу некоторое время, не забудьте, что мы использовали односимвольные токены для IF, WHILE и т.д. Также не забудьте, что любая буква, не являющаяся ключевым словом, просто отображается на экране как блок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Попробуйте:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ia=bxlye\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что означает «IF a=b X ELSE Y ENDIF».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что вы думаете? Работает? Попробуйте что-нибудь еще.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Добавление присваиваний\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Раз у нас уже есть подпрограммы для выражений, мы могли бы также заменить «блоки» настоящими операциями присваивания. Мы уже делали это прежде, поэтому это не будет слишком трудно. Прежде, чем сделать этот шаг, однако, мы должны исправить кое-что еще.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скоро мы обнаружим, что наши однострочные «программы», которые мы здесь пишем, будут ограничивать наш стиль. В настоящее время у нас нет способа вылечить это, потому что наш компилятор не распознает символы конца строки, возврат каретки (CR) и перевод строки (LF). Поэтому перед продвижением дальше давайте заткнем эту дыру.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует пара способов для работы с CR/LF. Один (подход C/Unix) просто рассматривает их как дополнительные символы пробела и игнорирует их. Фактически это не такой плохой подход, но он приводит к странным результатам для нашего анализатора в его текущем состоянии. Если бы он считывал входной поток из исходного файла как любой уважающий себя настоящий компилятор, не было бы никаких проблем. Но мы считываем входной поток с клавиатуры и ожидаем, что должно что-то произойти, когда мы нажимаем клавишу Return. Этого не произойдет, если мы просто перескакиваем CR и LF (попробуйте это). Поэтому я собираюсь использовать здесь другой метод, который в конечном счете не обязательно является лучшим методом. Рассматривайте его как временную замену до тех пор, пока мы не двинемся дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вместо того, чтобы пропускать CR/LF, мы позволим синтаксическому анализатору двигаться вперед и отлавливать их, затем предоставлять их специальной процедуре, аналогичной SkipWhite, которая пропускает их только в определенных «допустимых» местах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот эта процедура:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip a CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь добавьте два вызова Fin в процедуру Block следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l', 'u']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoLoop;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'r': DoRepeat;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'f': DoFor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'd': DoDo;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'b': DoBreak(L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Other;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вы обнаружите, что можете использовать многострочные «программы». Единственное ограничение в том, что вы не можете отделять токены IF или WHILE от их предикатов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы готовы включить операторы присваивания. Просто замените вызов Other в процедуре Block на вызов Assignment и добавьте следующую процедуру, скопированную из одной нашей более ранней программы. Обратите внимание, что сейчас Assignment вызывает BoolExpression, поэтому мы можем присваивать логические переменные.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С этими изменениями у вас теперь должна быть возможность писать сносные, реалистично выглядящие программы, подчиненные только нашему ограничению односимвольными токенами. Первоначально я также намеревался избавить вас и от этого ограничения. Однако, это потребует довольно больших изменений того, что мы сделали к этому моменту. Нам нужен настоящий лексический анализатор и это требует некоторых структурных изменений. Это небольшие изменения, которые потребуют чтобы мы выбросили все, что мы сделали к этому времени... при желании это может быть сделано в действительности с минимальными изменениями. Но необходимо такое желание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта глава и так получилась довольно длинной и она содержит довольно тяжелый материал, поэтому я решил оставить этот шаг до следующего раза, чтобы у вас было немного времени усвоить то, что мы сделали и вы были готовы начать на свежую голову.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующей главе, мы построим лексический анализатор и устраним односимвольный барьер раз и навсегда. Мы также напишем наш первый законченный компилятор, основанный на том, что мы сделали на этом уроке. Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Лексический анализ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последней главе я оставил вас с компилятором который должен почти работать, за исключением того, что мы все еще ограничены односимвольными токенами. Цель этого урока состоит в том, чтобы избавиться от этого ограничения раз и навсегда. Это означает, что мы должны иметь дело с концепцией лексического анализатора (сканера).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно я должен упомянуть, почему нам вообще нужен лексический анализатор... в конце концов до настоящего времени мы были способны хорошо справляться и без него даже когда мы предусмотрели многосимвольные токены.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Единственная причина, на самом деле, имеет отношение к ключевым словам. Это факт компьютерной жизни, что синтаксис ключевого слова имеет ту же самую форму, что и синтаксис любого другого идентификатора. Мы не можем сказать пока не получим полное слово действительно ли это ключевое слово. К примеру переменная IFILE и ключевое слово IF выглядят просто одинаковыми до тех пор, пока вы не получите третий символ. В примерах до настоящего времени мы были всегда способны принять решение, основанное на первом символе токена, но это больше невозможно когда присутствуют ключевые слова. Нам необходимо знать, что данная строка является ключевым словом до того, как мы начнем ее обрабатывать. И именно поэтому нам нужен сканер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На последнем уроке я также пообещал, что мы могли бы предусмотреть нормальные токены без глобальных изменений того, что мы уже сделали. Я не солгал... мы можем, как вы увидите позднее. Но каждый раз, когда я намеревался встроить эти элементы в синтаксический анализатор, который мы уже построили, у меня возникали плохие чувства в отношении их. Все это слишком походило на временную меру. В конце концов я выяснил причину проблемы: я установил программу лексического анализа не объяснив вам вначале все о лексическом анализе, и какие есть альтернативы. До настоящего времени я старательно избегал давать вам много теории и, конечно, альтернативные варианты. Я обычно не воспринимаю хорошо учебники которые дают двадцать пять различных способов сделать что-то, но никаких сведений о том, какой способ лучше всего вам подходит. Я попытался избежать этой ловушки, просто показав вам один способ, который работает.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это важная область. Хотя лексический анализатор едва ли является наиболее захватывающей частью компилятора он часто имеет наиболее глубокое влияние на общее восприятие языка так как эта часть наиболее близка пользователю. Я придумал специфическую структуру сканера, который будет использоваться с KISS. Она соответствует восприятию, которое я хочу от этого языка. Но она может совсем не работать для языка, который придумаете вы, поэтому в этом единственном случае я чувствую, что вам важно знать ваши возможности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому я собираюсь снова отклониться от своего обычного распорядка. На этом уроке мы заберемся гораздо глубже, чем обычно, в базовую теорию языков и грамматик. Я также буду говорить о других областях кроме компиляторов в которых лексических анализ играет важную роль. В заключение я покажу вам некоторые альтернативы для структуры лексического анализатора. Тогда и только тогда мы возвратимся к нашему синтаксическому анализатору из последней главы. Потерпите... я думаю вы найдете, что это стоит ожидания. Фактически, так как сканеры имеют множество применений вне компиляторов, вы сможете легко убедиться, что это будет наиболее полезный для вас урок.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Лексический анализ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лексический анализ – это процесс сканирования потока входных символов и разделения его на строки, называемые лексемами. Большинство книг по компиляторам начинаются с этого и посвящают несколько глав обсуждению различных методов построения сканеров. Такой подход имеет свое место, но, как вы уже видели, существуют множество вещей, которые вы можете сделать даже никогда не обращавшись к этому вопросу, и, фактически, сканер, который мы здесь закончим, не очень будет напоминать то, что эти тексты описывают. Причина? Теория компиляторов и, следовательно, программы следующие из нее, должны работать с большинством общих правил синтаксического анализа. Мы же не делаем этого. В реальном мире возможно определить синтаксис языка таким образом, что будет достаточно довольно простого сканера. И как всегда KISS – наш девиз.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как правило, лексический анализатор создается как отдельная часть компилятора, так что синтаксический анализатор по существу видит только поток входных лексем. Теоретически нет необходимости отделять эту функцию от остальной части синтаксического анализатора. Имеется только один набор синтаксических уравнений, который определяет весь язык, поэтому теоретически мы могли бы написать весь анализатор в одном модуле.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зачем необходимо разделение? Ответ имеет и теоретическую и практическую основы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В 1956 Ноам Хомский определил «Иерархию Хомского» для грамматик. Вот они:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип 0. Неограниченные (например Английский язык)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип 1. Контекстно-зависимые\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип 2. Контекстно-свободные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип 3. Регулярные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые характеристики типичных языков программирования (особенно старых, таких как Фортран) относят их к Типу 1, но большая часть всех современных языков программирования может быть описана с использованием только двух последних типов и с ними мы и будем здесь работать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошая сторона этих двух типов в том, что существуют очень специфические пути для их анализа. Было показано, что любая регулярная грамматика может быть анализирована с использованием частной формы абстрактной машины, называемой конечным автоматом. Мы уже реализовывали конечные автоматы в некоторых их наших распознающих программ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично грамматики Типа 2 (контекстно-свободные) всегда могут быть анализированы с использованием магазинного автомата (конечный автомат, дополненный стеком). Мы также реализовывали эти машины. Вместо реализации явного стека для выполнения работы мы положились на встроенный стек связанный с рекурсивным кодированием и это фактически является предочтительным способом для нисходящего синтаксического анализа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Случается что в реальных, практических грамматиках части, которые квалифицируются как регулярные выражения, имеют склонность быть низкоуровневыми частями, как определение идентификатора:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> ::= <letter> [ <letter> | <digit> ]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как требуется различные виды абстрактных машин для анализа этих двух типов грамматик, есть смысл отделить эти низкоуровневые функции в отдельный модуль, лексический анализатор, который строится на идее конечного автомата. Идея состоит в том, чтобы использовать самый простой метод синтаксического анализа, необходимый для работы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется другая, более практическая причина для отделения сканера от синтаксического анализатора. Мы хотим думать о входном исходном файле как потоке символов, которые мы обрабатываем справа налево без возвратов. На практике это невозможно. Почти каждый язык имеет некоторые ключевые слова типа IF, WHILE и END. Как я упомянул ранее, в действительности мы не можем знать является ли данная строка ключевым словом до тех пор пока мы не достигнем ее конца, что определено пробелом или другим разделителем. Так что мы должны хранить строку достаточно долго для того, чтобы выяснить имеем мы ключевое слово или нет. Это ограниченная форма перебора с возвратом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому структура стандартного компилятора включает разбиение функций низкоуровневого и высокоуровневого синтаксического анализа. Лексический анализатор работает на символьном уровне собирая символы в строки и т.п., и передавая их синтаксическому анализатору как неделимые лексемы. Также считается нормальным позволить сканеру выполнять работу по идентификации ключевых слов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Конечные автоматы и альтернативы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я упомянул, что регулярные выражения могут анализироваться с использованием конечного автомата. В большинстве книг по компиляторам а также в большинстве компиляторов, вы обнаружите, что это применяется буквально. Обычно они имеют настоящую реализацию конечного автомата с целыми числами, используемыми для определения текущего состояния и таблицей действий, выполняемых для каждой комбинации текущего состояния и входного символа. Если вы пишите «front end» для компилятора, используя популярные Unix инструменты LEX и YACC, это то, что вы получите. Выход LEX – конечый автомат, реализованный на C плюс таблица действий, соответствующая входной грамматике данной LEX. Вывод YACC аналогичен... исскуственный таблично-управляемый синтаксический анализатор плюс таблица, соответствующая синтаксису языка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако это не единственный вариант. В наших предыдущих главах вы много раз видели, что возможно реализовать синтаксические анализаторы специально не имея дела с таблицами, стеками и переменными состояния. Фактически в пятой главе я предупредил вас, что если вы считает себя нуждающимся в этих вещах, возможно вы делаете что-то неправильно и не используете возможности Паскаля. Существует в основном два способа определить состояние конечного автомата: явно, с номером или кодом состояния и неявно, просто на основании того факта, что я нахожусь в каком-то определенном месте кода (если сегодня вторник, то это должно быть Бельгия). Ранее мы полагались в основном на неявные методы, и я думаю вы согласитесь, что они работают здесь хорошо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На практике может быть даже не обязательно иметь четко определенный лексический анализатор. Это не первый наш опыт работы с многосимвольными токенами. В третьей главе мы расширили наш синтаксический анализатор для их поддержки и нам даже не был нужен лексический анализатор. Причиной было то, что в узком контексте мы всегда могли сказать просто рассматривая единственный предсказывающий символ, имеем ли мы дело с цифрой, переменной или оператором. В действительности мы построили распределенный лексический анализатор, используя процедуры GetName и GetNum.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имея ключевые слов мы не можем больше знать с чем мы имеем дело до тех пор, пока весь токен не будет прочитан. Это ведет нас к более локализованному сканеру, хотя, как вы увидите, идея распределенного сканера все же имеет свои достоинства.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Эксперименты по сканированию\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем возвратиться к нашему компилятору, было бы полезно немного поэкспериментировать с общими понятиями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с двух определений, наиболее часто встречающихся в настоящих языках программирования:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> ::= <letter> [ <letter> | <digit> ]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <number ::= [<digit>]+\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Не забудьте, что "*" указывает на ноль или более повторений условия в квадратных скобках, а "+" на одно и более.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже работали с подобными элементами в третьей главе. Давайте начнем (как обычно) с пустого Cradle. Не удивительно, что нам понадобится новая процедура распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alphanumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя ее, давайте напишем следующие две подпрограммы, которые очень похожи на те, которые мы использовали раньше:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var x: string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 x := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 x := x + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := x;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var x: string[16];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 x := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 x := x + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := x;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что эта версия GetNum возвращает строку, а не целое число, как прежде).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы можете легко проверить что эти подпрограммы работают, вызвав их из основной программы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WriteLn(GetName);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа выведет любое допустимое набранное имя (максимум восемь знаков, потому что мы так сказали GetName). Она отвергнет что-либо другое.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично проверьте другую подпрограмму.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Пробел\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Раньше мы также работали с вложенными пробелами, используя две подпрограммы IsWhite и SkipWhite. Удостоверьтесь, что эти подпрограммы есть в вашей текущей версии Cradle и добавьте строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SkipWhite;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в конец GetName и GetNum.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте определим новую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Lexical Scanner \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Function Scan: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем вызвать ее из новой основной программы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 writeln(Token);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Token = CR;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Вы должны добавить описание строки Token в начало программы. Сделайте ее любой удобной длины, скажем 16 символов).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь запустите программу. Заметьте, что входная строка действительно разделяется на отдельные токены.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Конечные автоматы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подпрограмма анализа типа GetName действительно реализует конечный автомат. Состояние неявно в текущей позиции в коде. Очень полезным приемом для визуализации того, что происходит, является синтаксическая диаграмма или «railroad-track» диаграмма. Немного трудно нарисовать их в этой среде, поэтому я буду использовать их очень экономно, но фигура ниже должна дать вам идею: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, эта диаграмма показывает логические потоки по мере чтения символов. Начинается все, конечно, с состояния «start» и заканчивается когда найден символ, отличный от алфавитно-цифрового. Если первый символ не буква, происходит ошибка. Иначе автомат продолжит выполнение цикла до тех пор, пока не будет найден конечный разделитель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что в любой точке потока наша позиция полностью зависит от предыдущей истории входных символов. В этой точке предпринимаемые действия зависят только от текущего состояния плюс текущий входной символ. Это и есть то, что образует конечный автомат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из-за сложностей представления «railroad-track» диаграмм в этой среде я буду продолжать придерживаться с этого времени синтаксических уравнений. Но я настоятельно рекомендую вам диаграммы для всего, что включает синтаксический анализ. После небольшой практики вы можете начать видеть, как написать синтаксический анализатор непосредственно из диаграммы. Параллельные пути кодируются в контролирующие действия (с помощью операторов IF или CASE), последовательные пути – в последовательные вызовы. Это почти как работа по схеме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы даже не обсудили SkipWhite, которая была представлена раньше, но это также простой конечный автомат, как и GetNum. Так же как и их родительская процедура Scan. Маленькие автоматы образуют большие автоматы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересная вещь, на которую я хотел бы чтобы вы обратили внимание это то, как безболезненно такой неявный подход создает эти конечные автоматы. Я лично предпочитаю его таблично-управляемому методу. Он также получает маленькие, компактные и быстрые сканеры.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Новые строки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Продвигаясь прямо вперед, давайте модифицируем наш сканер для поддержки более чем одной строки. Как я упомянул последний раз, наиболее простой способ сделать это – просто обработать символы новой строки, возврат каретки и перевод строки, как незаполненное пространство. Фактически это способ, используемый подпрограммой iswhite из стандартной библиотеки C. Прежде мы не этого делали. Я хотел бы сделать это теперь, чтобы вы могли почувствовать результат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы сделать это просто измените единственную выполнимую строку в IsWhite:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IsWhite := c in [' ', TAB, CR, LF];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы должны дать основной программы новое условие останова, так как она никогда не увидит CR. Давайте просто используем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 until Token = '.';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, откомпилируйте эту программу и запустите ее. Попробуйте пару строк, завершаемых точкой. Я использовал:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 now is the time\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for all good men.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эй, что случилось? Когда я набрал это, я не получил последний токен, точку. Программа не остановилась. Более того, когда я нажал клавишу 'enter' несколько раз, я все равно не получил точку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы все еще не можете выбраться из вашей программы, вы обнаружите, что набор точки в новой строке прервет ее.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что здесь происходит? Ответ в том, что мы зависаем в SkipWhite. Короткий осмотр этой подпрограммы покажет, что пока мы печатаем пустые строки, мы просто продолжаем выполнение цикла. После того, как SkipWhite встречает LF, он пытается выполнить GetChar. Но так как входной буфер теперь пуст, оператор чтения в GetChar настаивает на наличии другой строки. Процедура Scan получает завершающую точку, все правильно, но она вызывает SkipWhite и SkipWhite не возвращается до тех пор, пока не получит непустую строку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такое поведение не настолько плохое, как кажется. В настоящем компиляторе мы читали бы символы из входного файла вместо консоли и пока мы имеем какую-то процедуру для работы с концом файла, все получится ОК. Но для чтения данных с консоли такое поведение слишком причудливое. Суть в том, что соглашение C/Unix просто не совместимо со структурой нашего анализатора, который запрашивает предсказывающий символ. Код, который мастера из Bell реализовали, не использует это соглашение, поэтому они нуждаются в 'ungetc'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, давайте исправим проблему. Чтобы сделать это, мы должны возвратиться к старому определению IsWhite (удалите символы CR и LF) и используйте процедуру Fin, которую я представил в последний раз. Если ее нет в вашей текущей версии Cradle, поместите ее там.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Также измените основную программу следующим обраазом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 writeln(Token);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = CR then Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Token = '.';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на «охраняющую» проверку, предшествующую вызову Fin. Это то, что заставляет все это работать, и проверяет, то мы не пытаемся прочитать строку дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас испытайте этот код. Я думаю он понравится вам больше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы обратитесь к коду, который мы написали в последней главе, вы обнаружите, что я расставил вызовы Fin по всему коду, где прерывание строки было бы уместным. Это одна из тех областей, которые действительно влияют на восприятие, о котором я упомянул. В этой точке я должен убедить вас поэкспериментировать с различными способами организациями и посмотреть, как вам это понравится. Если вы хотите, чтобы ваш язык был по настоящему свободного стиля, тогда новые строки должны быть прозрачны. В этом случае наилучшим подходом было бы поместить следующие строки в начале Scan:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while Look = CR do\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Fin;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если, с другой стороны, вам нужен строчно-ориентированный язык подобный Ассемблеру, BASIC или FORTRAN (или даже Ada... заметьте, что он имеет комментарии, завершаемые новой строкой), тогда вам необходимо, чтобы Scan возвращал CR как токены. Он также должен съедать завершающие LF. Лучший способ сделать – использовать эту строку в самом начале Scan:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if Look = LF then Fin;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для других соглашений вы будете должны использовать другие способы организации. В моем примере на последнем уроке я разрешил новые строки только в определенных местах, поэтому я занял какое-то промежуточное положение. В остальных частях этих занятий я буду выбирать такие способы обработки новых строк какие мне понравятся, но я хочу, чтобы вы знали, как выбрать для себя другой путь.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Операторы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы могли бы сейчас остановиться и иметь в своем распоряжении довольно полезный сканер. В тех фрагментах KISS, которые мы построили, единственными токенами, состоящими из нескольких символов, являются идентификаторы и числа. Все операторы были односимвольными. Единственное исключение, которое я могу придумать – это операторы отношений «<=», «>=» и «<>», но они могут быть обработаны как особые случаи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако другие языки имеют многосимвольные операторы такие как «:=» в Паскале или «++» и «>>» в C. Хотя пока нам и не нужны многосимвольные операторы, было бы хорошо знать как получить их в случае необходимости.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Само собой разумеется, что мы можем обрабатывать операторы точно таким же способом, что и другие токены. Давайте начнем с подпрограммы распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize Any Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOp(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOp := c in ['+', '-', '*', '/', '<', '>', ':', '='];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важно заметить, что мы не должны включать в этот список каждый возможный оператор. К примеру круглые скобки не включены, так же как и завершающая точка. Текущая версия Scan и так хорошо поддерживает односимвольные операторы. Список выше включает только те символы, которые могут появиться в многосимвольных операторах. (Для конкретных языков список конечно всегда может быть отредактирован).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте изменим Scan следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Lexical Scanner \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Function Scan: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsOp(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := GetOp\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь испытайте программу. Вы убедитесь, что любые фрагменты кода, которые вы захотите бросить в нее будут аккуратно разложены на индивидуальные токены.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Списки, запятые и командные строки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем возвратиться к основной цели нашего обучения, я хотел бы немного выступить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сколько раз вы работали с программой или операционной системой, которая имела жесткие правила того, как вы должны разделять элементы в списке? (Попробую, последний раз вы использовали MS DOS!). Некоторые программы требуют пробелов как разделителей, некоторые требуют запятые. Хуже всего, что некоторые требуют и того и другого в разных местах. Большинство довольно неумолимы к нарушениям их правил.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думаю, это непростительно. Слишком просто написать синтаксически анализатор, который поддерживает и пробелы и запятые гибким способом. Рассмотрите следующую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over a Comma \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipComma;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = ',' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура из восьми строк пропустит разделитель, состоящий из любого числа (включая ноль) пробелов, с нулем или одной запятой, вложенной в строку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Временно измените вызов SkipWhite в Scan на вызов SkipComma и попробуйте ввести какие-нибудь списки. Хорошо работает, да? Разве вы не хотите, чтобы больше создателей программ знало о SkipComma?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К слову сказать, я обнаружил, что добавление эквивалента SkipComma в мою программу на ассемблере для Z80 заняло всего шесть дополнительных байт кода. Даже на 64K машинах это не слишком большая цена за дружелюбие к пользователю.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думаю вы можете видеть к чему я клоню. Даже если вы в своей жизни не написали ни одной строчки кода для компилятора, в каждой программе существуют места, где вы можете использовать понятие синтаксического анализа. Любая программа, которая обрабатывает командные строки, нуждается в нем. Фактически, если вы подумаете немного об этом, вы придете к заключению, что всякий раз, когда вы пишете программу, обрабатывающую ввод пользователя, вы определяете язык. Люди общаются с помощью языков и неявный синтаксис в вашей программе определяет этот язык. Настоящий вопрос: вы собираетесь определять его преднамеренно и явно, или просто позволите существовать независимо от того, как программа завершает синтаксический анализ?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я утверждаю, что у вас будет лучший, более дружественный интерфейс если вы потратите время на то, чтобы определить синтаксис явно. Запишите синтаксические уравнения или нарисуйте «railroad-track» диаграммы и закодируйте синтаксический анализатор используя методы, которые я показал вам здесь. Вы получите более хорошую программу и ее будет проще писать, в придачу.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Становится интересней\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, сейчас мы имеем довольно хороший лексический анализатор, который разбивает входной поток на лексемы. Мы могли бы использовать его как есть и иметь полезный компилятор. Но есть некоторые другие аспекты лексического анализа, которые мы должны охватить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Особенно следует рассмотреть (вздрогните) эффективность. Помните, когда мы работали с односимвольными токенами, каждой проверкой было сравнение одного символа Look с байтовой константой. Мы также использовали в основном оператор Case.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С многосимвольными лексемами, возвращаемыми Scan, все эти проверки становятся сравнением строк. Гораздо медленнее. И не только медленнее но и неудобней, так как в Паскале не существут строкового эквивалента оператора Case. Особенно расточительным кажется проверять то что состоит из одного символа... "=", "+" и другие операторы... используя сравнение строк.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравнение строк не является невозможным. Рон Кейн использовал этот подход при написании Small C. Так как мы придерживаемся принципа KISS мы были бы оправданы согласившись с этим подходом. Но тогда я не смог бы рассказать вам об одном из ключевых методов, используемых в «настоящих» компиляторах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы должны запомнить: лексический анализатор будет вызываться часто! Фактически один раз для каждой лексемы во всей исходной программе. Эксперименты показали, что средний компилятор тратит где-то от 20 до 40 процентов своего времени на подпрограммах лексического анализа. Если существовало когда-либо место, где эффективность заслуживает пристального рассмотрения, то это оно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По этой причине большинство создателей компиляторов заставляют лексический анализатор выполнять немного больше работы, «токенизируя» входной поток. Идея состоит в том, чтобы сравнивать каждую лексему со списком допустимых ключевых слов и операторов и возвращать уникальный код для каждой распознанной. В случае обычного имени переменной или числа мы просто возвращаем код, который говорит, к какому типу лексем они относятся и сохраняем где-нибудь текущую строку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое, что нам нужно – это способ идентификации ключевых слов. Мы всегда можем сделать это с помощью последовательных проверок IF, но несомненно было бы хорошо, если бы мы имели универсальную подпрограмму, которая могла бы сравнивать данную строку с таблицей ключевых слов. (Между прочим, позднее нам понадобится такая же подпрограмма для работы с таблицей идентификаторов). Это обычно выявляет проблему Паскаля, потому что стандартный Паскаль не имеет массивов переменной длины. Это настоящая головная боль – обьявлять различные подпрограммы поиска для каждой таблицы. Стандартный Паскаль также не позволяет инициализировать массивы, поэтому вам придется видеть код типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Table[1] := 'IF';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Table[2] := 'ELSE';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Table[n] := 'END';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что может получиться довольно длинным если есть много ключевых слов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью Turbo Pascal 4.0 имеет расширения, которые устраняют обе эти проблемы. Массивы-константы могут быть обьявлены с использованием средства TP «типизированные константы» а переменные размерности могут быть поддержаны с помощью Си-подобных расширений для указателей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала, измените ваши объявления подобным образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Размерность, использованная в SymTab не настоящая... память не распределяется непосредственно этим объявлением, а размерность должна быть только «достаточно большой»)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, сразу после этих объявлений, добавьте следующее:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array [1..4] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, вставьте следующую новую функцию:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Table Lookup \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ If the input string matches a table entry, return the entry\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 index. If not, return a zero. \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Lookup(T: TabPtr; s: string; n: integer): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found: boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := false;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 i := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while (i > 0) and not found do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s = T^[i] then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := true\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 dec(i);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lookup := i;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы проверить ее вы можете временно изменить основную программу следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadLn(Token);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Lookup(Addr(KWList), Token, 4));\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание как вызывается Lookup: функция Addr устанавливает указатель на KWList, который передается в Lookup.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, испытайте ее. Так как здесь мы пропускаем Scan, для получения соответствия вы должны набирать ключевые слова в верхнем регистре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы можем распознавать ключевые слова, далее необходимо договориться о возвращаемых для них кодах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, какие кода мы должны возвращать? В действительности есть только два приемлемых варианта. Это похоже на идеальное применения перечислимого типа Паскаля. К примеру, вы можете определить что-то типа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SymType = (IfSym, ElseSym, EndifSym, EndSym, Ident, Number, Operator);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и договориться возвращать переменную этого типа. Давайте попробуем это. Вставьте строку выше в описание типов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь добавьте два описания переменных:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Token: Symtype; \{ Current Token \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Value: String[16]; \{ String Token of Look \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Измените сканер так:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Lexical Scanner \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var k: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 k := Lookup(Addr(KWlist), Value, 4);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if k = 0 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := SymType(k – 1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Number;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsOp(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Operator;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Operator;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что Scan сейчас стала процедурой а не функцией).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, измените основную программу:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident: write('Ident ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Number: Write('Number ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Operator: Write('Operator ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IfSym, ElseSym, EndifSym, EndSym: Write('Keyword ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Writeln(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Token = EndSym;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы заменили строку Token, используемую раньше, на перечислимый тип. Scan возвращает тип в переменной Token и возвращает саму строку в новой переменной Value.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, откомпилируйте программу и погоняйте ее. Если все работает, вы должны увидеть, что теперь мы распознаем ключевые слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь у нас все работает правильно, и было легко сгенерировать это из того, что мы имели раньше. Однако, она все равно кажется мне немного «перегруженной». Мы можем ее немного упростить, позволив GetName, GetNum, GetOp и Scan работать с глобальными переменными Token и Value, вследствие этого удаляя их локальные копии. Кажется немного умней было бы переместить просмотр таблицы в GetName. Тогда новая форма для этих четырех процедур будет такой:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var k: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 k := Lookup(Addr(KWlist), Value, 4);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if k = 0 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := SymType(k-1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Number;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsOp(Look) then Expected('Operator');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOp(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Operator;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Lexical Scanner \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var k: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsOp(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetOp\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Operator;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Возвращение символа\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По существу, все сканеры, которые я когда-либо видел и которые написаны на Паскале, использовали механизм перечислимых типов, который я только что описал. Это конечно работающий механизм, но он не кажется мне самым простым подходом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде всего, список возможных типов символов может получиться довольно длинным. Здесь я использовал только один символ «Operator» для обозначения всех операторов, но я видел другие проекты, в которых фактически возвращаются различные кода для каждого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует, конечно, другой простой тип, который может быть возвращен как код: символ. Вместо возвращения значения «Operator» для знака "+", что неправильного в том, чтобы просто возвращать сам символ? Символ – такая же хорошая переменная для кодирования различных типов лексем, она легко может быть использована в операторах Case, и это гораздо проще набрать. Что может быть проще?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, мы уже имели опыт с идеей кодировать ключевые слова как одиночные символы. Наши предыдущие программы уже написаны таким способом, так что использование этого метода минимизирует изменения того, что мы уже сделали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые из вас могут почувствовать, что идея с возвращение символьных кодов слишком детская. Я должен допустить, что она становится немного неуклюжей для операторов типа «<=». Если вы хотите остаться с перечислимыми типами, хорошо. Для остальных я хотел бы показать как изменить то, что мы сделали выше, для поддержки такого подхода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-первых, сейчас вы можете удалить объявление типа SymType... он нам больше не понадобится. И вы можете изменить тип Token в char.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, чтобы заменить SymType, добавьте следующую константу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 const KWcode: string[5] = 'xilee';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Я буду кодировать все идентификаторы одиночным символом 'x').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец измените Scan и его родственников следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, 4) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '#';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsOp(Look) then Expected('Operator');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOp(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Length(Value) = 1 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Value[1]\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '?';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Lexical Scanner \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var k: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsOp(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetOp\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '?';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'x': write('Ident ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '#': Write('Number ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i', 'l', 'e': Write('Keyword ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Write('Operator ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Writeln(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Value = 'END';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа должна работать также как и предыдущая версия. Небольшое различие в структуре, может быть, но она кажется мне более простой.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Распределенные сканеры против централизованных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура лексического анализатора, которую я только что вам показал, весьма стандартна и примерно 99% всех компиляторов используют что-то очень близкое к ней. Это, однако, не единственно возможная структура, или даже не всегда самая лучшая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема со стандартным подходом состоит в том, что сканер не имеет никаких сведений о контексте. Например, он не может различить оператор присваивания "=" и оператор отношения "=" (возможно именно поэтому и C и Паскаль используют для них различные строки). Все, что сканер может сделать, это передать оператор синтаксическому анализатору, который может точно сказать исходя из контекста, какой это оператор. Точно так же, ключевое слово «IF» не может быть посредине арифметического выражения, но если ему случится оказаться там, сканер не увидит в этом никакой проблемы и возвратит его синтаксическому анализатору, правильно закодировав как «IF».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С таким подходом, мы в действительности не используем всю информацию, имеющуюся в нашем распоряжении. В середине выражения, например, синтаксический анализатор «знает», что нет нужды искать ключевое слово, но он не имеет никакой возможности сказать это сканеру. Так что сканер продолжает делать это. Это, конечно, замедляет компиляцию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В настоящих компиляторах проектировщики часто принимают меры для передачи подробной информации между сканером и парсером, только чтобы избежать такого рода проблем. Но это может быть неуклюже и, конечно, уничтожит часть модульности в структуре компилятора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Альтернативой является поиск какого-то способа для использования контекстной информации, которая исходит из знания того, где мы находимся в синтаксическом анализаторе. Это возвращает нас обратно к понятию распределенного сканера, в котором различные части сканера вызываются в зависимости от контекста.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В языке KISS, как и большинстве языков, ключевые слова появляются только в начале утверждения. В таких местах, как выражения они запрещены. Также, с одним небольшим исключением (многосимвольные операторы отношений), которое легко обрабатывается, все операторы односимвольны, что означает, что нам совсем не нужен GetOp.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что, оказывается, даже с многосимвольными токенами мы все еще можем всегда точно определить вид лексемы исходя из текущего предсказывающего символа, исключая самое начало утверждения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Даже в этой точке, единственным видом лексемы, который мы можем принять, является идентификатор. Нам необходимо только определить, является ли этот идентификатор ключевым словом или левой частью оператора присваивания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда мы заканчиваем все еще нуждаясь только в GetName и GetNum, которые используются так же, как мы использовали их в ранних главах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала вам может показаться, что это шаг назад и довольно примитивный способ. Фактически же, это усовершенствование классического сканера, так как мы используем подпрограммы сканирования только там, где они действительно нужны. В тех местах, где ключевые слова не разрешены, мы не замедляем компиляцию, ища их.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объединение сканера и парсера\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы охватили всю теорию и общие аспекты лексического анализа, я наконец готов подкрепит свое заявление о том, что мы можем приспособить многосимвольные токены с минимальными изменениями в нашей предыдущей работе. Для краткости и простоты я ограничу сам себя подмножеством того, что мы сделали ранее: я разрешу только одну управляющую конструкцию (IF) и никаких булевых выражений. Этого достаточно для демонстрации синтаксического анализа и ключевых слов и выражений. Расширение до полного набора конструкций должно быть довольно очевидно из того, что мы уже сделали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все элементы программы для синтаксического анализа этого подмножества с использованием односимвольных токенов уже существуют в наших предыдущих программах. Я построил ее осторожно скопировав эти файлы, но я не посмею попробовать провести вас через этот процесс. Вместо этого, во избежание беспорядка, вся программа показана ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program KISS;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lcount: integer; \{ Label Counter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip a CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Getname := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Ident;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + GetNum + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate the First Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var s: boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 s := Look = '-';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXS.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Completion of Term Processing (called by Term and FirstTerm \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term with Possible Leading Sign \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Condition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ This version is a dummy \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Procedure Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('Condition');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR: while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> 'e' then Expected('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пара комментариев: \b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Форма синтаксического анализатора выражений, использующего FirstTerm и т.п., немного отличается от того, что вы видели ранее. Это еще одна вариация на ту же самую тему. Не позволяйте им вертеть вами... изменения необязательны для того, что будет дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что как обычно я добавил вызовы Fin в стратегических местах для поддержки множественных строк.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем приступить к добавлению сканера, сначала скопируйте этот файл и проверьте, что он действительно корректно выполняет анализ. Не забудьте «кода»: "i" для IF, "l" для ELSE и "e" для ELSE или ENDIF.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если программа работает, тогда давайте поспешим. При добавлении модулей сканера в программу поможет систематический план. Во всех синтаксических анализаторах, которые мы написали до этого времени, мы придерживались соглашения, что текущий предсказывающий символ должен всегда быть непустым символом. Мы предварительно загружали предсказывающий символ в Init и после этого оставляли «помпу запущенной». Чтобы позволить программе работать правильно с новыми строками мы должны ее немного модифицировать и обрабатывать символ новой строки как допустимый токен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В многосимвольной версии правило аналогично: текущий предсказыващий символ должен всегда оставаться на начале следующей лексемы или на новой строке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многосимвольная версия показана ниже. Чтобы получить ее я сделал следующие изменения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Добавлены переменные Token и Value и определения типов, необходимые для Lookup.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Добавлено определение KWList и KWcode.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Добавлен Lookup.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • GetName и GetNum заменены их многосимвольными версиями. (Обратите внимание, что вызов Lookup был перемещен из GetName, так что он не будет выполняться внутри выражений).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Создана новая, рудиментарная Scan, которая вызывает GetName затем сканирует ключевые слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Создана новая процедура MatchString, которая ищет конкретное ключевое слово. Заметьте, что в отличие от Match, MatchString не считывает следующее ключевое слово.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Изменен Block для вызова Scan.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Немного изменены вызовы Fin. Fin теперь вызывается из GetName.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа полностью:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program KISS;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token : char; \{ Encoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value : string[16]; \{ Unencoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lcount: integer; \{ Label Counter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array [1..4] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWcode: string[5] = 'xilee';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip a CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Table Lookup \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Lookup(T: TabPtr; s: string; n: integer): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found: boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := false;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 i := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while (i > 0) and not found do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s = T^[i] then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := true\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 dec(i);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lookup := i;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '#';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier and Scan it for Keywords \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, 4) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input String \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure MatchString(x: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Value <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Ident;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Value + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Ident\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + Value + ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate the First Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var s: boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 s := Look = '-';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D1');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXS.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Completion of Term Processing (called by Term and FirstTerm \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term with Possible Leading Sign \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Condition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ This version is a dummy \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Procedure Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('Condition');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Condition;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDIF');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Statement Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not (Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoProgram;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравните эту программу с ее односимвольным вариантом. Я думаю вы согласитесь, что различия минимальны.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому времени вы узнали как анализировать и генерировать код для выражений, булевых выражений и управляющих структур. Теперь вы изучили, как разрабатывать лексические анализаторы и как встроить их элементы в транслятор. Вы все еще не видели всех элементов, объединеных в одну программу, но на основе того, что мы сделали ранее вы должны прийти к заключению, что легко расширить наши ранние программы для включения лексических анализаторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы очень близки к получению всех элементов, необходимых для построения настоящего, функционального компилятора. Есть еще несколько отсутствующих вещей, особенно вызовы процедур и определения типов. Мы будем работать с ними на следующих нескольких уроках. Прежде чем сделать это, однако, я подумал что было бы забавно превратить транслятор в настоящий компилятор. Это то, чем мы займемся в следующей главе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До настоящего времени мы применяли предпочтительно восходящий метод синтаксического анализа, начиная с низкоуровневых конструкций и продвигаясь вверх. В следующей главе я также взгляну сверху вниз, и мы обсудим, как изменяется структура транслятора при изменении определения языка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Немного философии\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот урок будет отличаться от других уроков в нашей серии по синтаксическому анализу и конструированию компиляторов. На этом уроке не будет никаких экспериментов или кода. На этот раз я хотел бы просто поговорить с вами некоторое время. К счастью, это будет короткий урок и затем мы сможем продолжить с того места где остановились, надо надеяться с обновленной энергией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я учился в университете, я обнаружил, что могу всегда следить за профессорской лекцией намного лучше, если знал куда он идет. Готов поспорить, с вами было то же самое.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что я подумал, может быть пришло время расказать вам куда мы идем с этой серией: что нас ждет в будущих главах и вообще что к чему. Я также поделюсь своими общими мыслями о полезности того, что мы делали.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Дорога домой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока что мы охватили синтаксический анализ и трансляцию арифметических выражений, булевых выражений и их комбинаций, связанных операторами отношений. Мы также сделали то же самое для управляющих конструкций. Во всем этом мы склонялись в основном к использованию нисходящего синтаксического анализа методом рекурсивного спуска, определение синтаксиса в БНФ и непосредственной генерации ассемблерного кода. Мы также изучили значение такого приема как односимвольные токены. В последней главе мы работали с лексическим анализом и я показал вам простой но мощный способ преодоления односимвольного барьера.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В течение всех этих исследований, я особенно выделял философию KISS... Keep It Simple, Sidney... и я надеюсь, что к настоящему времени вы поняли, насколько простыми могут в действительности быть эти вещи. Хотя наверняка имеются области в теории компиляции которые являются по настоящему пугающими, основной мыслью этой серии является то, что на практике вы можете просто вежливо обойти многие из этих областей. Если определение языка способствует этому или, как в этой серии, если вы можете определить язык по ходу дела, то возможно записать определение языка в БНФ с достаточным удобством. И, как мы видели, вы можете вывести процедуры синтаксического анализа из БНФ почти также быстро, как вы можете набирать на клавиатуре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По мере того, как наш компилятор принимал некоторую форму, он приобретал больше частей, но каждая часть довольно мала и проста и очень похожа на все другие.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту у нас есть многое из того, что составляет настоящий практический компилятор. Фактически, мы уже имеем все что нам нужно для создания игрушечного языка столь же мощного, как, скажем, Tiny Basic. В следующих двух главах мы пойдем вперед и определим этот язык.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для завершения этой серии, у нас все еще есть несколько тем для раскрытия. Они включают:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вызовы процедур, с параметрами и без.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Локальные и глобальные переменные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Базовые типы, такие как символьные и целочисленные типы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Массивы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Строки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Типы и структуры, определяемые пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Синтаксические анализаторы с деревьями и промежуточные языки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Оптимизация.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это будет рассмотрено в будущих главах. Когда мы закончим, вы будете иметь все инструменты, необходимые для разработки и создания своего собственного языка и компиляторов для его трансляции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не могу спроектировать эти языки для вас, но я могу дать некоторые комментарии и рекомендации. Я уже высказал некоторые из них в прошлых главах. Вы видели, например, какие управляющие структуры я предпочитаю.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти конструкции будут частью создаваемых мной языков. К этому моменту я представляю три языка, два из которых вы увидите в очередных главах:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 TINY – минимальный, но пригодный для использования язык уровня Tiny Basic или Tiny C. Он не будет очень практичным, но будет достаточно мощным, чтобы позволить вам писать и запускать настоящие программы которые делают что-нибудь заслуживающее внимание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 KISS – язык, который я создаю для своего собственного использования. KISS предназначен быть языком системного программирования. Он не будет иметь строгого контроля типов или причудливых структур данных, но он будет поддерживать большинство вещей, которые я хочу делать с языком более высокого уровня (HOL), за исключением возможно написания компиляторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также играл в течение нескольких лет с идеей HOL-подобного ассемблера со структурными управляющими конструкциями и HOL-подобными операциями присваивания. Это фактически было стимулом для моего первоначального углубления в джунгли теории компиляции. Этот язык возможно никогда не будет создан просто потому, что я узнал, что проще реализовать язык типа KISS, который использует только подмножество инструкций ЦПУ. Как вы знаете, ассемблер может быть предельно причудливым и нерегулярным, и язык, который отображается в него один к одному, может быть настоящим вызовом. Однако я всегда чувствовал, что синтаксис, используемый в стандартных ассемблерах тупой... почему\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L A,B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лучше или проще для трансляции, чем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 B=A?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думаю, было бы интересным упражнением разработка «компилятора» который дал бы программисту полный доступ и к контролю над полным набором инструкций ЦПУ, и позволил бы вам генерировать программы настолько же эффективные как язык ассемблер без болезненного изучения набора мнемоник. Это может быть сделано? Я не знаю. Настоящим вопросом может быть вопрос «будет ли полученный язык проще, чем ассемблер?» Если нет, то в нем нет никакого смысла. Я думаю, что это может быть сделано, но я полностью еще не уверен в том, как должен выглядеть синтаксис.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно у вас есть некоторые комментарии или предложения об этом. Буду рад услышать их.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы возможно не будете удивлены узнав, что уже работал в большинстве тех областей, которые мы рассмотрим. Я имею несколько хороших новостей: дела никогда не будут намного более сложными, чем они были до этого. Возможно построить завершенный, работающий компилятор для реального языка используя только те самые методы которые вы изучили до этого. И это поднимет некоторые интересные вопросы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Почему это так просто? \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед осуществлением этой серии я всегда думал, что компиляторы были просто естественно сложными компьютерными программами... предельно вызывающими. Однако то, что мы здесь делали обычно оказывалось совершенно простым, иногда даже тривиальным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторое время я думал, что это было просто потому, что я еще не залез в глубь темы. Я только охватил простые части. Я легко признаюсь вам что даже когда я начинал эту серию я не был уверен в том, как далеко мы будем способны продвинуться прежде чем дела станут слишком сложными для работы имеющимися способами. Но сейчас я уже нахожусь достаточно близко, чтобы увидеть конец пути. Какой вывод?\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Здесь нет ничего сложного!\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем я думал, что причина в том, что мы не генерировали очень хороший объектный код. Те из вас, кто следовали этой серии и пытались компилировать примеры, знают, что хотя код работает и достаточно отказоустойчив, его эффективность довольно ужасна. Я подчеркивал, что если бы мы сконцентрировались на получении компактного кода, то быстро бы получили всю недостающую сложность.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В какой то степени это так. В частности, мои первые небольшие усилия при попытке повысить эффективность подняли сложность до опасного уровня. Но с той поры когда я возился с некоторыми простыми методами оптимизацией и обнаружил некоторые, которые приводят к очень приличному качеству кода без добавления больших сложностей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец я подумал, что возможно причина была в «игрушечной» природе компилятора Я не претендовал на то, что мы когда-нибудь будем способны построить компилятор, конкурирующий с Borland и Microsoft. И однако снова, когда я забираюсь глубже в эти дела различия начинают стираться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Просто чтобы удостовериться что до вас дошла эта мысль, позвольте мне ее высказать напрямую:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя методы, которые мы здесь применяли, возможно создать работающий, промышленного качества компилятор не добавляя много сложности к тому, что мы уже сделали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С тех пор, как началась эта серия, я получил от вас некоторые комментарии. Большинство из них повторяют мои собственные мысли: «Это просто! Почему учебники представляют это настолько сложным?» Хороший вопрос.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Недавно я возвратился и взглянул на некоторые из этих текстов снова и даже купил и читаю некоторые новые. Каждый раз я возвращался с тем же чувством: эти ребята представляют это слишком сложным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Что происходит? Почему все это кажется сложным в этих книгах, но легким для нас? Действительно ли мы умней чем Ахо, Ульман, Бринч Хансен и все остальные?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Едва ли. Но мы делаем некоторые вещи по-другому и все более и более я начинаю ценить значение нашего подхода и способ, которым он упрощает дело. Кроме очевидных сокращений, которые я выделил в первой части, типа односимвольных токенов и консольного ввода/вывода, мы сделали некоторые неявные предположения и сделали некоторые вещи отличными от того, как разрабатывали компиляторы в прошлом. Как оказалось, наш метод делает жизнь намного проще.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но почемы все другие ребята не используют его?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы должны вспомнить контекст некоторых ранних разработок компиляторов. Эти люди работали на очень небольших компьютерах с ограниченными возможностями. Объемы памяти были очень ограничены, набор команд центрального процессора был минимален и программы чаще выполнялись в пакетном режиме, чем в интерактивном. Как оказалось, это повлияло на некоторые ключевые решения проекта, которые действительно усложнили проект. До недавнего времени я не понимал, насколько классический дизайн компилятора был обусловлен доступным оборудованием.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Даже в тех случаях, где эти ограничения больше не накладывались, люди предпочитали структурировать их программы тем же самым образом, так как это способ, которому они обучались.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем случае мы начали с чистого листа бумаги. Имеется опасность, конечно, что вы попадетесь в ловушки, которые другие люди давно научились избегать. Но это также позволило нам использовать различные подходы, которые, частично из-за проекта, частично из-за чистой удачи, позволили нам добиться простоты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеются области, которые, я думаю, в прошлом приводили к сложности:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Ограниченная оперативная память, вынуждающая выполнять множество проходов.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я только что прочитал «Brinch Hansen on Pascal Compilers» (отличная книга, BTW). Он разработал компилятор Pascal для PC, но он начал в 1981 г. с систем с 64К памяти и поэтому почти каждое решение проекта который он делал, было нацелено на то, чтобы уместить компилятор в ОЗУ. Чтобы сделать это, его компилятор выполнял три прохода, один из которых – лексический анализ. Не было никакого способа, с помощью которого он мог бы, например, использовать распределенный сканер, который я представил в последней главе, потому что структура программы не позволяла этого. Ему также требовались не один а два промежуточных языка для обеспечения связи между фазами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все ранние создатели компиляторов были вынуждены иметь дело с такой проблемой: разбить компилятор на достаточные части так, чтобы они поместились в памяти. Когда у вас есть множество проходов, вы должны добавить структуры данных для поддержки информации которую каждый проход оставляет для следующего. Это добавляет сложность и завершает управление проектом. В книге Ли «The Anatomy of a Compiler» упоминается компилятор Fortran, разработанный для IBM 1401. Он имел не менее 63 отдельных проходов! Само собой разумеется, в компиляторе, подобном этому, разделение на фазы доминировало бы над дизайном.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Даже в ситуации, когда ОЗУ достаточно, люди предпочитали использовать те же самые методы, с которыми они хорошо знакомы. До тех пор, пока не появился Turbo Pascal, мы не знали насколько может быть простым компилятор если бы вы начали с других предположений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Пакетная обработка.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ранние дни пакетная обработка была единственным выбором... не существовало никаких интерактивных вычислений. Даже сегодня компиляторы по существу выполняются в пакетном режиме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В компиляторах для майнфреймов, так же как и во многих микро компиляторах, значительные усилия расходуются на восстановление после ошибок... это может занять 30-40% компилятора и полностью управлять проектом. Идея состоит в том, чтобы избежать остановки на первой ошибке, а скорее идти любой ценой, так чтобы вы могли сказать программисту о как можно большем количестве ошибок во всей программе насколько возможно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это возвращает нас к дням ранних майнфреймов, где время выполнения измерялось в часах и днях и было важно выжать каждую последнюю унцию информации из каждого выполнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой серии я был очень осторожен и избежал проблемы восстановления после ошибок и вместо этого наш компилятор просто останавливается с сообщением на первой ошибке. Я откровенно признаюсь, что это было в основном потому, что я захотел использовать легкий путь и сохранить простоту. Но этот метод, заданный изначально Borland в Turbo Pascal также имеет много полезного в любом случае. Кроме сохранения простоты компилятора это также очень хорошо соответствует идее интерактивной системы. Когда компиляция происходит быстро и, особенно, когда вы имеете редактор типа Borland который будет правильно указывать вам на точку ошибки, тогда имеет смысл остановиться там и просто перезапустить компиляцию после того, как ошибка исправлена.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Большие программы.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ранние компиляторы были разработаны для поддержки больших программ... по существу бесконечных. В те дни существовал небольшой выбор; идея с библиотеками подпрограмм и раздельной компиляцией была еще в будущем. Снова, это предположение вело к многопроходному дизайну и промежуточным файлам для поддержки результатов раздельной обработки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поставленная Бринч Хансеном цель состояла в том, чтобы компилятор был способен компилировать сам себя. Снова, из-за ограничений оперативной памяти это приводило его к многопроходному дизайну. Он нуждался в таком маленьком резидентном коде компилятора, насколько возможно, так чтобы необходимые таблицы и другие структуры данных поместились в оперативную память.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не заявил об этом пока, потому что не было необходимости... мы всегда просто читали и записывали данные как потоки, в любом случае. Но, для заметки, мой план всегда был в том, чтобы в промышленном компиляторе исходные и обьектные данные должны сосуществовать в ОЗУ с компилятором, аля ранний Turbo Pascal. Вот почему я был осторожен и сохранил подпрограммы типа GetChar и Emit как отдельные попрограммы, несмотря на их небольшой размер. Будет просто изменить их на чтение и запись из памяти.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Акцент на эффективность.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Джон Бэкус заявил, что когда он и его коллеги разработали первоначальный компилятор Fortran они знали, что они должны получать компактный код. В те дни имелись сильные чувства против HOL в пользу ассемблера и причиной была эффективность. Если бы Fortran не производил очень хороший код по стандартам ассемблера, пользователи просто бы отказались использовать его. Заметьте, компилятор Fortran оказался одним из наиболее эффективных из когда либо созданных.в терминах качества кода. Но он был сложным!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сегодня мы имеем мощъ ЦПУ и размер ОЗУ с запасом, так что эффективность кода не такая большая проблема. Старательно игнорируя эту проблему мы действительно были способны сохранить простоту. Как ни странно, тем не менее, как я сказал, я нашел некоторую оптимизацию которую мы можем добавить в базовую структуру компилятора не добавляя слишком много сложности. Так что в этом случае мы получим свой пирог и сьедим его: мы в любом случае закончим с приемлемым качеством кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Ограниченный набор инструкций.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первые компьютеры имели примитивный набор команд. Вещи, которые мы считаем само собой разумеющимися такие как операции со стеком и косвенная адресация появились с большими сложностями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример: в большинстве компиляторов имеется структура данных, называемая литерный пул (literal pool). Компилятор обычно идентифицирует все литералы, используемые в программе и собирает их в одиночную структуру данных. Все ссылки на литералы сделаны косвенно на этот пул. В конце компиляции компилятор выдает команды для выделения памяти и инициализации литерного пула.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам пока не нужно было обращаться к этой проблеме. Когда нам нужно загрузить литерал мы просто делаем это строкой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE #3,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно кое-что упомянуть об использования литерного пула особенно на машине типа 8086, где данные и код могут быть разделены. Однако все это добавляет довольно большое количество сложности с небольшим результатом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, без стека мы бы потерялись. И вызовы подпрограмм и временная память сильно зависят от стека и мы использовали его даже больше, чем необходимо для облегчения синтаксического анализа выражений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Желание общности.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многое из содержимого типичной книги по компиляторам акцентировано на вопросы, к которым мы совсем не обращались... вопросы типа автоматической трансляции грамматик или генерация таблиц LALR анализа. Это не просто, потому что авторы хотят впечатлить вас. Имеются хорошие практические причины, почему эти темы рассмотрены здесь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы концентрировались на использовании синтаксического анализатора с рекурсивным спуском для анализа детерминированной грамматики, т.е. грамматики, которая однозначна и, следовательно, может быть проанализирована с одним уровнем предсказывания. Я не сделал из этого большого ограничения, но факт то, что это представляет небольшое подмножество возможных грамматик. Фактически, существует бесконечное число грамматик, которые мы не можем анализировать используя наш метод. LR метод более мощный и может работать с теми грамматиками, с которыми мы не можем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В теории компиляции важно знать, как работать с этими другими грамматиками и как преобразовать их в грамматики которые проще для работы с ними. К примеру многие (но не все) неоднозначные грамматики могут быть преобразованы в однозначные. Способ сделать это не всегда очевиден, всетаки, и так много людей посвятили годы на разработку способа их автоматического преобразования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На практике, эти проблемы оказываются значительно менее важными. Современные языкы стараются разрабатывать так, чтобы они были простыми для анализа в любом случае. Это было ключевой мотивацией при разработке Pascal. Несомненно, имеются паталогические грамматики, для которых вы с большим трудом написали бы однозначную БНФ, но в реальном мире лучшим ответом возможно было бы избежание этих грамматик.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем случае, конечно, мы трусливо позволили языку развиваться по ходу дела. Вы не можете всегда иметь такую роскошь. Однако, с небольшой заботой вы были бы способны сохранить синтаксический анализатор простым без необходимости прибегать к автоматическому переводу грамматик.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой серии мы приняли значительно отличающийся подход. Мы начали с чистого листа бумаги и разработали методы, которые работают в том контексте, в котором мы находимся: это однопользовательский персональный компьютер с вполне достаточно мощным ЦПУ и объемом ОЗУ. Мы ограничили сами себя приемлемыми грамматиками, которые легки для анализа, мы с успехом использовали систему команд ЦПУ, и мы не концентрировались на эффективности. Именно поэтому это было просто.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Означает ли это, что мы навсегда обречены создавать только игрушечные компиляторы? Нет, я так не думаю. Я уже сказал, что мы можем добавить некоторую оптимизацию без изменения структуры компилятора. Если мы захотим обрабатывать большие файлы, мы всегда можем добавить для этого буферизацию файлов. Эти вещи не оказывают влияния на общий дизайн компилятора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И я думаю что это главный фактор. Начав с маленьких и ограниченных случаев мы были способны сконцентрироваться на структуре компилятора, которая естественна для работы. Так как структура естественным образом удовлетворяет работе, она почти обречена быть простой и прозрачной. Добавление возможностей не должно изменять основную структуру. Мы можем просто добавить расширения типа файловой структуры или добавить уровень оптимизации. Я считаю, что когда ресурсы были ограничены, структуры, которые люди получали, были искуственно искажены чтобы заставить их работать в этих условиях, и не были оптимальными структурами для имеющейся проблемы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае, это мое личное предположение каким образом у нас была возможность сохранить простоту. Мы начали с чего-то простого и позволили ему развиваться естественным образом, не пытаясь направит его в какое-то традиционное русло.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы собираемся продолжать таким же образом. Я дал вам список областей, которые мы охватим в следующих главах. После прочтения этих глав вы будете способны создавать законченные, работающие компиляторы почти для любого случая и делать это легко. Если вы действительно хотите создать компилятор промышленного качества вы сможете сделать и это также.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для тех из вас, кто застоялся в ожидании кода для синтаксического анализатора, я приношу извинения за это отклонение. Я просто подумал, что вы хотели бы немного рассмотреть дела в перспективе. В следующий раз мы вернемся к основной цели обучения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока что мы рассмотрели только части компиляторов и хотя мы имеем многое из завершенного языка мы не говорили о том как сложить все это вместе. Это будет темой наших следующих двух глав. Затем мы поспешим к новым темам, которые я указал в начале этой главы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Вид сверху\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В предыдущих главах мы изучили многие из методов, необходимых для создания полноценного компилятора. Мы разработали операции присваивания (с булевыми и арифметическими выражениями), операторы отношений и управляющие конструкции. Мы все еще не обращались к вопросу вызова процедур и функций, но даже без них мы могли бы в принципе создать мини-язык. Я всегда думал, что было бы забавно просто посмотреть, насколько маленьким можно было бы построить язык, чтобы он все еще оставался полезным. Теперь мы уже почти готовы сделать это. Существует проблема: хотя мы знаем, как анализировать и транслировать конструкции, мы все еще совершенно не знаем, как сложить их все вместе в язык.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этих ранних главах разработка наших программ имела явно восходящий характер. В случае с синтаксическим анализом выражений, например, мы начали с самых низкоуровневых конструкций, индивидуальных констант и переменных и прошли свой путь до более сложных выражений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большинство людей считают, что нисходящий способ разработки лучше, чем восходящий. Я тоже так думаю, но способ, который мы использовали, казался естественно достаточным для тех вещей, которые мы анализировали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тем не менее вы не должны думать, что последовательный подход, который мы применяли во всех этих главах, является принципиально восходящим. В этой главе я хотел бы показать вам, что этот подход может работать точно также, когда применяется сверху вниз... может быть даже лучше. Мы рассмотрим языки типа C и Pascal и увидим как могут быть построены законченные компиляторы начиная сверху.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующей главе мы применим ту же самую методику для создания законченного транслятора подмножества языка KISS, который я буду называть TINY. Но одна из моих целей в этой серии состоит в том, чтобы вы не только могли увидеть как работает компилятор для TINY или KISS, но чтобы вы также могли разрабатывать и создавать компиляторы своих собственных языков. Примеры Си и Паскаля помогут вам в этом. Одна вещь, которую я хотел чтобы вы увидели, состоит в том, что естественная структура компилятора очень сильно зависит от транслируемого языка, поэтому простота и легкость конструирования компилятора очень сильно зависит от того, позволите ли вы языку определять структуру программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Немного сложнее получить полный компилятор C или Pascal, да мы и не будем. Но мы можем расчистить верхние уровни так, чтобы вы увидели как это делается.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Верхний уровень\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из самых больших ошибок людей при нисходящем проектировании заключается в неправильном выборе истинной вершины. Они думают, что знают какой должна быть общая структура проекта и поэтому они продолжают и записывают ее.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Всякий раз, когда я начинаю новый проект, я всегда хочу сделать это в самом начале. На языке разработки программ (program design language – PDL) этот верхний уровень походит на что-нибудь вроде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 solve the problem\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, я соглашусь с вами, что это не слишком большая подсказка о том, что расположено на следующем уровене, но я все равно запишу это просто для того, чтобы почувствовать, что я действительно начинаю с вершины.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем случае, общая функция компилятора заключается в компиляции законченной программы. С этого начинается любое определение языка, записанное в БНФ. На что походит верхний уровень БНФ? Хорошо, это немного зависит от транслируемого языка. Давайте взглянем на Pascal.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Структура Паскаля\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большинство книг по Pascal включают БНФ определение языка. Вот несколько первых строк одного из них:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program> ::= <program-header> <block> '.'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program-header> ::= PROGRAM <ident>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= <declarations> <statements>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем написать подпрограммы распознавания для работы с каждым из этих элементов подобно тому, как мы делали это прежде. Для каждого из них мы будем использовать знакомые нам односимвольные токены, затем понемногу расширяя их. Давайте начнем с первого распознавателя: непосредственно программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для ее трансляции мы начнем с новой копии Cradle. Так как мы возвращаемся к односимвольным именам мы будем просто использовать "p" для обозначения «program».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К новой копии Cradle добавьте следующий код и вставьте обращение к нему из основной программы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate A Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p'); \{ Handles program header part \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуры Prolog и Epilog выполняют все, что необходимо для связи программы с операционной системой так чтобы она могла выполняться как программа. Само собой разумеется, эта часть будет очень ОС-зависима. Помните, что я выдаю код для 68000, работающий под ОС, которую я использую – SK*DOS. Я понимаю, что большинство из вас использует PC и вы предпочли бы увидеть что-нибудь другое, но я слишком далеко зашел, чтобы что-то сейчас менять!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае, SK*DOS особенно простая для общения операционная система. Вот код для Prolog и Epilog:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('WARMST EQU $A01E');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Epilog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Epilog(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DC WARMST');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END ' + Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно добавьте этот код и испытайте «компилятор». В настоящее время существует только одна допустимая входная последовательность:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 px. (где х – это любая одиночная буква, имя программы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, как обычно наша первая попытка не очень впечатляет, но я уверен к настоящему времени вы знаете, что дальше станет интересней. Есть одна важная вещь, которую следует отметить: на выходе получается работающая, законченная и выполнимая программа (по крайней мере после того, как она будет ассемблирована).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это очень важно. Приятная особенность нисходящего метода состоит в том, что на любом этапе вы можете компилировать подмножество завершенного языка и получить программу, которая будет работать на конечной машине. Отсюда, затем, нам необходимо только добавлять возможности, расширяя конструкции языка. Это очень похоже на то, что мы уже делали, за исключением того, что мы подходили к этому с другого конца.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Расширение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы расширить компилятор мы должны просто работать с возможностями языка последовательно. Я хочу начать с пустой процедуры, которая ничего не делает, затем добавлять детали в пошаговом режиме. Давайте начнем с обработки блока в соответствии с его PDL выше. Мы можем сделать это в два этапа. Сначала добавьте пустую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Pascal Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBlock(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 и измените Prog следующим образом:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate A Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoBlock(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это конечно не должно изменить поведения программы, и не меняет. Но сейчас определение Prog закончено и мы можем перейти к расширению DoBlock. Это получается прямо из его БНФ определения:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Pascal Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBlock(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Declarations;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Statements;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура PostLabel была определена в главе по ветвлениям. Скопируйте ее в вашу копию Cradle.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я возможно должен объяснить причину вставки метки. Это имеет отношение к работе SK*DOS. В отличие от некоторых других ОС, SK*DOS позволяет точке входа в основную программу находиться в любом месте программы. Все, что вы должны сделать, это дать этой точке имя. Вызов PostLabel помещает это имя как раз перед первым выполнимым утверждением в основной программе. Как SK*DOS узнает какая из множества меток является точкой входа, спросите вы? Та, которая соответствует утверждению END в конце программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нам нужны заглушки для процедур Declarations и Statements. Сделайте их пустыми процедурами как мы делали это раньше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа все еще делает то же самое? Тогда мы можем перейти к следующему этапу.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объявления\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БНФ для объявлений в Pascal такая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <declarations> ::= ( <label list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <constant list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <type list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <variable list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <procedure> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <function> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что я использую более либеральное определение, используемое в Turbo Pascal. В определении стандартного Pascal каждая из этих частей должна следовать в определенном порядке относительно других).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно давайте позволим одиночным символам представлять каждый из этих типов объявлений. Новая форма для Declarations:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate the Declaration Part \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Declarations;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look in ['l', 'c', 't', 'v', 'p', 'f'] do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'l': Labels;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'c': Constants;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 't': Types;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Variables;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoProcedure;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'f': DoFunction;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, нам нужны процедуры-заглушки для каждого из этих типов объявлений. На этот раз они не могут быть совсем пустыми процедурами, так как иначе мы останемся с бесконечным циклом While. По крайней мере каждая подпрограмма распознавания должна съедать символ, который вызывает ее. Вставьте следующие процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Label Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Labels;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Const Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Constants;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('c');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Type Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Types;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('t');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Var Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Variables;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Procedure Definition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProcedure;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process Function Definition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoFunction;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('f');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь испытайте компилятор используя несколько характерных входных последовательностей. Вы можете смешивать объявления любым образом, каким вам нравится пока последним символом в программе не будет ".", указывающий на конец программы. Конечно, ни одно из этих объявлений фактически ничего не объявляет, так что вам не нужны (и вы не можете использовать) любые символы, кроме тех, которые обозначают ключевые слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем расширить раздел операторов аналогичным способом. БНФ для него будет:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <statements> ::= <compound statement>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <compound statement> ::= BEGIN <statement>(';' <statement>) END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что утверждение может начинаться с любого идентификатора, исключая END. Так что первая пустой формой процедуры Statements будет:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate the Statement Part \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Statements;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> 'e' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас компилятор примет любое число объявлений, сопровождаемое блоком BEGIN основной программы. Сам этот блок может содержать любые символы (за исключением END), но они должны присутствовать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Простейшая входная форма сейчас\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'pxbe.'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте ее. Также попробуйте некоторые ее комбинации. Сделайте некоторые преднамеренные ошибки и посмотрите что произойдет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту вы должны начать видеть основную линию. Мы начинаем с пустого транслятора для обработки программы, затем в свою очередь мы расширяем каждую процедуру, основанную на ее БНФ определении. Подобно тому, как более низкоуровневые БНФ определения добавляют детали и развивают определения более высокого уровня, более низкоуровневые распознаватели будут анализировать более детально входную программу. Когда последняя заглушка будет расширена, компилятор будет закончен. Это нисходящая разработка/реализация в ее чистейшей форме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы могли бы заметить, что даже хотя мы и добавляли процедуры, выходной результат программы не изменялся. Так и должно быть. На этих верхних уровнях не требуется никакой выдачи кода. Распознаватели функционируют просто как распознаватели. Они принимают входные последовательности, отлавливают плохие и направляют хорошие в нужные места, так что они делают свою работу. Если бы мы занимались этим немного дольше, код начал бы появляться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующим шагом в нашем расширении должна возможно быть процедура Statements. Определение Pascal:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <statement> ::= <simple statement> | <structured statement>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <simple statement> ::= <assignment> | <procedure call> | null\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <structured statement> ::= <compound statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <if statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <case statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <while statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <repeat statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <for statement> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <with statement>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это начинает выглядеть знакомыми. Фактически вы уже прошли через процесс синтаксического анализа и генерации кода и для операций присваивания и для управляющих структур. Это место, где верхний уровень встречается с нашим восходящим методом из предыдущих уроков. Конструкции будут немного отличаться от тех, которые мы использовали для KISS, но в этих различиях нет ничего, чего бы вы не смогли сделать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думаю теперь вы можете получить представление об этом процессе. Мы начали с завершенного БНФ описания языка. Начиная с верхнего уровня мы закодировали распознаватели для этих БНФ утверждений используя процедуры-заглушки для распознавателей следующего уровня. Затем мы расширили более низкоуровневые утверждения один за другим.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как оказывается, определение Pascal очень совместимо с использованием БНФ и БНФ описания этого языка существуют в избытке. Вооружившись таким описанием вы обнаружите, что довольно просто продолжить процесс, который мы начали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы могли бы продолжить расширение этих конструкций, просто чтобы прочувствовать это. Я не ожидаю, что вы сможет завершить сейчас компилятор Паскаля... есть слишком много вещей таких как процедуры и типы, к которым мы еще не обращались... но могло бы быть полезным попробовать некоторые из более знакомых вещей. Вам было бы полезно увидеть выполнимые программы, появляющиеся с другого конца.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если бы я собирался обратиться к вопросам которые мы еще не охватили, я предпочел бы сделать это в контексте KISS. Мы не пытаемся построить полный копилятор Pascal, поэтому я собираюсь остановить на этом расширение Pascal. Давайте взглянем на очень отличающийся язык.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Структура Си\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык C совсем другой вопрос, как вы увидите. Книги по C редко включают БНФ определения языка. Возможно дело в том, что этот язык очень сложен для описания в БНФ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из причин что я показываю вам сейчас эти структуры в том что я могу впечатлить вас двумя фактами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1. Определение языка управляет структурой компилятора. Что работает для одного языка может быть бедствием для другого. Это очень плохая идея попытаться принудительно встроить данную структуру в компилятор. Скорее вы должны позволить БНФ управлять структурой, как мы делали здесь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2. Язык, для которого сложно написать БНФ также будет возможно сложен для написания компилятора. Си – популярный язык и он имеет репутацию как позволяющий сделать практически все, что возможно. Несмотря на успех Small С, С является непростым для анализа языком.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа на C имеет меньше структур, чем ее аналог на Pascal. На верхнем уровне все в C является статическим объявлением или данных или функций. Мы можем зафиксировать эту мысль так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program> ::= ( <global declaration> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <global declaration> ::= <data declaration> | <function>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Small C функции могут иметь только тип по умолчанию int, который не объявлен. Это делает входную программу легкой для синтаксического анализа: первым токеном является или «int», «char» или имя функции. В Small C команды препроцессора также обрабатываются компилятором соответствующе, так что синтаксис становится:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <global declaration> ::= '#' <preprocessor command> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'int' <data list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'char' <data list> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> <function body> |\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя мы в действительности больше заинтересованы здесь в полном C , я покажу вам код, соответствующий структуре верхнего уровня Small C.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate A Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> ^Z do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '#': PreProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': IntDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'c': CharDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else DoFunction(Int);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что я должен был использовать ^Z чтобы указать на конец исходного кода. C не имеет ключевого слова типа END или "." для индикации конца программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С полным Си все не так просто. Проблема возникает потому, что в полном Си функции могут также иметь типы. Так что когда компилятор видит ключевое слово типа «int» он все еще не знает ожидать ли объявления данных или определение функции. Дела становятся более сложными так как следующим токеном может быть не имя... он может начинаться с "*" или "(" или комбинаций этих двух.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Точнее говоря, БНФ для полного Си начинается с:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program> ::= ( <top-level decl> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <top-level decl> ::= <function def> | <data decl>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <data decl> ::= [<class>] <type> <decl-list>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <function def> ::= [<class>] [<type>] <function decl>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вы можете увидеть проблему: первые две части обьявлений для данных и функций могут быть одинаковыми. Из-за неоднозначности в этой грамматике выше, она является неподходящей для рекурсивного синтаксического анализатора. Можем ли мы преобразовать ее в одну из подходящих? Да, с небольшой работой. Предположим мы запишем ее таким образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <top-level decl> ::= [<class>] <decl>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <decl> ::= <type> <typed decl> | <function decl>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <typed decl> ::= <data list> | <function decl>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем написать подпрограмму синтаксичесого анализа для определений классов и типов и позволять им отложить их сведения и продолжать выполнение даже не зная обрабатывается ли функция или объявление данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала, наберите следующую версию основной программы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> ^Z do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetClass;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetType;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На первый раз просто сделайте три процедуры-заглушки которые ничего не делают, а только вызывают GetChar.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работает ли эта программа? Хорошо, было бы трудно не сделать это, так как мы в действительности не требовали от нее какой-либо работы. Уже говорилось, что компилятор Си примет практически все без отказа. Несомненно это правда для этого компилятора, потому что в действительности все, что он делает, это съедает входные символы до тех пор, пока не найдет ^Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем давайте заставим GetClass делать что-нибудь стоящее. Объявите глобальную переменную\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var Class: char;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и измените GetClass\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Storage Class Specifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Procedure GetClass;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look in ['a', 'x', 's'] then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Class := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Class := 'a';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь я использовал три одиночных символа для представления трех классов памяти «auto», «extern» и «static». Это не единственные три возможных класса... есть также «register» и «typedef», но это должно дать вам представление. Заметьте, что класс по умолчанию «auto».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем сделать подобную вещь для типов. Введите следующую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Type Specifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetType;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'u' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Sign := 'u';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := 'i';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Sign := 's';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look in ['i', 'l', 'c'] then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что вы должны добавить еще две глобальные переменные Sign и Typ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С этими двумя процедурами компилятор будет обрабатывать определение классов и типов и сохранять их результаты. Мы можем сейчас обрабатывать остальные объявления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы еще ни коим образом не выбрались из леса, потому что все еще существуют много сложностей только в определении типов до того, как мы дойдем даже до фактических данных или имен функций. Давайте притворимся на мгновение, что мы прошли все эти заслоны и следующим во входном потоке является имя. Если имя сопровождается левой скобкой, то мы имеем объявление функции. Если нет, то мы имеем по крайней мере один элемент данных, и возможно список, каждый элемент которого может иметь инициализатор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вставьте следующую версию TopDecl:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Top-Level Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := Getname;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoFunc(Name)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoData(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что так как мы уже прочитали имя, мы должны передать его соответствующей подпрограмме.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, добавьте две процедуры DoFunc и DoData:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Function Definition \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoFunc(n: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('\{');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('\}');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Typ = ' ' then Typ := 'i';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Writeln(Class, Sign, Typ, ' function ', n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoData(n: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Typ = ' ' then Expected('Type declaration');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Writeln(Class, Sign, Typ, ' data ', n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Class, Sign, Typ, ' data ', n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(';');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как мы еще далеки от получения выполнимого кода, я решил чтобы эти две подпрограммы только сообщали нам, что они нашли.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Протестируйте эту программу. Для объявления данных дайте список, разделенный запятыми. Мы не можем пока еще обрабатывать инициализаторы. Мы также не можем обрабатывать списки параметров функций но символы «()\{\}» должны быть.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы все еще очень далеко от того, чтобы иметь компилятор C, но то что у нас есть обрабатывает правильные виды входных данных и распознает и хорошие и плохие входных данные. В процессе этого естественная структура компилятора начинает принимать форму.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можем ли мы продолжать пока не получим что-то, что действует более похоже на компилятор. Конечно мы можем. Должны ли мы? Это другой вопрос. Я не знаю как вы, но у меня начинает кружиться голова, а мы все еще далеки от того, чтобы даже получить что-то кроме объявления данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту, я думаю, вы можете видеть как структура компилятора развивается из определения языка. Структуры, которые мы увидели для наших двух примеров, Pascal и C, отличаются как день и ночь. Pascal был разработан, по крайней мере частично, чтобы быть легким для синтаксического анализа и это отразилось в компиляторе. Вообще, Pascal более структурирован и мы имеем более конкретные идеи какие виды конструкций ожидать в любой точке. В C наооборот, программа по существу является списком объявлений завершаемых только концом файла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы могли бы развивать обе эти структуры намного дальше, но помните, что наша цель здесь не в том, чтобы построить компилятор C или Pascal, а скорее изучать компиляторы вообще. Для тех из вас, кто хотят иметь дело с Pascal или C, я надеюсь, что дал вам достаточно начал чтобы вы могли взять их отсюда (хотя вам скоро понадобятся некоторые вещи, которые мы еще не охватили здесь, такие как типы и вызовы процедур). Остальные будьте со мной в следующей главе. Там я проведу вас через разработку законченного компилятора для TINY, подмножества KISS.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Представление «TINY»\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последней главе я показал вам основную идею нисходящей разработки компилятора. Я показал вам первые несколько шагов этого процесса для компиляторов Pascal и C, но я остановился далеко от его завершения. Причина была проста: если мы собираемся построить настоящий, функциональный компилятор для какого-нибудь языка, я предпочел бы сделать это для KISS, языка, который я определил в этой обучающей серии.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы собираемся сделать это же для подмножества KISS, которое я решил назвать TINY.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот процесс по существу будет аналогичен выделенному в главе 9, за исключением одного заметного различия. В той главе я предложил вам начать с полного БНФ описания языка. Это было бы прекрасно для какого-нибудь языка типа Pascal или C, определения которого устоялись. В случае же с TINY, однако, мы еще не имеем полного описания... мы будем определять язык по ходу дела. Это нормально. Фактически, это предпочительней, так как мы можем немного подстраивать язык по ходу дела для сохранения простоты анализа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что в последующей разработке мы фактически будем выполнять нисходящую разработку и языка и его компилятора. БНФ описание будет расти вместе с компилятором.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ходе этого будет принят ряд решений, каждое из которых будет влиять на БНФ и, следовательно, характер языка. В каждой решающей точке я попытаюсь не забывать объяснять решение и разумное обоснование своего выбора. Если вам случится придерживаться другого мнения и вы предпочтете другой вариант, вы можете пойти своим путем. Сейчас вы имеет базу для этого. Я полагаю важно отметить, что ничего из того, что мы здесь делаем не подчинено каким-либо жесткими правилами. Когда вы разрабатываете свой язык вы не должны стесняться делать это своим способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многие из вас могут сейчас спросить: зачем нужно начинать с самого начала? У нас есть работающее подмножество KISS как результат главы 7 (лексический анализ). Почему бы просто не раширить его как нужно? Ответ тройной. Прежде всего, я сделал несколько изменений для упрощения программы... типа изоляции процедур генерации кода, в результате чего мы можем более легко выполнять преобразование для различных машин. Во-вторых, я хочу, чтобы вы увидели что разработка действительно может быть выполнена сверху вниз как это подчеркнуто в последней главе. Наконец, нам всем нужна практика. Каждый раз, когда я прохожу через эти упражнения, я начинаю понимать немного больше, и вы будете тоже.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Подготовка\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Много лет назад существовали языки, называемые Tiny BASIC, Tiny Pascal и Tiny C, каждый из которых был подмножеством своего полного родительского языка. Tiny BASIC, к примеру, имел только односимвольные имена переменных и глобальные переменные. Он поддерживал только один тип данных. Звучит знакомо? К этому моменту мы имеем почти все инструменты, необходимые для создания компилятора подобного этому.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако язык, называемый Tiny-такой-то все же несет некоторый багаж, унаследованный от своего родительского языка. Я часто задавался вопросом, хорошая ли это идея. Согласен, язык, основанный на каком-то родительском языке, будет иметь преимущество знакомости, но может также существовать некоторый особенный синтаксис, перенесенный из родительского языка, который может приводить к появлению ненужной сложности в компиляторе. (Нигде это не является большей истиной, чем в Small C).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я задавался вопросом, насколько маленьким и простым может быть создан компилятор и при этом все еще быть полезным, если он разрабатывался из условия быть легким и для использования и для синтаксического анализа. Давайте выясним. Этот язык будет называться просто «TINY». Он является подмножеством KISS, который я также еще полностью не определил, что по крайней мере делает нас последовательными (!). Я полагаю вы могли бы назвать его TINY KISS. Но это открывает целую кучу проблем, так что давайте просто придерживаться имени TINY.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главные ограничения TINY будут возникать из-за тех вещей, которые мы еще не рассмотрели, таких как типы данных. Подобно своим кузенам Tiny C и Tiny BASIC, TINY будет иметь только один тип данных, 16-разрядное целое число. Первая версия, которую мы разработаем, не будет также иметь вызовов процедур и будет использовать односимвольные имена переменных, хотя, как вы увидите, мы можем удалить эти ограничения без особых усилий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык, который я придумал, разделит некоторые хорошие особенности Pascal, C и Ada. Получив урок из сравнения компиляторов Pascal и C в предыдущей главе, TINY все же будет иметь преимущественно вкус Паскаля. Везде, где возможно, структура языка будет ограничена ключевыми словами или символами, так что синтаксический анализатор будет знать, что происходит без догадок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другое основное правило: Я хотел бы чтобы в течение всей разработки компилятор производил настоящий выполнимый код. Даже если его не может быть слишком много в самом начале, но по крайней мере он должен быть корректным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, я буду использовать пару ограничений Pascal, которые имеют смысл: Все данные и процедуры должны быть объявлены перед тем, как они используются. Это имеет большой смысл, даже если сейчас единственным типом данных, который мы будем использовать, будет слово. Это правило, в свою очередь, означает, что единственное приемлемое место для размещения выполнимого кода основной программы – в конце листинга.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определение верхнего уровня будет аналогично Pascal:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <program> ::= PROGRAM <top-level decl> <main> '.'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже достигли решающей точки. Моей первой мыслью было сделать основной блок необязательным. Кажется бессмысленным писать «программу» без основной программы, но это имеет смысл, если мы разрешим множественные модули, связанные вместе. Фактически я предполагаю учесть это в KISS. Но тогда мы столкнемся с кучей проблем, которые я предпочел бы сейчас не затрагивать. Например, термин «PROGRAM» в действительности становится неправильно употребляемым. MODULE из Modula-2 или UNIT из Turbo Pascal были бы более подходящими. Во-вторых, как насчет правил видимости? Нам необходимо соглашение для работы с видимостью имен в модулях. На данный момент лучше просто сохранить простоту и совершенно игнорировать эту идею.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Также необходимо определиться с требованием, чтобы основная программа была последней. Я играл с идеей сделать ее размещение нефиксированным как в C. Характер SK*DOS, ОС под которую я компилирую, позволяет сделать это очень просто. Но это в действительности не имеет большого смысла принимая во внимание Pascal-подобное требование, что все данные и процедуры должны быть обьявлены прежде чем они используются. Так как основная программа может вызывать только те процедуры, которые уже были объявлены, единственное местоположение, имеющее смысл – в конце, a la Pascal.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По данной выше БНФ давайте напишем синтаксический анализатор, который просто распознает скобки:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура Header просто выдает инициализационный код, необходимый ассемблеру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Header Info \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('WARMST', TAB, 'EQU $A01E');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуры Prolog и Epilog выдают код для идентификации основной программы и для возвращения в ОС:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel('MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Epilog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DC WARMST');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основная программа просто вызывает Prog и затем выполняет проверку на чистое завершение:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> CR then Abort('Unexpected data after ''.''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас TINY примет только одну «программу» – пустую:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROGRAM . (или 'p.' в нашей стенографии).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, тем не менее, что компилятор генерирует для этой программы корректный код. Она будет выполняться и делать то, что можно ожидать от пустой программы, т.е. ничего кроме элегантного возвращения в ОС.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из моих любимых бенчмарков для компиляторов заключается в компиляции, связывании и выполнении пустой программы для любого языка. Вы можете многое узнать о реализации измеряя предел времени, необходимый для компиляции тривиальной программы. Также интересно измерить количество полученного кода. Во многих компиляторах код может быть довольно большим, потому что они всегда включают целую run-time библиотеку независимо от того, нуждаются они в ней или нет. Ранние версии Turbo Pascal в этом случае производили объектный файл 12К. VAX C генерирует 50К!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самые маленькие пустые программы какие я видел, получены компиляторами Модула-2 и они занимают примерно 200-800 байт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае TINY у нас еще нет run-time библиотеки, так что объектный код действительно крошечный (tiny): два байта. Это стало рекордом, и вероятно останется таковым, так как это минимальный размер, требуемый ОС.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующим шагом будет обработка кода для основной программы. Я буду использовать блок BEGIN из Pascal:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <main> ::= BEGIN <block> END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь мы снова приняли решение. Мы могли бы потребовать использовать объявление вида «PROCEDURE MAIN», подобно C. Я должен допустить, что это совсем неплохая идея... Мне не особенно нравится подход Паскаля так как я предпочитаю не иметь проблем с определением местоположения основной программы в листинге Паскаля. Но альтернатива тоже немного неудобна, так как вы должны работать с проверкой ошибок когда пользователь опустит основную программу или сделает орфографическую ошибку в ее названии. Здесь я использую простой выход.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другое решение проблемы «где расположена основная программа» может заключаться в требовании имени для программы и заключения основной программы в скобки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN <name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END <name>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 аналогично соглашению Модула-2. Это добавляет в язык немного «синтаксического сахара». Подобные вещи легко добавлять и изменять по вашим симпатиям если вы сами проектируете язык.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для синтаксического анализа такого определения основного блока измените процедуру Prog следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и добавьте новую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь единственной допустимой программой является программа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROGRAM BEGIN END. (или 'pbe.')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разве мы не делаем успехи??? Хорошо, как обычно это становится лучше. Вы могли бы попробовать сделать здесь некоторые преднамеренные ошибки подобные пропуску 'b' или 'e' и посмотреть что случится. Как всегда компилятор должен отметить все недопустимые входные символы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объявления\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно на следующем шаге необходимо решить, что мы подразумеваем под объявлением. Я намереваюсь иметь два вида объявлений: переменных и процедур/функций. На верхнем уровне разрешены только глобальные объявления, точно как в C.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас здесь могут быть только объявления переменных, идентифицируемые по ключевому слову VAR (сокращенно "v").\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <top-level decls> ::= ( <data declaration> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <data declaration> ::= VAR <var-list>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что так как имеется только один тип переменных, нет необходимости объявлять этот тип. Позднее, для полной версии KISS, мы сможем легко добавить описание типа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура Prog становится:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь добавьте две новые процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> 'b' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ''' + Look + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что на данный момент Decl – просто заглушка. Она не генерирует никакого кода и не обрабатывает список... каждая переменная должна быть в отдельном утверждении VAR.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, теперь у нас может быть любое число объявлений данных, каждое начинается с "v" вместо VAR, перед блоком BEGIN. Попробуйте несколько вариантов и посмотрите, что происходит.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объявления и идентификаторы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это выглядит довольно хорошо, но мы все еще генерируем только пустую программу. Настоящий ассемблер должен выдавать директивы ассемблера для распределения памяти под переменные. Пришло время действительно получить какой-нибудь код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С небольшим дополнительным кодом это легко сделать в процедуре Decl. Измените ее следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура Alloc просто выдает команду ассемблеру для распределения памяти:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(N, ':', TAB, 'DC 0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Погоняйте программу. Попробуйте входную последовательность, которая объявляет какие-нибудь переменные, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pvxvyvzbe.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Видите, как распределяется память? Просто, да? Заметьте также, что точка входа «MAIN» появляется в правильном месте.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кстати, «настоящий» компилятор имел бы также таблицу идентификаторов для записи используемых переменных. Обычно, таблица идентификаторов необходима для записи типа каждой переменной. Но так как в нашем случае все переменные имеют один и тот же тип, нам не нужна таблица идентификаторов. Оказывается, мы смогли бы находить идентификатор даже без различия типов, но давайте отложим это пока не возникнет такая необходимость.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, в действительности мы не анализировали правильный синтаксис для объявления данных, так как он включает список переменных. Наша версия разрешает только одну переменную. Это также легко исправить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БНФ для <var-list> следующая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <var-list> ::= <ident> (, <ident>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавление этого синтаксиса в Decl дает новую версию:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, теперь откомпилируйте этот код и испытайте его. Попробуйте ряд строк с объявлениями VAR, попробуйте список из нескольких переменных в одной строке и комбинации этих двух. Работает?\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Инициализаторы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока мы работали с объявлениями данных, меня беспокоила одна вещь – то, что Pascal не позволяет инициализировать данные в объявлении. Эта возможность по общему признанию является своего рода излишеством, и ее может не быть в языке, который считается минимальным языком. Но ее также настолько просто добавить, что было бы позором не сделать этого. БНФ становится:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <var-list> ::= <var> ( <var> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <var> ::= <ident> [ = <integer> ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Измените Alloc как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(N, ':', TAB, 'DC ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот оно: инициализатор в шесть дополнительных строк Pascal.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте эту версию TINY и проверьте, что вы действительно можете задавать начальное значение перменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ей богу, он начинает походить на настоящий компилятор! Конечно, он все еще ничего не делает, но выглядит хорошо, не так ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед тем как оставить этот раздел я должен подчеркнуть, что мы использовали две версии GetNum. Одна, более ранняя, возвращала символьное значение, одиночную цифру. Другая принимала многозначное целое число и возвращала целочисленное значение. Любая из них будет работать здесь, так как WriteLn поддерживает оба типа. Но нет никакой причины ограничивать себя одноразрядными значениями, так что правильной версией для использования будет та, которая возвращает целое число. Вот она:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Val: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 10 * Val + Ord(Look) – Ord('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Val;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Строго говоря, мы должны разрешить выражения в поле данных инициализатора, или, по крайней мере, отрицательные значения. Сейчас давайте просто разрешим отрицательные значения изменив код для Alloc следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Variable Name ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'v';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(N, ':', TAB, 'DC ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 If Look = '-' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь у вас есть возможность инициализировать переменные отрицательными и/или многозначными значениями.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Таблица идентификаторов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует одна проблема с компилятором в его текущем состоянии: он ничего не делает для сохранения переменной когда мы ее объявляем. Так что компилятор совершенно спокойно распределит память для нескольких переменных с тем же самым именем. Вы можете легко убедиться в этом набрав строку типа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pvavavabe.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь мы объявили переменную A три раза. Как вы можете видеть, компилятор бодро принимает это и генерирует три идентичных метки. Не хорошо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Позднее, когда мы начнем ссылаться на переменные, компилятор также будет позволять нам ссылаться на переменные, которые не существуют. Ассемблер отловит обе эти ошибки, но это совсем не кажется дружественным поведением – передавать такую ошибку ассемблеру. Компилятор должен отлавливать такие вещи на уровне исходного языка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что даже притом, что нам не нужна таблица идентификаторов для записи типов данных, мы должны установить ее только для того, чтобы проверять эти два условия. Так как пока мы все еще ограничены односимвольными именами переменных таблица идентификаторов может быть тривиальной. Чтобы предусмотреть ее сначала добавьте следующее объявление в начало вашей программы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var ST: array['A'..'Z'] of char;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и вставьте следующую функцию:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Look for Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(n: char): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := ST[n] <> ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам также необходимо инициализировать таблицу пробелами. Следующие строки в Init сделают эту работу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var i: char;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for i := 'A' to 'Z' do\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ST[i] := ' ';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, вставьте следующие две строки в начало Alloc:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if InTable(N) then Abort('Duplicate Variable Name ' + N);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ST[N] := 'v';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это должно все решить. Теперь компилятор будет отлавливать двойные объявления. Позднее мы также сможем использовать InTable при генерации ссылок на переменные.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Выполнимые утверждения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому времени мы можем генерировать пустую программу, которая имеет несколько объявленных переменных и возможно инициализированных. Но пока мы не генерировали ни строки выполнимого кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Верите ли вы или нет, но мы почти имеем пригодный для использования компилятор! Отсутствует только выполнимый код, который должен входить в основную программу. Но этот код – это только операции присваивания и операторы управления... все вещи, которые мы сделали раньше. Так что у нас не должно занять слишком много времени предусмотреть также и их.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БНФ определение, данное раньше для основной программы, включало операторный блок, который мы пока что игнорировали:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <main> ::= BEGIN <block> END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас мы можем рассматривать блок просто как серию операций присваивания:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= (Assignment)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с добавления синтаксического анализатора для блока. Мы начнем с процедуры-заглушки для операции присваивания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> 'e' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Измените процедуру Main чтобы она вызывала Block как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта версия все еще не генерирует никакого кода для «операций присваивания»... все что она делает это съедает символы до тех пор, пока не увидит "e", означающее «END». Но она устанавливает основу для того, что следует дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий шаг, конечно, – это расширение кода для операций присваивания. Это то, что мы делали много раз до этого, поэтому я не буду задерживаться на этом. На этот раз, однако, я хотел бы работать с генерацией кода немного по-другому. До настоящего времени мы всегда просто вставляли Emits, которые генерируют выходной код в соответствии с подпрограммами синтасического анализа. Немного неструктурно, возможно, но это кажется самым простым способом и помогает видеть, какой код должен быть выдан для каждой конструкции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, я понимаю, что большинство из вас используют компьютер 80x86, так что от кода, сгенерированного для 68000 вам мало пользы. Некоторые из вас спрашивали меня, что если бы машинозависимый код мог бы быть собран в одном месте, то было бы проще перенастроить его на другой ЦПУ. Ответ конечно да.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы сделать это вставьте следующие подпрограммы «генерации кода»:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Clear the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Clear;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Negate the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Constant Value to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConst(n: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE #');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(n, ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push Primary onto Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add Top of Stack to Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Subtract Primary from Top of Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D0,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store Primary to Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Store(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приятная особенность такого подхода, конечно, в том что мы можем перенастроить компилятор на новый ЦПУ просто переписав эти процедуры «генератора кода». Кроме того, позднее мы обнаружим что можем улучшить качество кода немного подправляя эти процедуры без необходимости изменения компилятора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что и LoadVar и Store проверяют таблицу идентификаторов чтобы удостовериться, что переменная определена. Обработчик ошибки Undefined просто вызывает Abort:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Undefined Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Undefined(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Undefined Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, теперь мы наконец готовы начать обработку выполнимого кода. Мы сделаем это заменив пустую версию процедуры Assignment.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы проходили этот путь много раз прежде, так что все это должно быть вам знакомо. Фактически, если бы не изменения, связанные с генерацией кода, мы могли бы просто скопировать процедуры из седьмой части. Так как мы сделали некоторые изменения я не буду их просто копировать, но мы пройдем немного быстрее, чем обычно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БНФ для операций присваивания:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <assignment> ::= <ident> = <expression>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <first term> ( <addop> <term> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <first term> ::= <first factor> <rest>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <factor> <rest>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <rest> ::= ( <mulop> <factor> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <first factor> ::= [ <addop> ] <factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <var> | <number> | ( <expression> )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта БНФ также немного отличается от той, что мы использовали раньше... еще одна «вариация на тему выражений». Эта специфичная версия имеет то, что я считаю лучшей обработкой унарного минуса. Как вы увидите позднее, это позволит нам очень эффективно обрабатывать отрицательные константы. Здесь стоит упомянуть, что мы часто видели преимущества «подстраивания» БНФ по ходу дела, с цель сделать язык легким для анализа. То, что вы видете здесь, немного другое: мы подстраиваем БНФ для того, чтобы сделать генерацию кода более эффективной! Это происходит впервые в этой серии.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во всяком случае, следующий код реализует эту БНФ:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(GetName)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Negative Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NegFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(-GetNum)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Leading Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': NegFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Common Code Used by Term and FirstTerm \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Leading Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, если вы вставили весь этот код, тогда откомпилируйте и проверьте его. Вы должны увидеть приемлемо выглядящий код, представляющий собой законченную программу, которая будет ассемблироваться и выполняться. У нас есть компилятор!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Булева логика\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий шаг также должен быть вам знаком. Мы должны добавить булевы выражения и операторы отношений. Снова, так как мы работали с ними не один раз, я не буду подробно разбирать их за исключением моментов, в которых они отличаются от того, что мы делали прежде. Снова, мы не будем просто копировать их из других файлов потому что я немного изменил некоторые вещи. Большинство изменений просто включают изоляцию машинозависимых частей как мы делали для арифметических операций. Я также несколько изменил процедуру NotFactor для соответствия структуре FirstFactor. Наконец я исправил ошибку в объектном коде для операторов отношений: в инструкции Scc я использовал только младшие 8 бит D0. Нам нужно установить логическую истину для всех 16 битов поэтому я добавил инструкцию для изменения младшего байта.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала нам понадобятся несколько подпрограмм распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Также нам понадобятся несколько подпрограмм генерации кода:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Complement the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NOT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ AND Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ OR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('OR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ XOR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Compare Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was = \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SEQ D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was != \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SNE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was > \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was < \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это дает нам необходимые инструменты. БНФ для булевых выражений такая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <bool-expr> ::= <bool-term> ( <orop> <bool-term> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <bool-term> ::= <not-factor> ( <andop> <not-factor> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <not-factor> ::= [ '!' ] <relation>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <relation> ::= <expression> [ <relop> <expression> ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зоркие читатели могли бы заметить, что этот синтаксис не включает нетерминал «bool-factor» используемый в ранних версиях. Тогда он был необходим потому, что я также разрешал булевы константы TRUE и FALSE. Но не забудьте, что в TINY нет никакого различия между булевыми и арифметическими типами... они могут свободно смешиваться. Так что нет нужды в этих предопределенных значениях... мы можем просто использовать -1 и 0 соответственно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В терминологии C мы могли бы всегда использовать определения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 #define TRUE -1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 #define FALSE 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Так было бы, если бы TINY имел препроцессор.) Позднее, когда мы разрешим объявление констант, эти два значения будут предопределены языком.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Причина того, что я заостряю на этом ваше внимание, в том что я пытался использовать альтернативный путь, который заключался в использовании TRUE и FALSE как ключевых слов. Проблема с этим подходом в том, что он требует лексического анализа каждого имени переменной в каждом выражении. Как вы помните, я указал в главе 7, что это значительно замедляет компилятор. Пока ключевые слова не могут быть в выражениях нам нужно выполнять сканирование только в начале каждого нового оператора... значительное улучшение. Так что использование вышеуказанного синтаксиса не только упрощает синтаксический анализ, но также ускоряет сканирование.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, если мы удовлетворены синтаксисом, представленным выше, то соответствующий код показан ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Equals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Not Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotEquals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('#');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('<');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Greater Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Relation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsRelop(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': Equals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '#': NotEquals;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '<': Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Factor with Leading NOT \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '!' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = '&' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('&');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Boolean OR \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('|');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Exclusive Or \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('~');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOrOp(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы связать все это вместе не забудьте изменить обращение к Expression в процедурах Factor и Assignment на вызов BoolExpression.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, если вы набрали все это, откомпилируйте и погоняйте эту версию. Сначала удостоверьтесь, что вы все еще можете анализировать обычные арифметические выражения. Затем попробуйте булевские. Наконец удостоверьтесь, что вы можете присваивать результат сравнения. Попробуйте к примеру:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 pvx,y,zbx=z>ye.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что означает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROGRAM\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 VAR X,Y,Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = Z > Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Видите как происходит присваивание булевского значения X?\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Управляющие структуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы почти дома. Имея булевы выражения легко добавить управляющие структуры. Для TINY мы разрешим только две из них, IF и WHILE:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <if> ::= IF <bool-expression> <block> [ ELSE <block>] ENDIF\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <while> ::= WHILE <bool-expression> <block> ENDWHILE\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще раз позвольте мне разъяснить решения, подразумевающиеся в этом синтаксисе, который сильно отличается от синтаксиса C или Pascal. В обоих этих языках «тело» IF или WHILE расценивается как одиночный оператор. Если вы предполагаете использовать блок из более чем одного оператора вы должны создать составной утверждение использую BEGIN-END (в Pascal) или '\{\}' (в C). В TINY (и KISS) нет таких вещей как составное утверждение... одиночное или множественное, они являются в этом языке просто блоками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В KISS все управляющие структуры имеют явные и уникальные ключевые слова, выделяющие операторный блок поэтому не может быть никакой путаницы где он начинается и заканчивается. Это современный подход, используемый в таких уважаемых языках, как Ada и Modula-2 и он полностью устраняет проблему «висячих else».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что я мог бы использовать то же самое ключевое слово END для завершения всех конструкций, как это сделано в Pascal. (Закрывающая '\}' в C служит той же самой цели.) Но это всегда вело к неразберихе, вот почему программисты на Pascal предпочитают писать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end \{ loop \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или end \{ if \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как я объяснил в пятой части, использование уникальных терминальных ключевых слов увеличивает размер списка ключевых слов и, следовательно, замедляет лексический анализ, но в данном случае это кажется небольшой ценой за дополнительную подстраховку. Лучше обнаруживать ошибки во время компиляции, чем во время выполнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна последняя мысль: каждая из двух конструкций выше имеют нетерминалы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <bool-expression> и <block>,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расположенные рядом без разделяющих ключевых слов. В Паскале мы ожидали бы в этом месте ключевые слова THEN и DO.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не вижу проблем в том, чтобы опустить эти ключевые слова, и синтаксический анализатор также не будет иметь проблем, при условии, что мы не сделаем ошибок в bool-expression. С другой стороны, если мы включим эти дополнительные ключевые слова мы получили бы еще один уровень подстраховки за малые деньги, и с этим у меня также нет проблем. Примите правильное решение каким путем пойти.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, после этого небольшого объяснения давайте продолжим. Как обычно нам понадобятся несколько новых подпрограмм генерации кода. Они генерируют код для условных и безусловных переходов:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch Unconditional \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Branch(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch False \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BranchFalse(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('TST D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исключая изоляцию подпрограмм генератора кода, код для анализа управляющих конструкций такой же, как вы видели прежде:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('i');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('l');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('w');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы связать все это вместе нам нужно только изменить процедуру Block чтобы распознавать ключевые слова IF и WHILE. Как обычно мы расширим определение блока так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= ( <statement> )*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <statement> ::= <if> | <while> | <assignment>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующий код:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавьте подпрограммы, которые я дал, откомпилируйте и протестируйте их. У вас должна быть возможность анализировать односимвольные версии любых управляющих конструкции. Выглядит довольно хорошо!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фактически, за исключением односимвольного ограничения, мы получили практически полную версию TINY. Я назову его TINY Version 0.1.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Лексический анализ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, вы знаете, что будет дальше: Мы должны преобразовать программу так, чтобы она могла работать с многосимвольными ключевыми словами, переводами строк и пробелами. Мы только что прошли все это в седьмой главе. Мы будем использовать метод распределенного сканера, который я показал вам в этой главе. Фактическая реализация немного отличается, потому что различается способ, которым я обрабатываю переводы строк.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала, давайте просто разрешим пробелы. Для этого необходимо только добавить вызовы SkipWhite в конец трех подпрограмм GetName, GetNum и Match. Вызов SkipWhite в Init запускает помпу в случае если есть ведущие пробелы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем мы должны обрабатывать переводы строк. Это в действительности двухшаговый процесс так как обработка переносов с односимвольными токенами отличается от таковой для многосимвольных токенов. Мы можем устранить часть работы сделав оба шага одновременно, но я чувствую себя спокойней, работая последовательно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вставьте новую процедуру:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over an End-of-Line \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что мы видели эту процедуру раньше в виде процедуры Fin. Я изменил имя, так как новое кажется более соответствующим фактическому назначению. Я также изменил код чтобы учесть множественные переносы и строки только с пробелами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующим шагом будет вставка вызовов NewLine везде, где мы посчитаем перенос допустимым. Как я подчеркивал ранее, этот момент может очень различаться для разных языков. В TINY я решил разрешить их практически в любом месте. Это означает, что нам нужно вызывать NewLine в начале (не в конце как с SkipWhite) процедур GetName, GetNum и Match.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для процедур, которые имеют циклы While, таких как TopDecl, нам нужен вызов NewLine в начале процедуры и в конце каждого цикла. Таким способом мы можем быть уверены, что NewLine вызывается в начале каждого прохода через цикл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы все это сделали, испытайте программу и проверьте, что она действительно обрабатывает пробелы и переносы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если это так, тогда мы готовы работать с многосимвольными токенами и ключевыми словами. Для начала, добавьте дополнительные объявления (скопированные почти дословно из главы 7):\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token: char; \{ Encoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value: string[16]; \{ Unencoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST: Array['A'..'Z'] of char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const NKW = 9;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NKW1 = 10;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array[1..NKW] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'WHILE', 'ENDWHILE',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'VAR', 'BEGIN', 'END', 'PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWcode: string[NKW1] = 'xilewevbep';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем добавьте три процедуры, также из седьмой главы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Table Lookup \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Lookup(T: TabPtr; s: string; n: integer): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found: Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := false;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 i := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while (i > 0) and not found do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s = T^[i] then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := true\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 dec(i);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lookup := i;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier and Scan it for Keywords \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, NKW) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input String \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure MatchString(x: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Value <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы должны сделать довольно много тонких изменений в оставшихся процедурах. Сначала мы должны изменить функцию GetName на процедуру, снова как в главе 7:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что эта процедура оставляет свой результат в глобальной строковой переменной Value.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, мы должны изменить каждую обращение к GetName чтобы отразить ее новую форму. Они происходят в Factor, Assignment и Decl:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Value[1]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := Value[1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(Value[1]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(Value[1]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что мы все еще разрешаем только односимвольные имена переменных поэтому мы используем здесь простое решение и просто используем первый символ строки.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, мы должны внести изменения, позволяющие использовать Token вместо Look как символа для проверки и вызывать Scan в подходящих местах. По большей части это включает удаление вызовов Match, редкие замены вызовов Match на вызовы MatchString, и замену вызовов NewLine на вызовы Scan. Вот затронутые подпрограммы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDIF');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDWHILE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token <> 'b' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('BEGIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это должно работать. Если все изменения сделаны правильно, вы должны теперь анализировать программы, которые выглядят как программы. (Если вы не сделали всех изменений, не отчаивайтесь. Полный листинг конечной формы дан ниже.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работает? Если да, то мы почти дома. Фактически, с несколькими небольшими исключениями, мы уже получили компилятор, пригодный для использования. Имеются еще несколько областей, требующих усовершенствования.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Многосимвольные имена переменных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из них – ограничение, требующее использования односимвольных имен переменных. Теперь, когда мы можем обрабатывать многосимвольные ключевые слова, это ограничение начинает казаться произвольным и ненужным. И действительно это так. В основном, единственное его достоинство в том, что он позволяет получить тривиально простую реализацию таблицы идентификаторов. Но это просто удобство для создателей компиляторов и оно должно быть уничтожено.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже делали этот шаг прежде. На этот раз, как обычно, я сделаю это немного по-другому. Я думаю подход, примененный здесь, сохранит простоту настолько, насколько это возможно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Естественным путем реализации таблицы идентификаторов на Pascal является объявление переменной типа запись и создание таблицы идентификаторов как массива таких записей. Здесь, однако, нам в действительности пока не нужно поле типа (существует пока что только один разрешенный тип), так что нам нужен только массив символов. Это имеет свое преимущество, потому что мы можем использовать существующую процедуру Lookup для поиска в таблице идентификаторов также как и в списке ключевых слов. Оказывается, даже когда нам нужны больше полей, мы все равно можем использовать тот же самый подход, просто сохраняя другие поля в отдельных массивах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот изменения, которые необходимо сделать. Сперва добавьте новую типизированную константу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 NEntry: integer = 0;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем измените определение таблицы идентификаторов как показано ниже:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 const MaxEntry = 100;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var ST : array[1..MaxEntry] of Symbol;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что ST не объявлен как SymTab. Это объявление липовое, чтобы заставить Lookup работать. SymTab заняля бы слишком много памяти и поэтому фактически никогда не обьявляется).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем мы должны заменить InTable.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Look for Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(n: Symbol): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := Lookup(@ST, n, MaxEntry) <> 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам также необходима новая процедура AddEntry, которая добавляет новый элемент в таблицу:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add a New Entry to Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddEntry(N: Symbol; T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Identifier ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if NEntry = MaxEntry then Abort('Symbol Table Full');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(NEntry);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[NEntry] := N;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType[NEntry] := T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура вызывается из Alloc:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: Symbol);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Variable Name ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddEntry(N, 'v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, мы должны изменить все подпрограммы, которые в настоящее время обрабатывают имена переменных как одиночный символ. Они включают LoadVar и Store (просто измените тип с char на string) и Factor, Assignment и Decl (просто измените Value[1] на Value).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последняя вещь: измените процедуру Init для очистки массива как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 1 to MaxEntry do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType[i] := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это должно работать. Испытайте ее и проверьте, что вы действительно можете использовать многосимвольные имена переменных.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Снова операторы отношений\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У нас осталось последнее односимвольное ограничение – ограничение операторов отношений. Некоторые из операторов отношений действительно состоят из одиночных символов, но другие требуют двух. Это '<=' и '>='. Я также предпочитаю Паскалевское '<>' для «не равно» вместо '#'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы помните, в главе 7 я указал, что стандартный способ работы с операторами отношений – включить их в список ключевых слов и позволить лексическому анализатору отыскивать их. Но, опять, это требует выполнение полного анализа выражения, тогда как до этого мы у нас была возможность ограничить использование сканера началом утверждения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я упомянул тогда, что мы все же можем избежать неприятностей с этим, так как многосимвольных операторов отношений немного и они ограничены в применении. Было бы легко обрабатывать их просто как специальные случаи и поддерживать их специальным способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Требуемые изменения влияют только на подпрограммы генерации кода и процедуры Relation и ее друзей. Сперва, нам понадобятся еще две подпрограммы генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was <= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was >= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем измените подпрограммы анализа отношений как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than or Equal» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Not Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('<');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Greater Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это все, что требуется. Теперь вы можете обрабатывать все операторы отношений. Попробуйте.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Ввод/Вывод\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь у нас есть полный, работающий язык, за исключением одного небольшого смущающего факта: у нас нет никакого способа получить или вывести данные. Нам нужны подпрограммы ввода/вывода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Современное соглашение, установленное в C и продолженное в Ada и Modula-2, состоит в том, чтобы вывести I/O операторы из самого языка и просто включить их в библиотеку подпрограмм. Это было бы прекрасно, за исключением того, что мы пока не имеем никаких средств поддержки подпрограмм. В любом случае, с этим подходом вы столкнетесь с проблемой переменной длины списка параметров. В Паскале I/O операторы встроены в язык, поэтому это единственные операторы, для которых список параметров может иметь переменное число элементов. В C мы примиряемся с клуджами типа scanf и printf и должны передавать количество параметров в вызываемую процедуру. В Ada и Modula-2 мы должны использовать неудобный (и медленный!) способ отдельного вызова для каждого аргумента.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что я думаю, что предпочитаю Паскалевский подход встраивания подпрограмм ввода/вывода, даже если мы не нуждаемся в этом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно, для этого нам нужны еще несколько подпрограмм генерации кода. Они, оказывается, самые простые из всех, потому что все, что мы делаем это вызываем библиотечные процедуры для выполнения работы.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR READ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Variable from Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR WRITE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Идея состоит в том, что READ загружает значение из входного потока в D0, а WRITE выводит его оттуда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти две процедуры представляют собой нашу первую встречу с потребностью в библиотечных процедурах... компонентах Run Time Library (RTL). Конечно кто-то (а именно мы) должен написать эти подпрограммы, но они не являются непосредственно частью компилятора. Я даже не буду беспокоиться о том, чтобы показать здесь эти подпрограммы, так как они очевидно очень ОС-зависимы. Я просто скажу, что для SK*DOS они особенно просты... почти тривиальны. Одна из причин, по которым я не буду показывать их здесь в том, что вы можете добавлять новые виды возможностей, например приглашение в READ или возможность пользователю повторить ошибочный ввод.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это действительно отдельный от компилятора проект, так что теперь я буду подразумевать что библиотека, называемая TINYLIB.LIB, существует.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как нам теперь нужно загружать ее, мы должны добавить ее загрузку в процедуру Header:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Header Info \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('WARMST', TAB, 'EQU $A01E');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LIB TINYLIB');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она возьмет на себя эту часть работы. Теперь нам также необходимо распознавать команды ввода и вывода. Мы можем сделать это добавив еще два ключевых слова в наш список:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const NKW = 11;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NKW1 = 12;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array[1..NKW] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'WHILE', 'ENDWHILE',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'READ', 'WRITE', 'VAR', 'BEGIN', 'END',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWcode: string[NKW1] = 'xileweRWvbep';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что здесь я использую кода в верхнем регистре чтобы избежать конфликта с 'w' из WHILE.) Затем нам нужны процедуры для обработки оператора ввода/вывода и его списка параметров:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Read Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Write Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, мы должны расширить процедуру Block для поддержки новых типов операторов:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На этом все. Теперь у нас есть язык!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту мы полностью определили TINY. Он не слишком значителен... в действительности игрушечный комиплятор. TINY имеет только один тип данных и не имеет подпрограмм... но это законченный, пригодный для использования язык. Пока что вы не имеете возможности написать на нем другой компилятор или сделать что-нибудь еще очень серьезное, но вы могли бы писать программы для чтения входных данных, выполнения вычислений и вывода результатов. Не слишком плохо для игрушки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более важно, что мы имеем твердую основу для дальнейшего развития. Я знаю, что вы будете рады слышать это: в последний раз я начал с создания синтаксического анализатора заново... с этого момента я предполагаю просто добавлять возможности в TINY пока он не превратится в KISS. Ох, будет время, когда нам понадобится попробовать некоторые вещи с новыми копиями Cradle, но как только мы разузнаем как они делаются, они будут встроены в TINY.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какие это будут возможности? Хорошо, для начала нам понадобятся подпрограммы и функции. Затем нам нужна возможность обрабатывать различные типы, включая массивы, строки и другие структуры. Затем нам нужно работать с идеей указателей. Все это будет в следующих главах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В справочных целях полный листинг TINY версии 1.0 показан ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Tiny10;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount: integer = 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NEntry: integer = 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token: char; \{ Encoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value: string[16]; \{ Unencoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const MaxEntry = 100;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var ST : array[1..MaxEntry] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType: array[1..MaxEntry] of char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const NKW = 11;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NKW1 = 12;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array[1..NKW] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'WHILE', 'ENDWHILE',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'READ', 'WRITE', 'VAR', 'BEGIN', 'END',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWcode: string[NKW1] = 'xileweRWvbep';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Undefined Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Undefined(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Undefined Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over an End-of-Line \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = CR do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Table Lookup \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Lookup(T: TabPtr; s: string; n: integer): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found: Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := false;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 i := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while (i > 0) and not found do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s = T^[i] then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := true\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 dec(i);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lookup := i;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Locate a Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Returns the index of the entry. Zero if not present. \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Locate(N: Symbol): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Locate := Lookup(@ST, n, MaxEntry);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Look for Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(n: Symbol): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := Lookup(@ST, n, MaxEntry) <> 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add a New Entry to Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddEntry(N: Symbol; T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Identifier ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if NEntry = MaxEntry then Abort('Symbol Table Full');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(NEntry);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[NEntry] := N;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType[NEntry] := T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlNum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Val: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLine;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 10 * Val + Ord(Look) – Ord('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Val;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier and Scan it for Keywords \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, NKW) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input String \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure MatchString(x: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Value <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Clear the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Clear;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Negate the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Complement the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NOT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Constant Value to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConst(n: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE #');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(n, ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push Primary onto Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add Top of Stack to Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Subtract Primary from Top of Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D0,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ AND Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ OR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('OR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ XOR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Compare Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was = \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SEQ D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was != \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SNE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was > \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was < \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was <= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was >= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store Primary to Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Store(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch Unconditional \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Branch(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch False \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BranchFalse(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('TST D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR READ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Value[1]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Variable from Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR WRITE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Header Info \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('WARMST', TAB, 'EQU $A01E');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel('MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Epilog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DC WARMST');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Negative Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NegFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(-GetNum)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Leading Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': NegFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Common Code Used by Term and FirstTerm \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Leading Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FirstTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Equal;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than or Equal» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Not Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('<');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Greater Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('>');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Relation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsRelop(Look) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': Equal;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '<': Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Factor with Leading NOT \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '!' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = '&' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('&');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Boolean OR \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('|');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Exclusive Or \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('~');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOrOp(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDIF');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDWHILE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Read Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Write Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: Symbol);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Variable Name ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddEntry(N, 'v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(N, ':', TAB, 'DC ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 If Look = '-' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token <> 'b' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('BEGIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 1 to MaxEntry do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType[i] := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> CR then Abort('Unexpected data after ''.''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Пересмотр лексического анализа\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У меня есть хорошие и плохие новости. Плохие новости – эта глава не та, которую я вам обещал последний раз. Более того, и следующая глава также.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошие новости в причине появления этой главы: я нашел способ упростить и улучшить лексический анализатор компилятора. Позвольте мне объяснить.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Предпосылка\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы помните, мы подробно говорили на тему лексических анализаторов в Главе 7 и я оставил вас с проектом распределенного сканера который, я чувствовал, был почти настолько простым, насколько я cмог сделать... более чем большинство из того, что я где-либо видел. Мы использовали эту идею в Главе 10. Полученная структура компилятора была простой и она делала свою работу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако недавно я начал испытывать проблемы такого рода, которые подсказывают, что возможно вы делаете что-то неправильно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблемы достигли критической стадии когда я попытался обратиться к вопросу точек с запятой. Некоторые люди спрашивали меня, действительно ли KISS будет использовать их для разделения операторов. Я не намеревался использовать точки с запятой просто потому, что они мне не нравятся и, как вы можете видеть, они не доказали своей необходимости.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но я знаю, что многие из вас, как и я, привыкли к ним, так что я намеревался написать короткую главу чтобы показать вам, как легко они могут быть добавлены раз вы так склонны к ним.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтож, оказалось что их совсем непросто добавить. Фактически это было чрезвычайно трудно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я полагаю, что должен был понять что что-то было неправильно из-за проблемы переносов строк. В последних двух главах мы обращались к этому вопросу и я показал вам, как работать с переносами с помощью процедуры, названной достаточно соответствующе NewLine. В TINY Version 1.0 я расставил вызовы этой процедуры в стратегических местах кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кажется, что всякий раз, когда я обращался к проблеме переносов, я, однако, находил этот вопрос сложным и полученный синтаксически анализатор оказывался очень ненадежным... одно удаление или добавление здесь или там и все разваливалось. Оглядываясь назад, я понимаю, что это было предупреждение, на которое я просто не обращал внимания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я попробовал добавить точку с запятой к переносам строк это стало последней каплей. Я получил слишком сложное решение. Я начал понимать, что необходимо что-то менять коренным образом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, в некотором отношении эта глава заставить нас возвратиться немного назад и пересмотреть заново вопрос лексического анализа. Сожалею об этом. Это цена, которую вы платите за возможность следить за мной в режиме реального времени. Но новая версия определенно усовершенствована и хорошо послужит нам дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как я сказал, сканер использованный нами в Главе 10, был почти настолько простым, насколько возможно. Но все может быть улучшено. Новый сканер более похож на классический сканер и не так прост как прежде. Но общая структура компилятора даже проще чем раньше. Она также более надежная и проще для добавления и/или модификации. Я думаю, что она стоит времени, потраченного на это отклонение. Так что в этой главе я покажу вам новую структуру. Без сомнения вы будете счастливы узнать, что хотя изменения влияют на многие процедуры, они не очень глубоки и поэтому мы теряем не очень многое из того что было сделано до этого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как ни странно, новый сканер намного более стандартен чем старый и он очень похож на более общий сканер, показанный мной ранее в главе 7. Вы должны помнить день, когда я сказал: K-I-S-S!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Проблема\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема начинает проявлять себя в процедуре Block, которую я воспроизвел ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, Block ориентирован на индивидуальные утверждения программы. При каждом проходе цикла мы знаем, что мы находимся в начале утверждения. Мы выходим из блока когда обнаруживаем END или ELSE.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но предположим, что вместо этого мы встретили точку с запятой. Вышеуказанная процедура не может ее обработать, так как процедура Scan ожидает и может принимать только токены, начинающиеся с буквы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я повозился с этим немного чтобы найти исправление. Я нашел множество возможных подходов, но ни один из них меня не удовлетворял. В конце концов я выяснил причину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вспомните, что когда мы начинали с наших односимвольных синтаксических анализаторов, мы приняли соглашение, по которому предсказывающий символ должен быть всегда предварительно считан. То есть, мы имели бы символ, соответствующий нашей текущей позиции во входном потоке, помещенный в глобальной символьной переменной Look, так что мы могли проверять его столько раз, сколько необходимо. По правилу, которое мы приняли, каждый распознаватель, если он находил предназначенный ему символ, перемещал бы Look на следующий символ во входном потоке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это простое и фиксированное соглашение служило нам очень хорошо когда мы имели односимвольные токены, и все еще служит. Был бы большой смысл применить то же самое правило и к многосимвольным токенам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но когда мы залезли в лексический анализ, я начал нарушать это простое правило. Сканер из Главы 10 действительно продвигался к следующему токену если он находил идентификатор или ключевое слово, но он не делал этого если находил возврат каретки, символ пробела или оператор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, такой смешанный режим работы ввергает нас в глубокую проблему в процедуре Block, потому что был или нет входной поток продвинут зависит от вида встреченного нами токена. Если это ключевое слово или левая часть операции присваивания, «курсор», как определено содержимым Look, был продвинут к следующему символу или к началу незаполненного пространства. Если, с другой стороны, токен является точкой с запятой, или если мы нажали возврат каретки курсор не был продвинут.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Само собой разумеется, мы можем добавить достаточно логики чтобы удержаться на правильном пути. Но это сложно и делает весь анализатор очень ненадежным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует гораздо лучший способ – просто принять то же самое правило, которое так хорошо работало раньше, и относиться к токенам так же как одиночным сиволам. Другими словами, мы будем заранее считывать токен подобно тому, как мы всегда считывали символ. Это кажется таким очевидным как только вы подумаете об этом способе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достаточно интересно, что если мы поступим таким образом, существующая проблема с символами перевода строки исчезнет. Мы можем просто рассмативать их как символы пробела, таким образом обработка переносов становится тривиальной и значительно менее склонной к ошибкам чем раньше.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Решение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем решение проблемы с пересмотра двух процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Not IsAlpha(Look) then Expected('Identifier');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := 'x';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until not IsAlNum(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Number');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '#';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until not IsDigit(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти две процедуры функционально почти идентичны тем, которые я показал вам в Главе 7. Каждая из них выбирает текущий токен, или идентификатор или число, в глобальную строковую переменную Value. Они также присваивают кодированной версии, Token, соответствующий код. Входной поток останавливается на Look, содержащем первый символ, не являющийся частью токена.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем сделать то же самое для операторов, даже многосимвольных, с помощью процедуры типа:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until IsAlpha(Look) or IsDigit(Look) or IsWhite(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что GetOps возвращает в качестве закодированного токена первый символ оператора. Это важно, потому что это означает, что теперь мы можем использовать этот одиночный символ для управления синтаксическим анализатором вместо предсказывающего символа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам нужно связать эти процедуры вместе в одну процедуру, которая может обрабатывать все три случая. Следующая процедура будет считывать любой из этих типов токенов и всегда оставлять входной поток за ним:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get the Next Input Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что здесь я поместил SkipWhite перед вызовами а не после. Это означает в основном, что переменная Look не будет содержать значимого значения и, следовательно, мы не должны использовать ее как тестируемое значение при синтаксическом анализе, как мы делали до этого. Это большое отклонение от нашего нормального подхода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, не забудьте, что раньше я избегал обработки символов возврата каретки (CR) и перевода строки (LF) как незаполненного пространства. Причина была в том, что так как SkipWhite вызывается последней в сканере, встреча с LF инициировала бы чтение из входного потока. Если бы мы были на последней строке программы, мы не могли бы выйти до тех пор, пока мы не введем другую строку с отличным от пробела символом. Именно поэтому мне требовалась вторая процедура NewLine для обработки CRLF.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но сейчас, когда первым происходит вызов SkipWhite, это то поведение, которое нам нужно. Компилятор должен знать, что появился другой токен или он не должен вызывать Next. Другими словами, он еще не обнаружил завершающий END. Поэтому мы будем настаивать на дополнительных данных до тех пор, пока не найдем что-либо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это означает, что мы можем значительно упростить и программу и концепции, обрабатывая CR и LF как незаполненное простанство и убрав NewLine. Вы можете сделать это просто изменив функцию IsWhite:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB, CR, LF];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже пробовали аналогичные подпрограммы в Главе 7, но вы могли бы также попробовать и эти. Добавьте их к копии Cradle и вызовите Next в основной программе:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Token, ' ', Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Token = '.';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Откомпилируйте и проверьте, что вы можете разделять программу на серии токенов и вы получаете правильные кода для каждого токена.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Почти работает, но не совсем. Существуют две потенциальные проблемы: Во-первых, в KISS/TINY почти все наши операторы – односимвольные. Единственное исключение составляют операторы отношений >=, <= и <>. Было бы позором обрабатывать все операторы как строки и выполнять сравнение строк когда почти всегда удовлетворит сравнение одиночных символов. Второе, и более важное, программа не работает, когда два оператора появляются вместе как в (a+b)*(c+d). Здесь строка после b была бы интерпретирована как один оператор ")*(".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно устранить эту проблему. К примеру мы могли бы просто дать GetOp список допустимых символов и обрабатывать скобки как отличный от других тип операторов. Но это хлопотное дело.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью, имеется лучший способ, который решает все эти проблемы. Так как почти все операторы односимвольные, давайте просто позволим GetOp получать только один символ одновременно. Это не только упрощает GetOp, но также немного ускоряет программу. У нас все еще остается проблема операторов отношений, но мы в любом случае обрабатывали их как специальные случаи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что вот финальная версия GetOp:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что я все еще присваиваю Value значение. Если вас действительно затрагивает эффективность, вы могли бы это опустить. Когда мы ожидаем оператор, мы в любом случае будем проверять только Token, так что значение этой строки не будет иметь значение. Но мне кажется хорошая практика дать ей значение на всякий случай.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте эту версию с каким-нибудь реалистично выглядящим кодом. Вы должны быть способны разделять любую программу на ее индивидуальные токены, но предупреждаю, что двухсимвольные операторы отношений будут отсканированы как два раздельных токена. Это нормально... мы будем выполнять их синтаксический анализ таким способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, в главе 7 функция Next была объединена с процедурой Scan, которая также сверяла каждый идентификатор со списком ключевых слов и кодировала каждый найденный. Как я упомянул тогда, последнее, что мы захотели бы сделать – использовать такую процедуру в местах, где ключевые слова не должны появляться, таких как выражения. Если бы мы сделали это, список ключевых слов просматривался бы для каждого идентификатора, появляющегося в коде. Нехорошо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правильней было бы в этом случае просто разделить функции выборки токенов и поиска ключевых слов. Версия Scan, показанная ниже, только проверяет ключевые слова. Обратите внимание, что она оперирует текущим токеном и не продвигает входной поток.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Scan the Current Identifier for Keywords \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'x' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, NKW) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последняя деталь. В компиляторе есть несколько мест, в которых мы должны фактически проверить строковое значение токена. В основном это сделано для того, чтобы различать разные END, но есть и пара других мест. (Я должен заметить, между прочим, что мы могли бы навсегда устранить потребность в сравнении символов END кодируя каждый из них различными символами. Прямо сейчас мы определенно идем маршрутом ленивого человека.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая версия MatchString замещает символьно-ориентированную Match. Заметьте, что как и Match она не продвигает входной поток.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input String \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure MatchString(x: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Value <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Исправление компилятора\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вооружившись этими новыми процедурами лексического анализа мы можем теперь начать исправлять компилятор. Изменения весьма незначительные, но есть довольно много мест, где они необходимы. Вместо того, чтобы показывать вам каждое место я дам вам общую идею а затем просто покажу готовый продукт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде всего, код процедуры Block не изменяется, но меняется ее назначение:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не забудьте, что новая версия Scan не продвигает входной поток, она только сканирует ключевые слова. Входной поток должен продвигаться каждой процедурой, которую вызывает Block.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В общих чертах, мы должны заменить каждую проверку Look на аналогичную проверку Token. Например:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOrOp(Token) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В процедурах типа Add мы больше не должны использовать Match. Нам необходимо только вызывать Next для продвижения входного потока:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Управляющие структуры фактически более простые. Мы просто вызываем Next для продвижения через ключевые слова управляющих конструкций:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDIF');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это все необходимые изменения. В листинге Tiny Version 1.1, данном ниже, я также сделал ряд других «усовершенствований», которые в действительности не нужны. Позвольте мне кратко разъяснить их:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1. Я удалил две процедуры Prog и Main и объединил их функции в основной программе. Они кажется не добавляли ясности... фактически они просто немного загрязняли программу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2. Я удалил ключевые слова PROGRAM и BEGIN из списка ключевых слов. Каждое из них появляется в одном месте, так что нет необходимости искать его.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3. Обжегшись однажды на чрезмерной дозе сообразительности, я напомнил себе, что TINY предназначен быть минималистским языком. Поэтому я заменил причудливую обработку унарного минуса на самую простую какую мог придумать. Гигантский шаг назад в качестве кода, но огромное упрощение компилятора. Для использования другой версии правильным местом был бы KISS.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 4. Я добавил несколько подпрограмм проверок ошибок типа CheckTable и CheckDup и заменил встроенный код на их вызовы. Это навело порядок во многих подпрограммах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 5. Я убрал проверку ошибок из подпрограмм генерации кода типа Store и поместил их в подпрограммы анализа, к которым они относятся. Смотрите например Assignment.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 6. Существовала ошибка в InTable и Locate которая заставляла их проверять все позиции вместо позиций только с достоверными данными. Теперь они проверяют только допустимые ячейки. Это позволяет нам устранить необходимость инициализации таблицы идентификаторов, которая была в Init.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 7. Процедура AddEntry теперь имеет два параметра, что помогает сделать программу немного более модульной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 8. Я подчистил код для операторов отношений добавив новые процедуры CompareExpression и NextExpression.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 9. Я устранил ошибку в подпрограмме Read... старая версия не выполняла проверку на правильность имени переменной.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полученный компилятор Tiny показан ниже. Не считая удаленного ключевого слова PROGRAM он анализирует тот же самый язык что и раньше. Он просто немного чище и, что более важно, значительно более надежный. Он мне нравится.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующей главе будет другое отклонение: сперва обсуждение точек с запятой и все, что привело меня такому беспорядку. Затем мы займемся процедурами и типами. Добавление этих возможностей далеко продвинет нас на пути к выведению KISS из категории «игрушечных языков». Мы подобрались очень близко к возможности написать серъезный компилятор.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 TINY VERSION 1.1 \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Tiny11;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LCount: integer = 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NEntry: integer = 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Type Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 type Symbol = string[8];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SymTab = array[1..1000] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TabPtr = ^SymTab;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look : char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token: char; \{ Encoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value: string[16]; \{ Unencoded Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const MaxEntry = 100;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var ST : array[1..MaxEntry] of Symbol;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType: array[1..MaxEntry] of char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Definition of Keywords and Token Types \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const NKW = 9;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NKW1 = 10;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWlist: array[1..NKW] of Symbol =\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ('IF', 'ELSE', 'ENDIF', 'WHILE', 'ENDWHILE',\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'READ', 'WRITE', 'VAR', 'END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const KWcode: string[NKW1] = 'xileweRWve';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Undefined Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Undefined(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Undefined Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report a Duplicate Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Duplicate(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Duplicate Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Check to Make Sure the Current Token is an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CheckIdent;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token <> 'x' then Expected('Identifier');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB, CR, LF];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Table Lookup \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Lookup(T: TabPtr; s: string; n: integer): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found: Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := false;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 i := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while (i > 0) and not found do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if s = T^[i] then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 found := true\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 dec(i);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Lookup := i;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Locate a Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Returns the index of the entry. Zero if not present. \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Locate(N: Symbol): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Locate := Lookup(@ST, n, NEntry);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Look for Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(n: Symbol): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := Lookup(@ST, n, NEntry) <> 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Check to See if an Identifier is in the Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an error if it's not. \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CheckTable(N: Symbol);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(N) then Undefined(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Check the Symbol Table for a Duplicate Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an error if identifier is already in table. \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CheckDup(N: Symbol);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add a New Entry to Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddEntry(N: Symbol; T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckDup(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if NEntry = MaxEntry then Abort('Symbol Table Full');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(NEntry);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[NEntry] := N;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SType[NEntry] := T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Not IsAlpha(Look) then Expected('Identifier');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := 'x';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until not IsAlNum(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetNum;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Number');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := '#';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Value + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until not IsDigit(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Value := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get the Next Input Token \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then GetName\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then GetNum\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else GetOp;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Scan the Current Identifier for Keywords \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'x' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Token := KWcode[Lookup(Addr(KWlist), Value, NKW) + 1];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input String \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure MatchString(x: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Value <> x then Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Unique Label \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function NewLabel: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var S: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(LCount, S);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NewLabel := 'L' + S;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(LCount);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Clear the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Clear;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Negate the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Complement the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NOT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Constant Value to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConst(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE #');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(n, ',D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push Primary onto Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add Top of Stack to Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Subtract Primary from Top of Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Top of Stack by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D0,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ AND Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ OR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('OR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ XOR Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Compare Top of Stack with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CMP (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was = \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SEQ D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was != \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SNE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was > \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was < \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was <= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SGE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Set D0 If Compare was >= \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SLE D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store Primary to Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Store(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch Unconditional \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Branch(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BRA ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Branch False \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BranchFalse(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('TST D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BEQ ' + L);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ReadIt(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR READ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write from Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure WriteIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR WRITE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write Header Info \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('WARMST', TAB, 'EQU $A01E');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel('MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Epilog \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DC WARMST');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('END MAIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Static Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Allocate(Name, Val: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Name, ':', TAB, 'DC ', Val);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'x' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Value)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if Token = '#' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(Value)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('Math Factor');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Token) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Token) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Clear\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Token) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get Another Expression and Compare \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CompareExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopCompare;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get The Next Expression and Compare \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NextExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CompareExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Equal;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NextExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than or Equal» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NextExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Not Equals» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NextExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetNEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Less Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': LessOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': NotEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CompareExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetLess;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Relational «Greater Than» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = '=' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NextExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreaterOrEqual;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CompareExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SetGreater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Relation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsRelop(Token) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '=': Equal;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '<': Less;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '>': Greater;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Factor with Leading NOT \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = '!' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Relation;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = '&' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAnd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Boolean OR \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Exclusive Or \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Boolean Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsOrOp(Token) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': BoolOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': BoolXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckTable(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := Value;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an IF Construct \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := L1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = 'l' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDIF');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a WHILE Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var L1, L2: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L1 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 L2 := NewLabel;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BoolExpression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BranchFalse(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('ENDWHILE');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Branch(L1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(L2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read a Single Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckIdent;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckTable(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadIt(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Read Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ReadVar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Write Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token <> 'x' then Expected('Variable Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckDup(Value);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddEntry(Value, 'v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Allocate(Value, '0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = 'v' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = ',' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('BEGIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Разное\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта глава – второе из тех отклонений в сторону, которые не вписываются в основное направление этой обучающей серии. Я упомянул в прошлый раз, что я накопил некоторые изменения, которые должны быть внесены в структуру компилятора. Поэтому я должен был отклониться чтобы разработать новую структуру и показать ее вам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда все это позади, я могу сказать что я намерен cделать прежде всего. Это не должно занять много времени и затем мы сможем вернуться в основное русло.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые люди спрашивали меня о вещах, которые предоставляют другие языки, но к которым я пока что не обращался в этой серии. Две самых больших из них – это точки с запятой и комментарии. Возможно вы тоже задумывались о них и гадали как изменился бы компилятор если бы мы работали с ними. Только для того, чтобы вы могли проследовать дальше без тревожащего чувства, что что-то пропущено, мы рассмотрим здесь эти вопросы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Точки с запятой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Со времен появления Алгола точки с запятой были частью почти каждого современного языка. Все мы использовали их считая это само собой разумеющимся. Однако я полагаю, что больше ошибок компиляции происходило из-за неправильно размещенной или отсутствующей точки с запятой, чем в любом другом случае. И если бы мы получали один пенни за каждое дополнительное нажатие клавиши, использованное программистами для набора этих маленьких мошенников, мы смогли бы оплатить национальный долг.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будучи воспитанным на Фортране, я потратил много времени чтобы привыкнуть к использованию точек с запятой и сказать по правде я никогда полностью не понимал почему они необходимы. Так как я программирую на Паскале и так как использование точек с запятой в Паскале особенно мудрено, этот один небольшой символ является моим наибольшим источником ошибок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я начал разработку KISS, я решил критически относиться к каждой конструкции в других языках и попытаться избежать наиболее общих проблем, происходящих с ними. Это ставит точку с запятой очень высоко в моем хит-листе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы понять роль точки с запятой, вы должны изучить краткую предисторию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ранние языки программирования были строчно-ориентированными. В Фортране, например, различные части утверждения занимали определенные столбцы и поля, в которых они должны были располагаться. Так как некоторые утверждения были слишком длинными для одной строки, существовал механизм «карта продолжения» («continuation card»), позволяющий компилятору знать, что данная карта все еще является частью предыдущей строки. Механизм дожил до наших дней, хотя перфокарты теперь – дела отдаленного прошлого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда появились другие языки, они также приняли различные механизмы для работы с многострочными операторами. Хороший пример – BASIC. Важно осознать, тем не менее, что механизм Фортрана был затребован не столько строчной ориентацией языка, сколько ориентацией по столбцам. В тех версиях Фортрана, где разрешен ввод в свободной форме, он больше не нужен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда отцы Алгола представили этот язык, они хотели уйти от строчно-ориентированных программ подобных Фортрану или Бейсику и разрешить ввод в свободной форме. Это дало возможность связывать множество утверждений в одну строку как например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=b; c=d; e=e+1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случаях подобных этому, точка с запятой почти обязательна. Та же самая строка без точек с запятой выглядит просто «странной»:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=b c= d e=e+1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я полагаю, что это главная... возможно единственная... причина точек с запятой: не давать программам выглядеть странно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но идея со связыванием множества утверждений вместе в одну строку в лучшем случае сомнительная. Это не очень хороший стиль программирования и возвращение назад к дням, когда считалось важным сэкономить карты. В наши дни CRT и выровненного кода ясность программ гораздо лучше обеспечивается сохранением раздельных утверждений. Все-таки хорошо иметь возможность множественных утверждений, но это позор – оставлять программистов в рабстве у точек с запятой только чтобы этот редкий случай не «выглядел странно».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я начинал KISS, я попытался держать глаза открытыми. Я решил, что буду использовать точки с запятой когда это станет необходимо для синтаксического анализатора, но только тогда. Я рассчитывал, что это случится примерно в то время, когда я добавил возможность разложения утверждений на несколько строк. Но как вы можете видеть это никогда не случилось. Компилятор TINY совершенно счастлив анализировать наиболее сложные утверждения, разложенные на любое число строк, без точек с запятой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, есть люди, которые использовали точки с запятой так долго, что они чувствуют себя без них голыми. Я один из них. Как только KISS стал достаточно хорошо определен, я попробовал написать на этом языке несколько программ-примеров. Я обнаружил, к своему ужасу, что пытаюсь в любом случае расставлять точки с запятой. Так что теперь я стою перед перспективой нового потока ошибок компилятора, вызванных нежелательными точками с запятой. Тьфу!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно более важно, что есть читатели, которые разрабатывают свои собственные языки, которые могут включать точки с запятой или которые хотят использовать методы из этого руководства для компиляции стандартных языков типа C. В обоих случаях, нам необходима возможность работать с точками с запятой.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Синтаксический сахар\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вся эта дисскуссия поднимает вопрос «синтаксического сахара»... конструкций, которые добавлены к языку не потому, что они нужны, но потому, что они заставляют программы выглядеть правильно для программиста. В конце концов, хорошо иметь маленький простой компилятор, но от него было бы мало пользы если бы полученный язык был закодированным или сложным для программирования. На ум приходит язык FORTH. Если мы можем добавить в язык возможности, которые делают программы более легкими для чтения и понимания, и если эти возможности предохраняют программиста от ошибок, тогда мы бы сделали это. Особенно если эти конструкции не добавляют слишком много сложности в язык или его компилятор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как пример можно было бы рассмотреть точку с запятой, но существуют множество других, такие как «THEN» в операторе IF, «DO» в операторе WHILE или даже утверждение «PROGRAM» которое я убрал из TINY. Ни один из этих токенов не добавляет много к синтаксису языка... компилятор может выяснить, что происходит и без них. Но некоторые люди чувствуют, что они улучшают читаемость программ и это может быть очень важно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют две школы мысли на эту тему, которые хорошо представлены двумя из наших наиболее популярных языков C и Pascal.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По мнению минималистов весь подобный сахар должен быть выброшен. Они доказывают, что это загромождает язык и увеличивает число нажатий клавиш, которое должен сделать программист. Возможно более важно, что каждый дополнительный токен или ключевое слово представляет собой ловушку, лежащую в ожидании невнимательного программиста. Если вы не учтете токен, пропустите его или сделаете в нем орфографическую ошибку, компилятор достанет вас. Поэтому эти люди утверждают, что лучший подход – избегать таких вещей. Этот народ предпочитает язык типа C, который имеет минимум ненужных ключевых слов и пунктуаций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Те, кто относятся к другой школе, предпочитают язык Pascal. Они доказывают, что необходимость набрать несколько дополнительных символов – это малая цена за удобочитаемость. В конце концов, люди тоже должны читать программы. Их самый лучший аргумент в том, что каждая такая конструкция является возможностью сообщить компилятору, что вы действительно хотите того, что сказали. Сахарные токены служат в качестве полезных ориентиров, помогающих вам не сбиться с пути..\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Различия хорошо представлены этими двум языками. Наиболее часто слышимая претензия к C – что он слишком прощающий. Когда вы делаете ошибку в C, ошибочный код часто является другой допустимой конструкцией C. Так что компилятор просто счастливо продолжает компиляцию и оставляет вам нахождение ошибок в течение отладки. Я предполагаю именно поэтому отладчики так популярны среди C программистов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, если компилируется программа на Паскале, вы можете быть вполне уверены, что программа будет делать то, что вы ей сказали. Если имеется ошибка во время выполнения, возможно это ошибка разработки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самым лучшим примером полезного сахара является непосредственно точка с запятой. Рассмотрите фрагмент кода:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=1+(2*b+c) b...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как нет никакого оператора, соединяющего токен 'b' с остальной частью выражения, компилятор заключит, что выражение заканчивается на ')' а 'b' – это начало нового утверждения. Но предположим, что я просто пропустил предполагаемый оператор и в действительности хотел сказать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=1+(2*b+c)*b...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае компилятор выдаст ошибку, хорошо, но она не будет очень осмысленной, так как он будет ожидать знак '=' после 'b', который в действительности не должен быть там.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если, наооборот, я вставлю точку с запятой после 'b', тогда не может остаться сомнений где, как я предполагаю, заканчивается утверждение. Синтаксический сахар, т.о., может служить очень полезной цели, предоставляя некоторую дополнительную подстраховку что мы остаемся на правильном пути.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я нахожусь где-то посередине между этими подходами. Я склоняюсь к преимуществам Паскалевской точки зрения... я был бы очень доволен находить свои ошибки во время компиляции а не во время выполнения. Но я также ненавижу просто бросаться словами без явной причины как в COBOL. Пока что я последовательно выкинул большинство Паскалевского сахара из KISS/TINY. Но я конечно не испытываю сильных чувств к любому способу и я также могу видеть значение разбрасывания небольшого количества сахара только для дополнительной подстраховки, которую он дает. Если вам нравится этот последний подход, такие вещи легко добавить. Только запомните, что как и точка с запятой каждая ложка сахара – это что-то, что может потенциально привести к ошибке компиляции при ее пропуске.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Работа с точками с запятой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть два различных способа работы с точками с запятой используемые в популярных языках. В Паскале точка с запятой расценивается как разделитель операторов. Точка с запятой не требуется после последнего утверждения в блоке. Синтаксис:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= <statement> ( ';' <statement>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <statement> ::= <assignment> | <if> | <while> ... | null\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (пустое утверждение важно!)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Паскаль также определяет некоторые точки с запятой в других местах, таких как после утверждения PROGRAM.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В C и Ada, с другой стороны, точка с запятой рассматриватся как терминатор операторов и следует после всех утверждений (с некоторыми смущающими и путающими исключениями). Синтаксис для них простой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <block> ::= ( <statement> ';')*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из двух синтаксисов, синтаксис Паскаля внешне выглядит более рациональным, но опыт показал, что он ведет к некоторым странным трудностям. Люди так привыкают ставить точку с запятой после каждого утверждения, что они также предпочитают ставить ее и после последнего утверждения в блоке. Это обычно не приносит какого-либо вреда... она просто обрабатывается как пустое утверждение. Многие программисты на Паскале, включая вашего покорного слугу, делают точно также. Но есть одно место, в котором вы абсолютно не можете поставить точку с запятой – прямо перед ELSE. Это маленький подводный камень стоил мне множества дополнительных компиляций, особенно когда ELSE добавляется к существующему коду. Так что выбор C/Ada оказывается лучше. Очевидно, Никлаус Вирт думает также: в его Modula-2 он отказался от Паскалевского подхода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имея эти два синтаксиса, легко (теперь, когда мы реорганизовали синтаксический анализатор!) добавить эти возможности в наш анализатор. Давайте сначала возьмем последний случай, так как он проще.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала я упростил программу представив новую подпрограмму распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Semicolon \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Semi;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString(';');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура очень похожа на наш старый Match. Она требует чтобы следующим токеном была точка с запятой. Найдя его, она переходит к следующему.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как точка с запятой следует за утверждением, процедура Block почти единственная, которую мы должны изменить:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Token in ['e', 'l']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'x': Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Semi;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Внимательно взгляните на тонкие изменения в операторе case. Вызов Assigment теперь ограничивается проверкой Token. Это позволит избежать вызова Assigment когда токен является точкой с запятой (что случается когда утверждение пустое).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как объявления – тоже утверждения, мы также должны добавить вызов Semi в процедуру TopDecl:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = 'v' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = ',' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Semi;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец нам нужен вызов для утверждения PROGRAM:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('PROGRAM');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Semi;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Header;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('BEGIN');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 MatchString('END');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проще некуда. Испробуйте это с копией TINY и скажите как вам это нравится.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Версия Паскаля немного сложнее, но она все равно требует только небольших изменений и то только в процедуре Block. Для максимальной простоты давайте разобьем процедуру на две части. Следующая процедура обрабатывает только одно утверждение:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Single Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Statement;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Scan;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Token of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'i': DoIf;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'w': DoWhile;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'R': DoRead;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'W': DoWrite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'x': Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя эту процедуру мы можем переписать Block так:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Statement;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Token = ';' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Statement;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это, уверен, не повредило, не так ли? Теперь мы можем анализировать точки с запятой в Паскаль-подобном стиле.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Компромисс\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы знаем как работать с точками с запятой, означает ли это, что я собираюсь поместить их в KISS/TINY? И да и нет. Мне нравится дополнительный сахар и защита, которые приходят с уверенным знанием, где заканчиваются утверждения. Но я не изменил своей антипатии к ошибкам компиляции, связанным с точками с запятой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что я придумал хороший компромис: сделаем их необязательными!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрите следующую версию Semi:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Semicolon \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Semi;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Token = ';' then Next;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура будет принимать точку с запятой всякий раз, когда вызвана, но не будет настаивать на ней. Это означает, что когда вы решите использовать точки с запятой, компилятор будет использовать дополнительную информацию чтобы удержаться на правильном пути. Но если вы пропустите одну (или пропустите их всех) компилятор не будет жаловаться. Лучший из обоих миров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поместите эту процедуру на место в первую версию вашей программы (с синтаксисом для C/Ada) и вы получите TINY Version 1.2.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Комментарии\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вплоть до этого времени я тщательно избегал темы комментариев. Вы могли бы подумать, что это будет простая тема... в конце концов компилятор совсем не должен иметь дела с комментариями; он просто должен игнорировать их. Чтож, иногда это так.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Насколько простыми или насколько трудными могут быть комментарии, зависит от выбранного вами способа их реализации. В одном случае, мы можем сделать так, чтобы эти комментарии перехватывались как только они поступят в компилятор. В другом, мы можем обрабатывать их как лексические элементы. Станет интереснее когда вы рассмотрите вещи, типа разделителей комментариев, содержащихся в строках в кавычках.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Односимвольные разделители\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот пример. Предположим, мы принимаем стандарт Turbo Pascal и используем для комментариев фигурные скобки. В этом случае мы используем односимвольные разделители, так что наш анализ немного проще.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один подход состоит в том, чтобы удалять комментарии как только мы встретим их во входном потоке, т.е. прямо в процедуре GetChar. Чтобы сделать это сначала измените имя GetChar на какое-нибудь другое, скажем GetCharX. (На всякий случай запомните, это будет временное изменение, так что лучше не делать этого с вашей единственной копией TINY. Я полагаю вы понимаете, что вы всегда должны делать эти эксперименты с рабочей копией).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нам нужна процедура для пропуска комментариев. Так что наберите следующее:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip A Comment Field \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '\}' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно, что эта процедура будет просто считывать и отбрасывать символы из входного потока, пока не найдет правую фигурную скобку. Затем она считывает еще один символ и возвращает его в Look.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы можем написать новую версию GetChar, которая вызывает SkipComment для удаления комментариев:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get Character from Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Any Comments \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '\{' then SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наберите этот код и испытайте его. Вы обнаружите, что вы действительно можете вставлять комментарии везде, где захотите. Комментарии никогда даже не попадут в синтаксический анализатор... каждый вызов GetChar просто возвращает любой символ, не являющийся частью комментария.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фактически, хотя этот метод делает свое дело и может даже совершенно удовлетворять вас, он делает свою работу немного слишком хорошо. Прежде всего, большинство языков программирования определяет, что комментарии должны быть обработаны как пробелы, так как комментарии не могут быть вложены, скажем, в имя переменной. Эта текущая версия не заботится о том, где вы помещаете комментарии.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, так как остальная часть синтаксического анализатора не может даже получить символ '\{', вам не будет позволено поместить его в строку в кавычках.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, прежде чем вы отвернете свой нос от такого упрощенного решения, я должен подчеркнуть, что столь уважаемый компилятор, как Turbo Pascal, также не позволит использовать '\{' в строке в кавычках. Попробуйте. Относительно комментариев, вложенных в идентификатор, я не могу представить чтобы кто-то захотел сделать подобные вещи, так что вопрос спорен. Для 99% всех приложений то что я показал, будет работать просто отлично.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но, если вы хотите быть щепетильным в этом вопросе и придерживаться стандартного обращения, тогда нам нужно переместить место перехвата немного ниже.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы сделать это сперва верните GetChar на старое место и измените имя, вызываемое в SkipComment Затем, давайте добавим левую фигурную скобку как возможный символ незаполненного пространства:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB, CR, LF, '\{'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы можем работать с комментариями в процедуре SkipWhite:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '\{' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipComment\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что SkipWhite написан так, что мы пропустим любую комбинацию незаполненного пространства и комментариев в одном вызове.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Протестируйте компилятор. Вы обнаружите, что он позволит комментариям служить разделителями токенов. Заслуживает внимания, что этот подход также дает нам возможность обрабатывать фигурные скобки в строках в кавычках, так как внутри этих строк мы не будем проверять или пропускать пробелы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Остался последний вопрос: вложенные комментарии. Некоторым программистам нравится идея вложенных комментариев так как это позволяет комментировать код во время отладки. Код, который я дал здесь не позволит этого и, снова, не позволит и Turbo Pascal.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но исправить это невероятно просто. Все, что нам нужно – сделать SkipComment рекурсивной:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip A Comment Field \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '\}' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '\{' then SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Готово. Настолько утонченный обработчик комментариев, какой вам когда-либо может понадобиться.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Многосимвольные разделители\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это хорошо для случаев, когда комментарии ограничены одиночными символами, но как быть с такими случаями как C или стандартный Pascal, где требуются два символа? Хорошо, принцип все еще тот же самый, но мы должны совсем немного изменить наш подход. Я уверен, что вы не удивитесь узнав, что это более сложный случай.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для многосимвольной ситуации проще всего перехватывать левый ограничитель в GetChar. Мы можем «токенизировать» его прямо здесь, заменяя его одиночным символом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте условимся, что мы используем ограничители C '/*' и '*/'. Сначала мы должны возвратиться к методу 'GetCharX'. В еще одной копии вашего компилятора переименуйте GetChar в GetCharX и затем введите следующую новую процедуру GetChar:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character. Intercept '/*' \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if TempChar <> ' ' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Look := TempChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TempChar := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '/' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(TempChar);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if TempChar = '*' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Look := '\{';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TempChar := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть эта процедура перехватывает каждое появление '/'. Затем она исследует следующий символ в потоке. Если это символ '*', то мы нашли начало комментария и GetChar возвратит его односимвольный заменитель. (Для простоты я использую тот же самый символ '\{' как я делал для Паскаля. Если бы вы писали компилятор C, вы без сомнения захотели бы использовать какой-то другой символ, не используемый где-то еще в C. Выберите что вам нравится... даже $FF, что-нибудь уникальное).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если символ, следующий за '/' не '*', тогда GetChar прячет его в новой глобальной переменной TempChar и возвращает '/'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что вы должны объявить эту новую переменную и присвоить ей значение ' '. Мне нравится делать подобные вещи с использование конструкции «типизированная константа» в Turbo Pascal:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 const TempChar: char = ' ';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нам нужна новая версия SkipComment:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip A Comment Field \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Look = '*';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Look = '/';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на несколько вещей: прежде всего нет необходимости изменять функцию IsWhite и процедуру SkipWhite так как GetChar возвращает токен '\{'. Если вы измените этот символ токена, тогда конечно вы также должны будете изменить символ в этих двух подпрограммах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, заметьте, что SkipComment вызывает в своем цикле не GetChar а GetCharX. Это означает, что завершающий '/' не перехватывается и обрабатывается SkipComment. В-третьих, хотя работу выполняет процедура GetChar, мы все же можем работать с символами комментариев вложенными в строки в кавычках, вызывая GetCharX вместо GetChar пока мы находимся внутри строки. Наконец, заметьте, что мы можем снова обеспечить вложенные комментарии добавив одиночное утверждение в SkipComment, точно также как мы делали прежде.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Односторонние комментарии\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока что я показал вам как работать с любыми видами комментариев, ограниченных слева и справа. Остались только односторонние комментарии подобные используемым в ассемблере или Ada, которые завершаются концом строки. На практике этот способ проще. Единственная процедура, которая должна быть изменена – SkipComment, которая должна теперь завершаться на символе переноса строки:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip A Comment Field \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipComment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 repeat\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetCharX;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 until Look = CR;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если ведущий символ – одиночный, как ";" в ассемблере, тогда мы по существу все сделали. Если это двухсимвольный токен, как "–" из Ada, нам необходимо только изменить проверки в GetChar. В любом случае это более легкая проблема чем двухсторонние комментарии.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту у нас есть возможность работать и с комментариями и точками с запятой, так же как и с другими видами синтаксического сахара. Я показал вам несколько способов работы с каждым из них, в зависимости от желаемых соглашений. Остался единственный вопрос – какие из этих соглашений мы должны использовать в KISS/TINY?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По причинам, которые я высказал по ходу дела, я выбираю следующее:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Точки с запятой – терминаторы а не разделители.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Точки с запятой необязательны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Комментарии ограничены фигурными скобками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Комментарии могут быть вложенными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поместите код, соответствующий этим случаям в вашу копию TINY. Теперь у вас есть \b TINY Version 1.2\b0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы разрешили эти побочные проблемы, мы можем наконец возвратиться в основное русло. В следующей главе мы поговорим о процедурах и передаче параметров и добавим эти важные возможности в TINY.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Процедуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец-то мы принимаемся за хорошую главу!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту мы изучили почти все основные особенности компиляторов и синтаксического анализа. Мы узнали как транслировать арифметические выражения, булевы выражения, управляющие конструкции, объявления данных и операторы ввода/вывода. Мы определили язык TINY 1.3, который воплощает все эти возможности, и написали элементарный компилятор, который может их транслировать. Добавив файловый ввод/вывод мы могли бы действительно иметь работающий компилятор, способный производить выполнимые объектные файлы из программ, написанных на TINY. С таким компилятором мы могли бы писать простые программы, способные считывать целочисленные данные, выполнять над ними вычисления и выводить результаты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это хорошо, но то, что у нас есть, это все еще только игрушечный язык. Мы не можем считывать и выводить даже одиночные символы текста и у нас все еще нет процедур.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти возможности, которые будут обсуждены в следующих двух главах, так сказать отделят мужчин от игрушек. «Настоящие» языки имеют более одного типа данных и они поддерживают вызовы процедур. Более чем любые другие, именно эти две возможности дают языку большую часть его характера и индивидуальности. Как только мы предоставим их, наши языки, TINY и его преемники, перестанут быть игрушками и получат характер настоящих языков, пригодных для серъезного программирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В течение нескольких предыдущих глав я обещал вам урок по этим двум важным темам. Каждый раз появлялись другие проблемы, которые требовали отклонения и работы с ними. Наконец у нас появилась возможность оставить все эти проблемы в покое и вернуться в основное русло. В этой главе я охвачу процедуры. В следующий раз мы поговорим об основных типах данных.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Последнее отклонение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта глава была необычайно трудной для меня. Причина не имеет никакого отношения непосредственно к теме... я знал, о чем хотел рассказать уже какое-то время, и фактически я представил большинство из этого на Software Development '89, в феврале. Больше это имело отношение к подходу. Позвольте мне объяснить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я впервые начал эту серию, я сказал вам, что мы будем использовать некоторые «приемы» чтобы упростить себе жизнь и позволить нам получить общее представление не вдаваясь слишком подробно в детали. Среди этих приемов была идея рассмотрения отдельных частей компилятора в отдельные моменты времени, т.е. выполнения экспериментов, использующих Cradle как основу. Когда, например, мы исследовали выражения мы работали только с этой частью теории компиляции. Когда мы исследовали управляющие структуры, мы писали различные программы, все еще основанные на Cradle, для выполнения этой части. Мы включили эти понятия в полный язык довольно недавно. Эти методы служили нам действительно очень хорошо и привели нас к разработке компилятора для TINY версии 1.3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вначале, когда я начал этот урок, я попытался основываться на том, что мы уже сделали и просто добавлять новые возможности в существующий компилятор. Это оказалось немного неудобным и сложным... слишком, чтобы удовлетворить меня.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В конце концов я выяснил почему. В этой серии экспериментов я отказался от очень полезного метода, который позволил нам добраться до сюда, и без особой на то нужды я переключился на новый метод работы, который включал в себя пошаговые изменения в полной версии компилятора TINY.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы долны понять, что то, чем мы здесь занимаемся немного уникально. Существует ряд статей таких как статьи по Small C от Кейна и Хендрикса, которые представляли законченный компилятор для одного языка или другого. Это другое. В этой обучающей серии вы наблюдаете за моей разработкой и реализацией и языка и компилятора в реальном режиме времени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В экспериментах, которые я проводил при подготовке к этой статье, я пробовал вносить изменения в компилятор TINY таким способом, что на каждом шаге мы бы все еще имели настоящий, работающий компилятор. Другими словами, я сделал попытку инкрементального расширения языка и его компилятора в то же самое время объясняя вам, что я делал.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это оказалось тяжелым делом! В конце-концов я понял, что глупо было и пытаться. Достигнув столького используя идею маленьких экспериментов, основанных на односимвольных токенах и простых, специализированных программах, я отказался от них в пользу работы с полным компилятором. Это не сработало.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому мы собираемся возвратиться к своим корням, так сказать. В этой и следующей главах я буду снова использовать односимвольные токены для исследования концепции процедур, освобожденный от другого багажа, накопленного нами на предыдущих уроках. Фактически, я даже не буду пытаться в конце этого урока обьединить конструкции в компилятор TINY. Мы оставим это на потом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В конце концов на этот раз вам не понадобится что-то большее, так что давайте не будем больше тратить времени зря и двинемся вперед.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Основы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все современные центральные процессоры предоставляют прямую поддержку вызовов процедур и 68000 не исключение. Для 68000 вызов – BSR (PC-относительная версия) или JSR, и возвращение RTS. Все что мы должны сделать это организовать для компилятора выдачу этих команд в соответствующих местах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В действительности есть три вещи, которые мы должны рассмотреть. Одна из них – механизм вызова/возврата. Вторая – механизм определения процедур. И, наконец, вопрос передачи параметров в вызываемую процедуру. Ни одна из этих вещей не является в действительности очень сложной и мы можем конечно позаимствовать то, что сделано в других языках... нет необходимости заново изобретать колесо. Из этих трех вопросов передача параметров займет большую часть нашего внимания просто потому что здесь существует много возможностей.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Основа для экспериментов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как всегда нам понадобится некоторое программное обеспечение, которое послужит нам как основание для того, что мы делаем. Нам не нужна полная версия компилятора TINY но нам нужна достаточная его часть для того, чтобы некоторые конструкции были представлены. В частности, нам нужна по крайней мере возможность обрабатывать утверждения некоторых видов и объявления данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, показанная ниже является такой основой. Это остаточная форма TINY с односимвольными токенами. Она имеет объявления данных, но только в их самой простейшей форме... никаких списков или инициализаторов. Имеются операции присваивания, но только вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <ident> = <ident>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другими словами, единственным допустимым выражением является одиночное имя переменной. Нет никаких управляющих конструкций... единственным допустимым утверждением является присваивание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большую часть программы составляют просто подпрограммы из стандартного Cradle. Я показал ее здесь полностью только для того, чтобы быть уверенным что все мы начинаем с одного места:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Calls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var ST: Array['A'..'Z'] of char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Undefined Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Undefined(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Undefined Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Duplicate Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Duplicate(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort('Duplicate Identifier ' + n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get Type of Symbol \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function TypeOf(n: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TypeOf := ST[n];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Look for Symbol in Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(n: char): Boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := ST[n] <> ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add a New Symbol to Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddEntry(Name, T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Intable(Name) then Duplicate(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[Name] := T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Check an Entry to Make Sure It's a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CheckVar(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not InTable(Name) then Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if TypeOf(Name) <> 'v' then Abort(Name + ' is not a\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 variable');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := upcase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over an End-of-Line \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Post a Label To Output \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PostLabel(L: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(L, ':');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreVar(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Vestigial Version \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Begin-Block \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('e');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'v';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(N, ':', TAB, 'DC 0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> 'b' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что у нас есть таблица идентификаторов и есть логика для проверки допустимости имени переменной. Также стоит обратить внимание на то, что я включил код, который вы видели ранее для поддержки пробелов и переносов строк. Наконец заметьте, что основная программа ограничена как обычно операторными скобками BEGIN-END.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы скопировали программу в Turbo, первым делом нужно откомпилировать ее и удостовериться что она работает. Сделайте несколько объявлений а затем блок begin. Попробуйте что-нибудь вроде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 va (для VAR A)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 vb (для VAR B)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 vc (для VAR C)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b (для BEGIN)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b=c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 e. (для END.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как обычно, вы должны сделать некоторые преднамеренные ошибки и проверить, что программа правильно их отлавливает.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объявление процедуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы удовлетворены, как работает наша маленькая программа, тогда пришло время поработать с процедурами. Так как мы еще не говорили о параметрах мы начнем с рассмотрения только таких процедур которые не имеют списка параметров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала, давайте рассмотрим простую программу с процедурой и подумаем о коде который мы хотели бы увидеть для нее сгенерированным:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROGRAM FOO;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROCEDURE BAR; BAR:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END; RTS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN \{ MAIN PROGRAM \} MAIN:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO; BSR BAR\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 . .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END. END MAIN\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь я показал конструкции высокоуровневого языка слева и желаемый ассемблерный код справа. Прежде всего заметьте, что здесь несомненно нам не нужно генерировать много кода! Для большей части процедуры и основной программы наши существующие конструкции позаботятся о генерируемом коде.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ключ к работе с телом процедуры – понимание того, что хотя процедура может быть очень длинной, ее объявление в действительности не отличается от объявления переменной. Это просто еще один вид объявлений. Мы можем записать БНФ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <declaration> ::= <data decl> | <procedure>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это означает, что можно легко изменить TopDecl для работы с процедурами. Как насчет синтаксиса процедуры? Хорошо, вот предлагаемый синтаксис, который по существу такой же как и в Pascal:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <procedure> ::= PROCEDURE <ident> <begin-block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь практически не требуется никакой генерации кода., кроме генерации внутри блока begin. Мы должны только выдать метку в начале процедуры и RTS в конце.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот требуемый код:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Procedure Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'p';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Return;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что я добавил новую подпрограмму генерации кода Return, которая просто выдает инструкцию RTS. Создание этой подпрограммы «оставлено как упражнение студенту».\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для завершения этой версии добавьте следующую строку в оператор Case в DoBlock.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'p': DoProc;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я должен упомянуть, что эта структура для объявлений и БНФ, которая управляет ей, отличается от стандартного Паскаля. В определении Паскаля от Дженсена и Вирта объявления переменных и, фактически, все виды объявлений, должны следовать в определенном порядке, т.е. метки, константы, типы, переменные, процедуры и основная программа. Чтобы следовать такой схеме, мы должны разделить два объявления и написать в основной программе что-нибудь вроде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DoVars;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DoProcs;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DoMain;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, большинство реализаций Паскаля, включая Turbo, не требуют такого порядка и позволяют вам свободно перемешивать различные объявления до тех пор пока вы не попробуете обратиться к чему-то прежде, чем это будет объявлено. Хотя это может быть больше эстетическим удовлетворением объявлять все глобальные переменные на вершине программы, конечно не будет никакого вреда от того, чтобы разрешить расставлять их в любом месте. Фактически, это может быть даже немного полезно, в том смысле, что это даст нам возможность выполнять небольшое элементарное скрытие информации. Переменные, к которым нужно обращатся только из основной программы, к примеру, могут быть объявлены непосредственно перед ней и будут таким образом недоступны для процедур.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте эту новую версию. Заметьте, что мы можем объявить так много процодур, как захотим (до тех пор, пока не исчерпаем односимвольные имена!) и все метки и RTS появятся в правильных местах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь стоит заметить, что я не разрешаю вложенные процедуры. В TINY все процедуры должны быть объявлены на глобальном уровне, так же как и в C. На Форуме Компьютерных Языков на CompuServe по этому поводу возникла порядочная дискуссия. Оказывается, существует значительная расплата сложностью которая должна быть заплачена за роскошь использования вложенных процедур. Более того, эта расплата платится во время выполнения, так как должен быть добавлен дополнительный код, который будет выполняться каждый раз когда процедура вызывается. Я также охотно верю что вложение это не очень хорошая идея просто на том основании, что я видел слишком много злоупотреблений этой возможностью. Прежде, чем сделать следующий шаг, также стоит обратить внимание на то, что «основная програма» в ее текущем состоянии незавершена, так как она не имеет метки и утверждения END. Давайте исправим эту небольшую оплошность:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoMain;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('b');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DoMain;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что DoProc и DoMain не совсем симметричны. DoProc использует вызов BeginBlock тогда как DoMain нет. Это из-за того, что начало процедуры определяется по ключевому слову PROCEDURE (в данном случае сокращенно 'p'), тогда как основная программа не имеет никакого другого ключевого слова кроме непосредственно BEGIN.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И это ставит интересный вопрос: почему?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы посмотрим на структуры C программы, мы обнаружим, что все функции совсем одинаковы, за исключением того, что основная программа идентифицируется по своему имени «main». Так как функции C могут появляться в любом порядке, основная программа так же может быть в любом месте модуля компиляции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Паскале наоборот, все переменные и процедуры должны быть объявлены прежде чем они используются, что означает, что нет никакого смысла помещать что-либо после основной программы... к ней никогда нельзя будет обратиться. «Основная программа» не идентифицирована вообще, кроме того, что эта часть кода следует после глобального BEGIN. Другими словами если это не что-нибудь еще, это должна быть основная программа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это приводит к немалой путанице для начинающих программистов, а для больших программ на Паскале иногда вообще трудно найти начало основной программы. Это ведет к соглашениям типа идентификации ее в комментариях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN \{ of MAIN \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это всегда казалось мне немного клуджем. Возникает вопрос: Почему обработка основной программы должна так отличаться от обработки процедур? Теперь, когда мы осознали, что объявление процедур это просто... часть глобальных объявлений... не является ли основная программа также просто еще одним объявлением?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ – да, и обрабатывая ее таким способом мы можем упростить код и сделать его значительно более ортогональным. Я предлагаю использовать для идентификации основной программы явное ключевое слово PROGRAM (Заметьте, что это означает, что мы не можем начать с него файл, как в Паскале). В этом случае наша БНФ становится:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <declaration> ::= <data decl> | <procedure> | <main program>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <procedure> ::= PROCEDURE <ident> <begin-block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <main program> ::= PROGRAM <ident> <begin-block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код также смотрится намного лучше, по крайней мере в том смысле, что DoMain и DoProc выглядят более похоже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoMain;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('P');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Prolog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '.' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'P': DoMain;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Epilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как объявление основной программы теперь внутри цикла TopDecl, возникают некоторые трудности. Как мы можем гарантировать, что она – последняя в файле? И выйдем ли мы когда либо из цикла? Мой ответ на второй вопрос, как вы можете видеть, – в том, чтобы вернуть нашего старого друга точку. Как только синтаксический анализатор увидит ее дело сделано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ на первый вопрос: он зависит от того, насколько мы хотим защищать программиста от глупых ошибок. В коде, который я показал, нет ничего, предохраняющего программиста от добавления кода после основной программы... даже другой основной программы. Код просто не будет доступен. Однако, мы могли бы обращаться к нему через утверждение FORWARD, которое мы предоставим позже. Фактически, многие программисты на ассемблере любят использовать область сразу после программы для объявления больших, неинициализированных блоков данных, так что действительно может быть некоторый смысл не требовать, чтобы основная программа была последней. Мы оставим все как есть.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы решим, что должны дать программисту немного больше помощи чем сейчас, довольно просто добавить некоторую логику, которая выбросит нас из цикла как только основная программа будет обработана. Или мы могли бы по крайней мере сообщать об ошибке если кто-то попытается вставить две основных.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Вызов процедуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы удовлетворены работой программы, давайте обратимся ко второй половине уравнения... вызову.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим БНФ для вызова процедуры:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <proc_call> ::= <identifier>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с другой стороны БНФ для операции присваивания:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <assignment> ::= <identifier> '=' <expression>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кажется у нас проблема. Оба БНФ утверждения с правой стороны начинаются с токена <identifier>. Как мы предполагаем узнать, когда мы видим идентификатор, имеем ли мы вызов процедуры или операцию присваивания? Это похоже на случай, когда наш синтаксический анализатор перестает быть предсказывающим и действительно это точно такой случай. Однако, оказывается эту проблему легко решить, так как все, что мы должны сделать – посмотреть на тип идентификатора записанный в таблице идентификаторов. Как мы обнаружили раньше, небольшое локальное нарушение правила предсказывающего синтаксического анализа может быть легко обработано как специальный случай.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот как это делается:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Decide if a Statement is an Assignment or Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AssignOrProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case TypeOf(Name) of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ' ': Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Assignment(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': CallProc(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Identifier ' + Name +\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ' Cannot Be Used Here');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while not(Look in ['e']) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AssignOrProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, процедура Block сейчас вызывает AssignOrProc вместо Assignment. Назначение этой новой процедуры просто считать идентификатор, определить его тип и затем вызвать процедуру, соответствующую этому типу. Так как имя уже прочитано, мы должны передать его в эти две процедуры и соответственно изменить Assignment. Процедура CallProc – это просто подпрограмма генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Call a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CallProc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('BSR ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, к этому моменту у нас есть компилятор, который может работать с процедурами. Стоить отметить, что процедуры могут вызывать процедуры с любой степенью вложенности. Так что, даже хотя мы и не разрешаем вложенные объявления, нет ничего, чтобы удерживало нас от вложенных вызовов, точно так, как мы ожидали бы на любом языке. Мы получили это и это было не слишом сложно, не так ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, пока мы можем работать только с процедурами, которые не имеют параметров. Процедуры могут оперировать глобальными переменными по их глобальным именам. Так что к этому моменту мы имеем эквивалент конструкции Бейсика GOSUB. Не слишком плохо... в конце концов масса серъезных программ была написана с применением GOSUBа., но мы можем добиться большего и добьемся. Это следующий шаг.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Передача параметров\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова, все мы знаем основную идею передачи параметров, но давайте просто для надежности разберем ее заново.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще, процедуре предоставляется список параметров, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROCEDURE FOO(X, Y, Z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В объявлении процедуры параметры называются формальными параметрами и могут упоминаться в теле процедуры по своим именам. Имена, используемые для формальных параметров в действительности произвольны. Учитывается только позиция. В примере выше имя 'X' просто означает «первый параметр» везде, где он используется.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда процедура вызывается, «фактические параметры» переданные ей, связаны с формальными параметрами на взаимно-однозначном принципе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БНФ для синтаксиса выглядит приблизительно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <procedure> ::= PROCEDURE <ident> '(' <param-list> ')' <begin-block>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <param_list> ::= <parameter> ( ',' <parameter> )* | null\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично, вызов процедуры выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <proc call> ::= <ident> '(' <param-list> ')'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что здесь уже есть неявное решение, встроенное в синтаксис. Некоторые языки, такие как Pascal и Ada разрешают списку параметров быть необязательным. Если нет никаких параметров, вы просто полностью отбрасываете скобки. Другие языки, типа C и Modula-2, требуют скобок даже если список пустой. Ясно, что пример, который мы только что привели, соответствует первой точке зрения. Но, сказать правду, я предпочитаю последний. Для одних процедур решение кажется должно быть в пользу «безсписочного» подхода. Оператор\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Initialize; ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 стоящий отдельно, может означать только вызов процедуры. В синтаксических анализаторах, которые мы писали, мы преимущественно использовали процедуры без параметров и было бы позором каждый раз заставлять писать пустую пару скобок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но позднее мы также собираемся использовать и функции. И так как функции могут появляться в тех же самым местах что и простые скалярные идентификаторы, вы не сможете сказать об их различиях. Вы должны вернуться к объявлениям, чтобы выяснить это. Некоторые люди полагают, что это преимущество. Их аргументы в том, что идентификатор замещается значением и почему вас заботит, сделано ли это с помощъю подстановки или функции? Но нас это иногда заботит, потому что функция может выполняться довольно долго. Если написав простой идентификатор в данном выражении мы можем понести большие затраты во время выполнения, то мне кажется, что мы должны быть осведомлены об этом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае, Никлаус Вирт разработал и Pascal и Modula-2. Я оправдаю его и полагаю что он имел веские причины для изменения правил во втором случае!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Само собой разумеется, легко принять любую точку зрения на то, как разрабатывать язык, так что это строго вопрос персонального предпочтения. Делайте это таким способом, какой вам больше нравится.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед тем как пойти дальше, давайте изменим транслятор для поддержки списка параметров (возможно пустого). Пока мы не будем генерировать никакого дополнительного кода... просто анализировать синтаксис. Код для обработки объявления имеет ту же самую форму, которую мы видели раньше когда работали со списками переменных:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process the Formal Parameter List of a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> ')' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В процедуру DoProc необходимо добавить строчку для вызова FormalList:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Procedure Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'p';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Return;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас код для FormalParam всего лишь пустышка, который просто пропускает имена переменных:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Formal Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для фактического вызова процедуры должен быть аналогичный код для обработки списка фактических параметров:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process an Actual Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process the Parameter List for a Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ParamList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> ')' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CallProc(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ParamList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Call(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что CallProc больше не является просто простой подпрограммой генерации кода. Она имеет некоторую структуру. Для обработки я переименовал подпрограмму генерации кода в просто Call и вызвал ее из CallProc.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, если вы добавите весь этот код в ваш транслятор и протестируете его, вы обнаружите, что действительно можете правильно анализировать синтаксис. Обращаю ваше внимание на то, что здесь нет никакой проверки того, что количество (и, позднее, тип) формальных и фактических параметров совпадает. В промышленном компиляторе, мы конечно должны делать это. Сейчас мы игнорируем эту проблему той причине, что структура нашей таблицы идентификаторов пока не дает нам места для сохранения необходимой информации. Позднее мы подготовим место для этих данных и тогда сможем работать с этой проблемой.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Семантика параметров\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До этого мы имели дело с синтаксисом передачи параметров и получили механизм синтаксического анализа для его обработки. Сейчас мы должны рассмотреть семантику, т.е. действия, которые должны быть предприняты когда мы столкнемся с параметрами. Это ставит нас перед вопросом выбора способа передачи параметров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует более чем один способ передачи параметров и способ, которым мы сделаем это, может иметь глубокое влияние на характер языка. Так что это одна из тех областей, где я не могу просто дать вам свое решение. Скорее, было бы важно чтобы мы потратили некоторое время на рассмотрение альтернатив, так чтобы вы могли, если захотите, пойти своим путем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть два основных способа передачи параметров:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • По значению\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • По ссылке (адресу)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Различия лучше всего видны в свете небольшого исторического обзора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Старые компиляторы Фортрана передавали все параметры по ссылке. Другими словами, фактически передавался адрес параметра. Это означало, что вызываемая подпрограмма была вольна и считывать и изменять этот параметр, что часто и происходило, как будто это была просто глобальная переменная. Это был фактически самый эффективный способ и он был довольно простым, так как тот же самый механизм использовался во всех случаях с одним исключением, которое я кратко затрону.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя имелись и проблемы. Многие люди чувствовали, что этот метод создавал слишком большую связь между вызванной и вызывающей подпрограммой. Фактически, это давало подпрограмме полный доступ ко всем переменным, которые появлялись в списке параметров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто нам не хотелось бы фактически изменять параметр а только использовать его как входные данные. К примеру, мы могли бы передавать счетчик элементов в подпрограмму и хотели бы затем использовать этот счетчик в цикле DO. Во избежание изменения значения в вызываемой программе мы должны были сделать локальную копию входного параметра и оперировать только его копией. Некоторые программисты на Фортране фактически сделали практикой копирование всех параметров, исключая те, которые должны были использоваться как возвращаемые значения. Само собой разумеется, все это копирование победило добрую часть эффективности, связанной с этим методом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существовала, однако, еще более коварная проблема, которая была в действительности не просто ошибкой соглашения «передача по ссылке», а плохой сходимостью нескольких решений реализации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, у нас есть подпрограмма:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SUBROUTINE FOO(X, Y, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где N – какой-то входной счетчик или флажок. Часто нам бы хотелось иметь возможность передавать литерал или даже выражение вместо переменной, как например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CALL FOO(A, B, J + 1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Третий параметр не является переменной, и поэтому он не имеет никакого адреса. Самые ранние компиляторы Фортрана не позволяли таких вещей, так что мы должны были прибегать к ухищрениям типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 K = J + 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CALL FOO(A, B, K)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь снова требовалось копирование и это бремя ложилось на программистов. Не хорошо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более поздние реализации Фортрана избавились от этого, разрешив использовать выражения как параметры. Что они делали – назначали сгенерированную компилятором переменную, сохраняли значение выражения в этой переменной и затем предавали адрес выражения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока все хорошо. Даже если подпрограмма ошибочно изменила значение анонимной переменной, кто об этом знал или кого это заботило? При следующем вызове она в любом случае была бы рассчитана повторно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема возникла когда кто-то решил сделать вещи более эффективными. Они рассуждали, достаточно справедливо, что наиболее общим видом «выражений» было одиночное целочисленное значение, как в:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CALL FOO(A, B, 4)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Казалось неэффективным подходить к проблеме «вычисления» такого целого числа и сохранять его во временной переменной только для передачи через список параметров. Так как мы в любом случае передавали адрес, казалось имелся большой смысл в том, чтобы просто передавать адрес целочисленного литерала, 4 в примере выше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы сделать вопрос более интересным большинство компиляторов тогда и сейчас идентифицирует все литералы и сохраняет их отдельно в «литерном пуле», так что мы должны сохранять только одно значение для каждого уникального литерала. Такая комбинация проектных решений: передача выражений, оптимизация литералов как специальных случаев и использование литерного пула – это то, что вело к бедствию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы увидеть, как это работает, вообразите, что мы вызываем подпрограмму FOO как в примере выше, передавая ей литерал 4. Фактически, что передается – это адрес литерала 4, который сохранен в литерном пуле. Этот адрес соответствует формальному параметру K в самой подпрограмме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь предположите, что без ведома программиста подпрограмма FOO фактически присваивает K значение -7. Неожиданно, литерал 4 в литерном пуле меняется на -7. В дальнейшем, каждое выражение, использующее 4, и каждая подпрограмма, в которую передают 4, будут использовать вместо этого значение -7! Само собой разумеется, что это может привести к несколько причудливому и труднообъяснимому поведению. Все это дало концепции передачи по ссылке плохое имя, хотя, как мы видели, в действительности это была комбинация проектных решений, ведущая к проблеме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несмотря на проблему, подход Фортрана имел свои положительные моменты. Главный из них – тот факт, что мы не должны поддерживать множество механизмов. Та же самая схема передачи адреса аргумента работает для всех случаев, включая массивы. Так что размер компилятора может быть сокращен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Частично из-за этого подводного камня Фортрана и частично просто из-за уменьшенной связи, современные языки типа C, Pascal, Ada и Modula 2 в основном передают скаляры по значению.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это означает, что значение скаляра копируется в отдельное значение, используемое только для вызова. Так как передаваемое значение – копия, вызываемая процедура может использовать его как локальную переменную и изменять ее любым способом, каким нравится. Значение в вызывающей программе не будет изменено.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала может показаться, что это немного неэффективно из-за необходимости копировать параметр. Но запомните, что мы в любом случае окажемся перед необходимостью выбирать какое-то значение, является ли оно непосредственно параметром или его адресом. Внутри подпрограммы, использование передачи по значению определенно более эффективно, так как мы устраняем один уровень косвенности. Наконец, мы видели раньше, что в Фортране часто было необходимо в любом случае делать копии внутри подпрограммы, так что передача по значению уменьшает количество локальных переменных. В целом, передача по значению лучше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исключая одну маленькую деталь: если все параметры передаются по значению, у вызванной процедуры нет никакого способа возвратить результат в вызвавшую! Переданный параметр не изменяется в вызвавшей подпрограмме а только в вызванной. Ясно, что так работы не сделать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют два эквивалентных ответа на эту проблему. В Паскале Вирт предусмотрел параметры-переменные, которые передаются по ссылке. VAR параметр не что иное как наш старый друг параметр Фортрана с новым именем и расцветкой для маскировки. Вирт аккуратно обходит проблему «изменения литерала» так же как проблему «адрес выражения» с помощью простого средства, разрешая использовать в качестве фактических параметров только переменные. Другими словами, это тоже самое ограничение, которое накладывали самые ранние версии Фортрана.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Си делает ту же самую вещъ, но явно. В C все параметры передаются по значению. Однако одним из видов переменных, которые поддерживает С, является указатель. Так передавая указатель по значению, вы в действительности передаете то, на что он указывает по ссылке. В некоторых случаях это работает даже еще лучше, потому что даже хотя вы и можете изменить указываемую переменную на все, что хотите, вы все же не сможете изменить сам указатель. В функции типа strcpy, к примеру, где указатель увеличивается при копировании строки, мы в действительности увеличиваем только копии указателей, так что значение указателей в вызвавшей процедуре все еще остается каким было. Чтобы изменить указатель вы должны передавать указатель на указатель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как мы просто проводим эксперименты, мы рассмотрим и передачу по значению и передачу по ссылке. Таким образом у нас будет возможность использовать любой из них как нам нужно. Стоит упомянуть, что было бы тяжело использовать здесь подход С, так как указатель это другой тип а типы мы еще не изучали!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Передача по значению\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте просто попробуем некоторые нехитрые вещи и посмотрим, куда они нас приведут. Давайте начнем со случая передачи по значению. Рассмотрим вызов процедуры:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO(X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Почти единственным приемлемым способом передачи данных является передача через стек ЦПУ. Поэтому, код который мы бы хотели видеть сгенерированным мог бы выглядеть так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X(PC),-(SP) ; Push X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE Y(PC),-(SP) ; Push Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BSR FOO ; Call FOO\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это конечно не выглядит слишком сложным!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда BSR выполнен центральный процессор помещает адрес возврата в стек и переходит к FOO. В этой точке стек будет выглядеть следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Значение X (2 bytes)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Значение Y (2 bytes)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SP –> Адрес возврата (4 bytes)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что значения параметров имеют адреса с фиксированными смещениями от указателя стека. В этом примере адреса такие:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X: 6(SP)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y: 4(SP)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь рассмотрим, на что могла бы походить вызываемая процедура:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROCEDURE FOO(A, B)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 A = B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Помните, что имена формальных параметров произвольные... учитываются только позиции).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Желаемый код мог бы выглядеть так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO: MOVE 4(SP),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,6(SP)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RTS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что для адресации формальных параметров нам будет необходимо знать, какую позицию они занимают в списке параметров. Это подразумевает некоторые изменения в содержимом таблицы идентификаторов. Фактически, в нашем односимвольном случае лучше всего просто создать новую таблицу идентификаторов для формальных параметров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с объявления новой таблицы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var Params: Array['A'..'Z'] of integer;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам также необходимо отслеживать, сколько параметров имеет данная процедура:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var NumParams: integer;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И мы должны инициализировать новую таблицу. Теперь, не забудьте, что список формальных параметров будет различным для каждой процедуры, которые мы обрабатываем, так что мы будем должны инициализировать эту таблицу заново для каждой процедуры. Вот инициализатор:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize Parameter Table to Null \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ClearParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Params[i] := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NumParams := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы поместим обращение к этой процедуре в Init и также в конец DoProc:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := ' ';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ClearParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Procedure Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'p';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Return;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ClearParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что вызов внутри DoProc гарантирует, что таблица будет чиста, когда мы в основной программе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, теперь нам нужны несколько процедур для работы с таблицей. Следующие несколько функций являются по существу копиями InTable, TypeOf и т.д.:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Find the Parameter Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function ParamNumber(N: char): integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ParamNumber := Params[N];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ See if an Identifier is a Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsParam(N: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsParam := Params[N] <> 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add a New Parameter to Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddParam(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsParam(Name) then Duplicate(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Inc(NumParams);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Params[Name] := NumParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, нам понадобятся некоторые подпрограммы генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Parameter to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 4 + 2 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(SP),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Parameter from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 4 + 2 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE D0,');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push The Primary Register to the Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Последнюю подпрограмму мы уже видели прежде, но ее не было в этой остаточной версии программы.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После этих приготовлений мы готовы работать с семантикой процедур со списками вызовов (помните, что код для работы с синтаксисом уже на месте).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с обработки формальных параметров. Все что мы должны сделать – добавить каждый параметр в таблицу идентификаторов параметров:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Formal Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddParam(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, что делать с формальными параметрами, когда они появляются в теле процедуры? Это требует немного больше работы. Мы должны сначала определить, что это формальный параметр. Чтобы сделать это, я написал модифицированную версию TypeOf:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get Type of Symbol \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function TypeOf(n: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsParam(n) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TypeOf := 'f'\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TypeOf := ST[n];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что так как TypeOf теперь вызывает IsParam, возможно будет необходимо изменить ее местоположение в программе.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы также должны изменить AssignOrProc для работы с этим новым типом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Decide if a Statement is an Assignment or Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AssignOrProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case TypeOf(Name) of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ' ': Undefined(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v', 'f': Assignment(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'p': CallProc(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Identifier ' + Name + ' Cannot Be Used Here');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, код для обработки операции присваивания и выражения должен быть расширен:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Vestigial Version \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsParam(Name) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadParam(ParamNumber(Name))\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsParam(Name) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreParam(ParamNumber(Name))\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVar(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, эти процедуры обработают каждое встретившееся имя переменной или как формальный параметр или как глобальную переменную, в зависимости от того, появляется ли оно в таблице идентификаторов параметров. Запомните, что мы используем только остаточную форму Expression. В конечной программе изменения, показанные здесь, должны быть добавлены в Factor а не Expression.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Осталось самое простое. Мы должны только добавить семантику в фактический вызов процедуры, что мы можем сделать с помощъю одной новой строки кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process an Actual Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так вот. Добавьте эти изменения в вашу программу и испытайте ее. Попробуйте объявить одну или две процедуры, каждая со списком формальных параметров. Затем сделайте какие-нибудь присваивания, используя комбинации глобальных и формальных параметров. Вы можете вызывать одну процедуру из другой, но вы не можете объявлять вложенные процедуры. Вы можете даже передавать формальные параметры из одной процедуры в другую. Если бы мы имели здесь полный синтаксис языка, вы могли бы также читать и выводить формальные параметры или использовать их в сложных выражениях.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Что неправильно?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тут вы могли бы подумать: Уверен, здесь должно быть что-то большее чем несколько сохранений и восстановлений из стека. Для передачи параметров здесь должно быть что-то большее чем тут есть.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы были бы правы. Фактически, код, который мы здесь генерируем, оставляет желать лучшего в нескольких случаях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самая явная оплошность в том, что он неправильный! Если вы оглянетесь на код для вызова процедур, вы увидите, что вызывающая подпрограмма помещает каждый фактический параметр в стек перед тем, как она вызывает процедуру. Процедура использует эту информацию, но она не изменяет указатель стека. Это означает, что содержимое все еще остается там когда мы возвращаемся. Кто-то должен очистить стек или мы скоро окажемся в очень трудной ситуации!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью, это легко исправить. Все, что мы должны сделать – это увеличить указатель стека когда мы закончим.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Должны ли мы делать это в вызывающей программе или в вызываемой процедуре? Некоторые люди позволяют вызываемой процедуре очищать стек, так как требуется генерировать меньше кода на вызов и так как процедура, в конце концов, знает сколько параметров она получила. Но это означает, что она должна что-то делать с адресом возврата чтобы не потерять его.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я предпочитаю разрешить очистку в вызывающей программе, так что вызываемая процедура должна только выполнить возврат. Также это кажется немного более сбалансированным так как именно вызывающая программа первой «засорила» стек. Но это означает, что вызывающая программа должна запоминать сколько элементов помещено в стек. Чтобы сделать проще, я изменил процедуру ParamList на функцию, возвращающую количество помещенных байт:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process the Parameter List for a Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function ParamList: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> ')' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 inc(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 inc(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ParamList := 2 * N;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура CallProc затем использует его для очистки стека:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Procedure Call \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CallProc(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := ParamList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Call(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CleanStack(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь я создал еще одну подпрограмму генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Adjust the Stack Pointer Upwards by N Bytes \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CleanStack(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if N > 0 then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('ADD #');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(N, ',SP');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, если вы добавили этот код в ваш компилятор, я думаю вы убедитесь, что стек теперь под контролем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая проблема имеет отношение к нашему способу адресации относительно указателя стека. Это работает отлично на наших простых примерах, так как с нашей элементарной формой выражений никто больше не засоряет стек. Но рассмотрим другой пример, такой простой как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PROCEDURE FOO(A, B)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BEGIN\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 A = A + B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 END\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Код, сгенерированный нехитрым синтаксическим анализатором, мог бы быть:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO: MOVE 6(SP),D0 ; Извлечь A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; Сохранить его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE 4(SP),D0 ; Извлечь B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADD (SP)+,D0 ; Добавить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,6(SP) : Сохранить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RTS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это было бы неправильно. Когда мы помещаем первый аргумент в стек, смещения для двух формальных параметров больше не 4 и 6, я 6 и 8. Поэтому вторая выборка вернула бы снова A а не B.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это не конец света. Я думаю, вы можете видеть, что все, что мы должны делать – изменять смещение каждый раз, когда мы помещаем в стек и что фактически и делается если ЦПУ не имеет поддержки других методов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью, все-же, 68000 имеет такую поддержку. Поняв, что этот ЦПУ мог бы использоваться со многими компиляторами языков высокого уровня, Motorola решила добавить прямую поддержку таких вещей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема, как вы можете видеть в том, что когда процедура выполняется, указатель стека скачет вверх и вниз, и поэтому использование его как ссылки для доступа к формальным параметрам становится неудобным. Решение состоит в том, чтобы вместо него определить и использовать какой-то другой регистр. Этот регистр обычно устанавливается равным подлинному указателю стека и называется указателем кадра.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Команда LINK из набора инструкций 68000 позволяет вам объявить такой указатель кадра и установить его равным указателю стека и все это в одной команде. Фактически, она делает даже больше чем это. Так как этот регистр может использоваться для чего-то еще в вызывающей процедуре, LINK также помещает текущее значение регистра в стек. Вы можете также добавить значение к указателю стека чтобы создать место для локальных переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В дополнение к LINK есть UNLK, которая просто восстанавливает указатель стека и выталкивает старое значение обратно в регистр.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С использованием этих двух команд код для предыдущего примера станет:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO: LINK A6,#0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE 10(A6),D0 ; Извлечь A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; Сохранить его\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE 8(A6),D0 ; Извлечь B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADD (SP)+,D0 ; Добавить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,10(A6) : Сохранить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UNLK A6\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RTS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исправить компилятор для генерации этого кода намного проще чем объяснить. Все, что нам нужно сделать – изменить генерацию кода в DoProc. Так как из-за этого код становится немного больше одной строки, я создал новые процедуры, схожие с процедурами Prolog и Epilog, вызываемыми DoMain:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog for a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ProcProlog(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LINK A6,#0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Epilog for a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ProcEpilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('UNLK A6');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('RTS');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура DoProc теперь просто вызывает их:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Procedure Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'p';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ProcProlog(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ProcEpilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ClearParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В заключение, мы должны изменить ссылки на SP в процедурах LoadParam и StoreParam:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Parameter to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 2 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Parameter from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 2 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE D0,');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что вычисление Offset изменяется чтобы учесть дополнительное сохранение A6.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это все что требуется. Попробуйте и посмотрите как вам это нравится.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту мы генерируем некоторый относительно хороший код для процедур и вызовов процедур. С ограничениями, что нет никаких локальных переменных (пока) и не разрешено вложение процедур этот код именно то что нам нужно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все еще остается только одна небольшая проблема:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У нас нет способа возвратить результат в вызывающую программу!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это, конечно, не ограничение генерируемого нами кода, а ограничение, свойственное протоколу передачи по значению. Обратите внимание, что мы можем использовать формальные параметры любым способом внутри процедуры. Мы можем вычислять для них новое значение, использовать их как счетчики циклов (если бы мы имели циклы!) и т.д. Так что код делает то, что предполагается. Чтобы решить эту последнюю проблему мы должны рассмотреть альтернативный протокол.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Передача по ссылке\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это просто теперь, когда мы уже имеем механизм. Мы только должны внести несколько изменений в генерацию кода. Вместо помещения значения в стек, мы должны помещать адрес. Оказывается, 68000 имеет инструкцию PEA которая как раз делает это.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для этого мы сделаем новую версию тестовой программы. Перед тем, как сделать что-нибудь еще, сделайте копию программы в ее текущем состоянии, потому что позже она понадобится нам снова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с рассмотрения кода, который мы хотели бы видеть сгенерированным для нового случая. Используя тот же самый пример что и раньше, мы должны вызов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO(X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оттранслировать в:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PEA X(PC) ; Сохранить адрес X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PEA Y(PC) ; Сохранить адрес Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 BSR FOO ; Вызвать FOO\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это просто вопрос небольших изменений в Param:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process an Actual Parameter \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Param;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('PEA ' + GetName + '(PC)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что при передачей по ссылке мы не можем использовать выражения в списке параметров, поэтому Param может просто непосредственно считывать имя).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На другой стороне, ссылки на формальные параметры должны получить один уровень косвенности:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 FOO: LINK A6,#0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L 12(A6),A0 ; Извлечь адрес A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE (A0),D0 ; Извлечь A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; Сохранить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L 8(A6),A0 ; Извлечь адрес B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE (A0),D0 ; Извлечь B\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ADD (SP)+,D0 ; Добавить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L 12(A6),A0 ; Извлечь адрес A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,(A0) : Сохранить A\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 UNLK A6\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RTS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это может быть обработано с изменениями в LoadParam and StoreParam:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Parameter to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 4 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE.L ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (A0),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Parameter from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 4 * (NumParams – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE.L ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для правильного расчета, мы также должны изменить одну строку в ParamList:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ParamList := 4 * N;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь должно работать. Испытайте компилятор и посмотрите, генерирует ли он приемлемый код. Как вы увидите, код вряд ли оптимален, так как мы перезагружаем регистр адреса каждый раз, когда необходим параметр. Но это соответствует нашему принципу KISS – просто генерировать код который работает. Мы только сделаем здесь небольшое замечание, что есть еще один кандидат для оптимизации и пойдем дальше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы научились обрабатывать параметры использую передачу по значению и передачу по ссылке. В реальном мире, конечно, мы хотели бы иметь возможность работать с обоими методами. Однако пока мы не можем этого сделать, потому что у нас еще не было урока по типам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы можем иметь только один метод, то, конечно, это должен быть старый добрый Фортранов метод передачи по ссылке, так как это единственный способ, которым процедуры могут возвращать значения в вызвавшую программу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это, фактически, будет одним из различий между TINY и KISS. В следующей версии TINY мы будем использовать передачу по ссылке для всех параметров. KISS будет поддерживать оба метода.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Локальные переменные\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока мы не сказали ничего о локальных переменных и наше определение процедур не разрешает их. Само собой разумеется, что это большой пробел в нашем языке и он должен быть исправлен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И снова здесь мы стоим перед выбором: статическое или динамическое хранение?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В старых FORTRAN программах локальные переменные использовали статическое хранение подобно глобальным. То есть, каждая локальная переменная получала имя и распределенный адрес как любая другая переменная и к ней обращались по этому имени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нам это легко сделать, используя уже имеющийся механизм распределения. Помните, однако, что локальные переменные могут иметь те же самые имена, что и глобальные переменные. Мы так или иначе должны согласиться с этим, назначая уникальные имена для этих переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Характерная особенность статического хранения в том, что данные выживают при вызове процедуры и возврате. Когда процедура вызывается снова, данные все еще будут здесь. Это может быть преимуществом в некоторых приложениях. Во времена FORTRAN мы применяли такой прием как инициализация флажка, чтобы вы могли сказать когда мы входим в процедуру первый раз и могли бы выполнить любую первоначальную инициализацию, которую необходимо выполнить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, эта же «особенность» статического хранения делает рекурсию невозможной. Любое новое обращение к процедуре перепишет данные уже находящиеся в локальных переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Альтернативой является динамическое хранение, при котором память распределяется в стеке точно также как и для переданных параметров. Для это мы уже имеем готовый механизм. Фактически, те же самые подпрограммы, которые работают с переданными (по значению) параметрами в стеке, могут так же легко работать и с локальными переменными... генерируемый код тот же самый. Назначение смещения в инструкции 68000 LINK сейчас такое: мы можем использовать его для регулировки указателя стека при выделении места для локальных переменных. Динамическое хранение, конечно, по существу поддерживает рекурсию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я впервые начал планировать TINY, я должен признаться имел предубеждение в пользу статического хранения. Просто потому, что старые FORTRAN программы были чрезвычайно эффективны... ранние компиляторы FORTRAN производили качественный код, который и сейчас редко сопоставим с современными компиляторами. Даже сегодня данная программа, написанная на FORTRAN вероятно превзойдет ту же самую программу написанную на C или Pascal, иногда с большим отрывом. (Вот так! Что вы скажете на это заявление!)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я всегда полагал, что причина имела отношение к двум основным различиям между реализациями Фортрана и другими языками: статическое хранение и передача по ссылке. Я знаю, что динамическое хранение поддерживает рекурсию, но мне всегда казалось немного странным желание мириться с более медленным кодом, который в 95% случаев не нуждается в рекурсии, только для того чтобы получить эту возможность когда она понадобится. Идея состоит в том, что со статическим хранением вы можете использовать не косвенную а абсолютную адресацию, которая должна привести к более быстрому коду.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Позднее, однако, некоторые люди указали мне, что в действительности нет никаких падений производительности связанной с динамическим хранением. Для 68000, к примеру, вы в любом случае не должны использовать абсолютную адресацию... большинство операционных систем требуют переместимый код. И команда 68000\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE 8(A6),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет тоже самое время выполнения, что и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X(PC),D0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что теперь я убежден, что нет никакой важной причины не использовать динамическое хранение.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как такое использование локальных переменных так хорошо соответствует схеме передачи параметров по значению, мы будем использовать эту версию транслятора для иллюстрации (я надеюсь вы сохранили копию!).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основная идея состоит в том, чтобы отслеживать количество локальных параметров. Затем мы используем это число в инструкции LINK для корректировки указателя стека при выделения для них места. Формальные параметры адресуются как положительные смещения от указателя кадра а локальные как отрицательные смещения. С небольшой доработкой те же самые процедуры, которые мы уже создали, могут позаботиться обо всем этом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте начнем с создания новой переменной Base:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var Base: integer;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем использовать эту переменную вместо NumParams для вычисления смещения стека. Это подразумевает изменение двух ссылок на NumParams в LoadParam и StoreParam:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Parameter to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 2 * (Base – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE ');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Parameter from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreParam(N: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Offset: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Offset := 8 + 2 * (Base – N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('MOVE D0,');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Offset, '(A6)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Идея состоит в том, что значение Base будет заморожено после того, как мы обработаем формальные параметры и не будет увеличиваться дальше когда новые, локальные, переменные будут вставлены в таблицу идентификаторов. Об этом позаботится код в конце FormalList:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process the Formal Parameter List of a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look <> ')' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = ',' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(',');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalParam;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Base := NumParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 NumParams := NumParams + 4;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Мы добавили четыре слова чтобы учесть адрес возврата и старый указатель кадра, который заканчивается между формальными параметрами и локальными переменными.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все что мы должны сделать дальше – это установить семантику объявления локальных переменных в синтаксическом анализаторе. Подпрограммы очень похожи на Decl и TopDecls:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Local Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LocDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddParam(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Local Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function LocDecls: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var n: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look = 'v' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LocDecl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 inc(n);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LocDecls := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что LocDecls является функцией, возвращающей число локальных переменных в DoProc.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем мы изменим DoProc для использования этой информации:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Procedure Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DoProc;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var N: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 k: integer;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('p');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 N := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Duplicate(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := 'p';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 FormalList;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 k := LocDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ProcProlog(N, k);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 BeginBlock;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ProcEpilog;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ClearParams;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Я сделал пару изменений, которые не были в действительности необходимы. Кроме небольшой реорганизации я переместил вызов Fin в FormalList а также в LocDecls. Не забудьте поместить его в конец FormalList.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на изменения при вызове ProcProlog. Новый параметр – это число слов (не байт) для распределения памяти. Вот новая версия ProcProlog:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write the Prolog for a Procedure \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure ProcProlog(N: char; k: integer);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PostLabel(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit('LINK A6,#');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(-2 * k)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас должно работать. Добавьте эти изменения и посмотрите как они работают.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту вы знаете как компилировать объявления и вызовы процедур с параметрами, передаваемыми по ссылке и по значению. Вы можете также обрабатывать локальные переменные. Как вы можете видеть, сложность состоит не в предоставлении механизма, а в определении какой механизм использовать. Стоит нам принять эти решения и код для трансляции в действительности не будет таким сложным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не показал вам как работать с комбинацией локальных параметров и передачей параметров по ссылке, но это простое расширение того, что вы уже видели. Это просто немного более хлопотно и все, так как мы должны поддерживать оба механизма вместо одного. Я предпочел оставить это на потом, когда мы научимся работать с различными типами переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это будет следующая глава, которая появится ближе к Форуму.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Типы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последней главе (Часть 13, Процедуры) я упомянул, что в ней и в следующей главе мы рассмотрим две возможности, которые помогут отделить игрушечный язык от настоящего, пригодного к использованию. В ней мы рассмотрели вызовы процедур. Многие из вас терпеливо ждали, начиная с Августа'89 когда я выдам вторую. Хорошо, вот она.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы поговорим о том, как работать с различными типами данных. Как и в последней главе, я не буду сейчас включать эти возможности непосредственно в компилятор TINY. Вместо этого я буду использовать тот же самый подход, который так хорошо служил нам в прошлом: использование только фрагментов синтаксического анализатора и односимвольных токенов. Как обычно, это позволит на добраться непосредственно до сути вопроса не продираясь сквозь массу ненужного кода. Так как основные проблемы при работе с множественными типами данных возникают в арифметических операциях, на них мы и сконцентрируем свое внимание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несколько предупреждений: Во-первых, есть некоторые типы, которые я не буду охватывать в этой главе. Здесь мы будем говорить только о простых, встроенных типах. Мы даже не будем работать с массивами, указателями или строками, я охвачу их в следующих нескольких главах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, мы также не будем обсуждать и типы определяемые пользователем. Это будет значительно позже, по той простой причине, что я все еще не убедил себя, что эти определяемые пользователем типы должны быть в языке KISS. В более поздних главах я собираюсь охватить по крайней мере основные концепции определяемых пользователем типов, записей и т.д., просто для того, чтобы серия была полной. Но действительно ли они будут включены как часть KISS – все еще открытый вопрос. Я открыт для комментариев и предложений по этой теме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, я должен предупредить вас: то, что мы собираемся сделать может добавить массу дополнительных сложностей и в синтаксический анализатор и в генерируемый код. Поддерживать различные типы достаточно просто. Сложность возникает когда вы добавляете правила преобразования между типами. Вообще-то, будет ли ваш компилятор простым или сложным зависит от способа, выбранного вами для определения правил преобразования типов. Даже если вы решите запретить любые преобразования типов (как в Ada, например) проблема все еще остается, и она встроена в математику. Когда вы умножаете два коротких числа, к примеру, вы можете получить длинный результат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я подошел к этой проблеме очень осторожно, пытаясь сохранить простоту. Но мы не можем полностью избежать сложности. Как обычно случается, мы оказываемся перед необходимостью выбирить между качеством кода и сложностью и, как обычно, я предпочитаю выбрать самый простой подход.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Что будет дальше?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем мы погрузимся в это занятие, я думаю вам бы хотелось знать что мы сейчас собираемся делать... особенно после того, как прошло столько много времени с прошлой главы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тем временем я не бездействовал. Я разбил компилятор на модули. Одна из проблем, с которыми я столкнулся, в том, что так как мы охватывали новые области и вследствие этого расширяли возможности компилятора TINY, он становился все больше и больше. Я понял пару глав назад, что это приводило к затруднениям и именно поэтому я возвратился к использованию только фрагментов компилятора в последней и этой главах. Кажется просто глупо заново воспроизводить код для, скажем, обработки булевых исключающих ИЛИ, когда тема дискуссии – передача параметров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидным способом получит свой пирог и съесть его также является разбиение компилятора на раздельно компилируемые модули и, конечно, модули Turbo Pascal являются для этого идеальным средством. Это позволит нам скрыть некоторый довольно сложный код (такой как полный синтаксический анализ арифметических и булевых выражений) в одиночный модуль и просто вытаскивать его всякий раз когда он необходим. При таком способе единственным кодом, который я должен буду воспроизводить в этих главах, будет код который непосредственно касается обсуждаемого вопроса.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я также игрался с Turbo 5.5 который, конечно, включает Борландовские объектно-ориентированные расширения Паскаля. Я не решил, использовать ли эти возможности, по двум причинам. Прежде всего, многие из вас, кто следовал за этой серией, могут все еще не иметь 5.5 и я конечно не хочу вынуждать кого-либо пойти и купить новый компилятор только для того, чтобы завершить эту серию. Во-вторых, я не убежден, что ОО расширения имеют такое большое значение для этого приложения. Мы обсуждали кое-что из этого на форуме CLM на CompuServe, и пока что мы не нашли никакой убедительной причины для использования ОО конструкции. Это одна из тех областей, где я мог бы использовать некоторую обратную связь с читателями. Кто-нибудь хочет проголосовать за Turbo 5.5 и ООП?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае после следующих нескольких глав этой серии я планирую предоставить вам законченный набор модулей а также законченные функционирующие компиляторы. Планом фактически предусмотрено три компилятора: один для односимвольной версии TINY (для использования в наших экспериментах), один для TINY и один для KISS. Я достаточно четко выделил различия между TINY и KISS:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 TINY будет поддерживать только два типа данных: символьный и 16-разрядное целое число. Я могу также попробовать сделать что-нибудь со строками, так как без них компилятор был бы довольно бесполезным. KISS будет поддерживать все обычные простые типы, включая массивы и даже числа с плавающей точкой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 TINY будет иметь только две управляющие конструкции IF и WHILE. KISS будет поддерживать очень богатый набор конструкций включая одну, которую мы не обсуждали здесь ранее... CASE.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 KISS будет поддерживать раздельно компилируемые модули.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одно предостережение: так как я все еще не знаю достаточно об ассемблере для 80x86, все эти модули компилятора все еще будут написаны для поддержки кода 68000. Однако в программах, которые я планирую вам представить, вся генерация кода была тщательно изолирована в отдельном модуле, так что любой предприимчивый студент смог бы перенастроить их на любой другой процессор. Эта задача «оставлена как упражнение для студента». Я сделаю предложение прямо здесь и сейчас: с человеком, который предоставит нам первый надежный перевод для 80x86, я буду счастлив обсудить коллективные авторские права и авторские отчисления от предстоящей книги.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но хватит говорить. Давайте приступим к изучению типов. Как я сказал ранее, мы будем делать это как и в последней главе: выполняя эксперименты с использованием односимвольных токенов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Таблица идентификаторов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Должно быть очевидным, что если мы собираемся работать с переменными различных типов, нам понадобится какое-то место для записи их типов. Очевидным средством для этого является таблица идентификаторов и мы уже использовали ее например для различия между локальными и глобальными переменными и между переменными и процедурами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структура таблицы идентификаторов для односимвольных токенов особенно проста и мы использовали ее прежде несколько раз. Для работы с ней, мы возьмем некоторые процедуры, которые мы использовали раньше.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала, нам необходимо объявить саму таблицу идентификаторов:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST: Array['A'..'Z'] of char; \{ *** ДОБАВЬТЕ ЭТУ СТРОКУ ***\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем мы должны удостовериться, что она инициализируется в процедуре Init:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := '?';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая процедура в действительности нам не нужна, но она будет полезна для отладки. Все, что она делает, это формирует дамп содержимого таблицы идентификаторов:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Dump the Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DumpTable;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(i, ' ', ST[i]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В действительности не имеет значения, где вы поместите эту процедуру... я планирую группировать все подпрограммы таблицы идентификаторов вместе, так что я поместил ее сразу после процедур сообщений об ошибках.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы осторожный тип (как я), вам возможно захотелось бы начать с тестовой программы, которая ничего не делает а просто инициализирует таблицу и затем создает ее дамп. Только для того, чтобы быть уверенным, что все мы находимся на одной волне, ниже я воспроизвожу всю программу, дополненную новыми процедурами. Заметьте, что эта версия включает поддержку пробелов:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Types;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Constant Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CR = ^M;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LF = ^J;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Variable Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST: Array['A'..'Z'] of char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report an Error \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Error and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Abort(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report What Was Expected \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Abort(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Dump the Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure DumpTable;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(i, ' ', ST[i]);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Decimal Digit \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an AlphaNumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlNum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+', '-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Mulop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*', '/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Boolean Orop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsOrop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsOrop := c in ['|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Relop \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsRelop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsRelop := c in ['=', '#', '<', '>'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsWhite(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsWhite := c in [' ', TAB];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over Leading White Space \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsWhite(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Skip Over an End-of-Line \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = CR then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = LF then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match a Specific Input Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Output a String with Tab and CRLF \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Initialize \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var i: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 for i := 'A' to 'Z' do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[i] := '?';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DumpTable;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, запустите эту программу. Вы должны получить (очень быстро) распечатку всех букв алфавита (потенциальных идентификаторов) сопровождаемых вопросительным знаком. Не очень захватывающе, но это только начало.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, вообще-то мы хотим видеть типы только тех переменных, которые были определены. Мы можем устранить другие добавив в DumpTable условие IF. Измените цикл следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 for i := 'A' to 'Z' do\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if ST[i] <> '?' then\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WriteLn(i, ' ', ST[i]);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь запустите программу снова. Что вы получили?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, это даже более скучно чем раньше! Сейчас вообще ничего не выводится, так как в данный момент ни одно из имен не было обьявлено. Мы можем немного приправить результат вставив в основную программу несколько операторов, объявляющих несколько записей. Попробуйте такие:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ST['A'] := 'a';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ST['P'] := 'b';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ST['X'] := 'c';\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На этот раз, когда вы запустите программу, вы должны получить распечатку, показывающую, что таблица идентификаторов работает правильно.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Добавление записей\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, заполнение таблицы напрямую – довольно плохая практика и она не сможет хорошо нам послужить в будущем. То, что нам нужно, это процедура, добавляющая записи в таблицу. В то же самое время мы знаем, что нам будет необходимо тестировать таблицу для проверки, что мы не объявляем повторно переменную, которая уже используется (что легко может случиться при наличии всего 26 вариантов!). Для поддержки всего это введите следующие новые процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report Type of a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function TypeOf(N: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TypeOf := ST[N];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Report if a Variable is in the Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function InTable(N: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 InTable := TypeOf(N) <> '?';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Check for a Duplicate Variable Name \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure CheckDup(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if InTable(N) then Abort('Duplicate Name ' + N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add Entry to Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AddEntry(N, T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 CheckDup(N);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ST[N] := T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь измените три строки в основной программе следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddEntry('A', 'a');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddEntry('P', 'b');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AddEntry('X', 'c');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и запустите программу снова. Работает? Тогда у нас есть подпрограммы таблицы идентификаторов, необходимые для поддержки нашей работы с типами. В следующем разделе мы начнем их использовать на практике.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Распределение памяти\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В других программах, подобных этой, включая сам компилятор TINY, мы уже обращались к вопросу объявления глобальных переменных и кода, генерируемого для них. Давайте создадим здесь урезанную версию «компилятора», чья единственная функция – позволить нам объявлять переменные. Помните, синтаксис для объявления:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <data decl> ::= VAR <identifier>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова, мы можем вытащить массу кода из предыдущих программ. Следующий код – это урезанные версии тех процедур. Они значительно упрощены, так как я удалил такие тонкости как списки переменных и инициализаторы. Обратите внимание, что в процедуре Alloc новый вызов AddEntry будет также заботиться о проверке двойных объявлений:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddEntry(N, 'v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(N, ':', TAB, 'DC 0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('v');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '.' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'v': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, в основной программе добавьте вызов TopDecl и запустите программу. Попробуйте распределить несколько переменных и обратите внимание на полученный сгенерированный код. Для вас это пройденный этап, поэтому результат должен выглядеть знакомым. Заметьте из кода для TopDecls что программа завершается точкой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока вы здесь, попробуйте объявить две переменные с одинаковыми именами и проверьте что синтаксический анализатор отлавливает ошибку.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Объявление типов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Распределение памяти различных размеров не сложнее чем изменение процедуры TopDecl для распознавания более чем одного ключевого слова. Здесь необходимо принять ряд решений, с точки зрения того, каков должен быть синтаксис и т.п., но сейчас я собираюсь отложить все эти вопросы и просто объявить не подлежащий утверждению указ что наш синтаксис будет таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <data decl> ::= <typename> <identifier>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <typename> ::= BYTE | WORD | LONG\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (По удивительному совпадению, первые буквы этих наименований оказались те же самыми что и спецификации длины ассемблерного кода 68000, так что такой выбор съэкономит нам немного работы.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем создать код, который позаботится об этих объявлениях, внеся всего лишь небольше изменения. Обратите внимание, что в подпрограммах, показанных ниже, я отделил генерацию код в Alloc от логической части. Это соответствует нашему желанию изолировать машино-зависимую часть компилятора.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate Code for Allocation of a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure AllocVar(N, T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(N, ':', TAB, 'DC.', T, ' 0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Allocate Storage for a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Alloc(N, T: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AddEntry(N, T);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 AllocVar(N, T);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Data Declaration \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Alloc(GetName, Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate Global Declarations \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '.' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 'b', 'w', 'l': Decl;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Abort('Unrecognized Keyword ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Внесите показанные изменения в эти процедуры и испытайте программу. Используйте одиночные символы "b", "w" и "l" как ключевые слова (сейчас они должны быть в нижнем регистре). Вы увидите, что в каждом случае мы выделяем память соответствующего объема. Обратите внимание, глядя на дамп таблицы идентификаторов, что размеры также сохранены для использования позже. Какого использования? Хорошо, это тема остальной части этой главы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Присваивания\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда мы можем объявлять переменные различных размеров, очевидно что мы должны иметь возможность что-то с ними делать. На первый раз, давайте просто попробуем загружать их в наш рабочий регистр D0. Имеет смысл использовать ту же самую идею, которую мы использовали для Alloc, т.е. сделаем процедуру загрузки, которая может загружать переменные нескольких размеров. Нам также необходимо продолжать изолировать машино-зависимое содержимое. Процедура загрузки выглядит так:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name, Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, Name + '(PC)', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По крайней мере для 68000, многие команды оказываются командами MOVE. Было бы полезно создать отдельный генератор кода только для этих инструкций и затем вызывать его когда необходимо:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate a Move Instruction \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Move(Size: char; Source, Dest: String);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE.' + Size + ' ' + Source + ',' + Dest);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\} \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что эти две подпрограммы – строго генераторы кода; они не имеют проверки ошибок и другой логики. Чтобы завершить картинку, нам необходим еще один программный уровень, который предоставляет эти функции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде всего, мы должны удостовериться, что типы, с которыми мы работаем – загружаемого типа. Это звучит как работа для другого распознавателя:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Legal Variable Type \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsVarType(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsVarType := c in ['B', 'W', 'L'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, было бы хорошо иметь подпрограмму, которая извлечет тип переменной из таблицы идентификаторов в то же время проверяя его на допустимость:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Variable Type from the Symbol Table \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function VarType(Name: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := TypeOf(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsVarType(Typ) then Abort('Identifier ' + Name +\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ' is not a variable');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 VarType := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вооруженная этими инструментами, процедура, выполняющая загрузку переменной, становится тривиальной:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Load(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Name, VarType(Name));\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Примечание для обеспокоившихся: я знаю, знаю, все это очень неэффективно. В промышленной программы мы, возможно, предприняли бы шаги чтобы избежать такого глубокого вложения вызовов процедур. Не волнуйтесь об этом. Это упражнение, помните? Более важно сделать его правильно и понять его, чем получить неправильный ответ но быстро. Если вы закончите свой компилятор и обнаружите, что вы несчастны от его быстродействия, вы вольны вернуться и доработать код для более быстрой работы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Было бы хорошей идеей протестировать программу сейчас. Так как мы пока не имеем процедуры для работы с операциями присваивания, я просто добавил строки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Load('A');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Load('B');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Load('C');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Load('X');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в основную программу. Таким образом, после того, как раздел объявления завершен, они будут выполнены чтобы генерировать код для загрузки. Вы можете поиграть с различными комбинациями объявлений чтобы посмотреть как обрабатываются ошибки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я уверен, что вы не будете удивлены, узнав, что сохранение переменных во многом подобно их загрузке. Необходимые процедуры показаны дальше:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store Primary to Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreVar(Name, Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, 'D0', '(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Variable from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Store(Name: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVar(Name, VarType(Name));\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы можете проверить их таким же образом, что и загрузку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, конечно, достаточно легко использовать их для обработки операций присваивания. Что мы сделаем – создадим специальную версию процедуры Block, которая поддерживает только операции приваивания, а также специальную версию Expression, которая поддерживает в качестве допустимых выражений только одиночные переменные. Вот они:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Load(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Block of Statements \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while Look <> '.' do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Стоит заметить, что новые процедуры, которые позволяют нам манипулировать типами, даже проще и яснее чем те, что мы видели ранее. Это в основном блягодаря нашим усилиям по изоляции подпрограмм генерации кода.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть одна небольшая назойливая проблема. Прежде мы использовали завершающую точку Паскаля чтобы выбраться из процедуры TopDecl. Теперь это неправильный символ... он использован для завершения Block. В предудущих программах мы использовали для выхода символ BEGIN (сокращенно "b"). Но он теперь используется как символ типа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение, хотя и является отчасти клуджем, достаточно простое. Для обозначения BEGIN мы будем использовать 'B' в верхнем регистре. Так что измените символ в цикле WHILE внутри TopDecl с "." на "B" и все будет прекрасно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы можем завершить задачу, изменив основную программу следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Main Program \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Init;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 TopDecls;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('B');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Fin;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Block;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DumpTable;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что я должен был расставить несколько обращений к Fin чтобы избежать проблем переносов строк.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, запустите эту программу. Попробуйте ввести:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ba \{ byte a \} *** НЕ НАБИРАЙТЕ КОММЕНТАРИИ!!! ***\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 wb \{ word b \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 lc \{ long c \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 B \{ begin \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a=c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b=a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b=b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b=c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 c=a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 c=b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 c=c\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для каждого объявления вы должны получить сгенерированный код, распределяющий память. Для каждого присваивания вы должны получить код который загружает переменную корректного размера и сохраняет ее, также корректного размера.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть только одна небольшая проблема: сгенерированный код неправильный!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Взгляните на код для a=c:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L C(PC),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LEA A(PC),A0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.B D0,(A0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот код корректный. Он приведет к сохранению младших восьми бит C в A, что является примлемым поведением. Это почти все, что мы можем ожидать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но теперь, взгляните на противоположный случай. Для c=a генерируется такой код:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.B A(PC),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LEA C(PC),A0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.L D0,(A0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это не правильно. Он приведет к сохранению байтовой переменной A в младших восьми битах D0. Согласно правилам для процессора 68000 старшие 24 бита останутся неизменными. Это означаем, что когда мы сохраняем все 32 бита в C, любой мусор, который был в этих старших разрядах, также будет сохранен. Нехорошо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То, с чем мы сейчас столкнулись назвается проблемой преобразования типов или приведением.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде, чем мы сделаем что-либо с переменными различных типов, даже если это просто их копирование, мы должны быть готовы встретиться с этой проблемой. Это не самая простая часть компилятора. Большинство ошибок, которые я видел в промышленных компиляторах, имели отношение к ошибкам преобразования типов для некоторой неизвестной комбинации аргументов. Как обычно, существует компромисс между сложностью компилятора и потенциальным качеством сгенерированного кода, и, как обычно, мы выберем путь, который сохранит компилятор простым. Я думаю вы надете, что с таким подходом мы можем удерживать потенциальную сложность под достаточным контролем.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Трусливый выход\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде, чем мы заберемся в детали (и потенциальную сложность) преобразования типов, я хотел бы, чтобы вы видели, что существует один суперпростой способ решения проблемы: просто переводить каждую переменную в длинное целое во время загрузки!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для этого достаточно добавить всего одну строку в LoadVar, хотя, если мы не собираемся полностью игнорировать эффективность, она должна ограничиваться проверкой IF. Вот измененная версия:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name, Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Typ <> 'L' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, Name + '(PC)', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что StoreVar не нуждается в подобном изменении).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы выполните некоторые тесты с этой новой версией, вы обнаружите, что теперь все работает правильно, хотя иногда неэффективно. К примеру, рассмотрим случай a=b (для тех же самых объявлений, что показаны выше). Теперь сгенерированный код становится:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CLR.L D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.W B(PC),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 LEA A(PC),A0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE.B D0,(A0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае CLR оказывается ненужной, так как результат помещается в байтовую переменную. Небольшая доработка помогла бы нам улучшить его. Однако, все это не так уж плохо, и это типичного рода неэффективность, которую мы видели прежде в нехитрых компиляторах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я должен подчеркнуть, что устанавливая старшие разряды в нуль, мы фактически обрабатываем числа как целые числа без знака. Если вместо этого мы хотим обрабатывать их как целые числа со знаком (более вероятный случай) мы должны делать расширение знака после загрузки. Просто для того, чтобы обернуть эту часть дискуссии милой красной ленточкой, давайте изменим LoadVar как показано ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name, Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Typ = 'B' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('CLR.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, Name + '(PC)', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Typ = 'W' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой версии байт обрабатывается как беззнаковое число (как в Паскале и Си) в то время как слово обрабатывается как знаковое.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Более приемлемое решение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы видели, перевод каждой переменной в длинное слово пока она находится в памяти решает проблему, но это едва ли может быть названо эффективным и, возможно, не было бы приемлемым даже для тех из нас, кто требует не обращать внимания на эффективность. Это означает, что все арифметические операции будут выполняться с 32-битной точностью, что удвоит время выполнения для большинства операций и сделает его еще больше для умножения и деления. Для этих операций мы должны были бы вызывать подпрограммы, даже если данные были бы байтом или словом. Все это слишком походит на уловку, так как уводит нас от всех настоящих проблем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, значит это решение плохое. Есть ли еще относительно простой способ получить преобразование данных? Можем ли мы все еще сохранять простоту?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Да, действительно. Все, что нам нужно сделать – выполнить преобразование с другого конца... т.е. мы выполняем преобразование на выходе, когда данные сохраняются, а не на входе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но запомните, часть присваивания, отвечающая за хранение, в значительной степени независима от загрузки данных, о которой заботится процедура Expression. Вообще, выражение может быть произвольно сложным, поэтому как может процедура Assignment знать, какой тип данных оставлен в регистре D0?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова, ответ прост: Мы просто спросим об этом процедуру Expression! Ответ может быть возвращен как значение функции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это требует изменения некоторых процедур, но эти изменения, как и сам метод, совсем простые. Прежде всего, так как мы не требуем чтобы LoadVar выполнял всю работу по преобразованию, давайте возвратимся к простой версии:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVar(Name, Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, Name + '(PC)', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, давайте добавим новую процедуру, которая будет выполнять преобразование из одного типа в другой:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Convert a Data Item from One Type to Another \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Convert(Source, Dest: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Source <> Dest then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Source = 'B' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND.W #$FF,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Dest = 'L' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, мы должны реализовать логику, требуемую для загрузки и сохранения переменной любого типа. Вот подпрограммы для этого:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Load(Name: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ : char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := VarType(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVar(Name, Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Load := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store a Variable from the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Store(Name, T1: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var T2: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 T2 := VarType(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T1, T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVar(Name, T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что Load является функцией, которая не только выдает код для загрузки, но также возвращает тип переменной. Таким образом, мы всегда знаем, с каким типом данных мы работаем. Когда мы выполняем Store, мы передаем ей текущий тип переменной в D0. Так как Store также знает тип переменной назначения, она может выполнить преобразование необходимым образом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вооруженная всеми этими новыми подпрограммами, реализация нашего элементарного присваивания по существу тривиальна. Процедура Expression теперь становится функцией возвращающей тип выражения в процедуру Assignment:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := Load(GetName);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Store(Name, Expression);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова, заметьте как невероятно просты эти две подпрограммы. Мы изолировали всю логику типа в Load и Store и хитрость с передачей типа делает остальную работу чрезвычайно простой. Конечно, все это для нашего специального, тривиального случая с Expression. Естественно, для общего случая это будет более сложно. Но теперь вы смотрите на финальную версию процедуры Assignment!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это выглядит как очень простое и ясное решение, и действительно это так. Откомпилируйте эту программу и выполните те же самые тесты, что и ранее. Вы увидите, что все типы данных преобразованы правильно и здесь немного, если вообще есть, зря потраченных инструкций. Только преобразование «байт-длинное слово» использует две инструкции когда можно было бы использовать одну, и мы могли бы легко изменить Convert для обработки этого случая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя мы в этом случае не рассматривали переменные без знака, я думаю вы можете видеть, что мы могли бы легко исправить процедуру Convert для работы и с этими типами. Это «оставлено как упражнение для студента».\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Литеральные аргументы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зоркие читатели могли бы отметить, однако, что мы еще даже не имеем правильной формы простого показателя, потому что мы не разрешаем загрузку литеральных констант, только переменных. Давайте исправим это сейчас.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для начала нам понадобится функция GetNum. Мы уже видели ее несколько версий, некоторые возвращают только одиночный символ, некоторые строку, а некоторые целое число. Та, которая нам здесь нужна будет возвращать длинное целое, так что она может обрабатывать все, что мы ей подбросим. Обратите внимание, что здесь не возвращается никакой информации о типах: GetNum не интересуется тем, как будет использоваться число:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNum: LongInt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Val: LongInt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Val := 10 * Val + Ord(Look) – Ord('0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNum := Val;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SkipWhite;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, когда работаем с литералами, мы имеем одну небольшую проблему. С переменными мы знаем какого типа они должны быть потому что они были объявлены с таким типом. Мы не имеем такой информации о типе для литералов. Когда программист говорит «-1», означает ли это байт, слово или длинное слово? Мы не имеем никаких сведений. Очевидным способом было бы использование наибольшего возможного типа, т.е. длинного слова. Но это плохая идея, потому что когда мы примемся за более сложные выражения, мы обнаружим, что это заставит каждое выражение включающее литералы, также переводить в длинное.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лучшим подходом было бы выбрать тип, основанный на значении литерала, как показано далее:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Constant to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function LoadNum(N: LongInt): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ : char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if abs(N) <= 127 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := 'B'\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if abs(N) <= 32767 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := 'W'\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Typ := 'L';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConst(N, Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadNum := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Я знаю, знаю, база числа не является в действительности симметричной. Вы можете хранить -128 в одиночном байте и -32768 в слове. Но это легко исправить и не стоит затраченного времени или дополнительной сложности возиться с этим сейчас. Стоящая мысль.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что LoadNum вызывает новую версию подпрограммы генерации кода LoadConst, которая имеет дополнительный параметр для определения типа:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Constant to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConst(N: LongInt; Typ: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var temp:string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Str(N, temp);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Typ, '#' + temp, 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы можем изменить процедуру Expression для использования двух возможных видов показателей:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := Load(GetName)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := LoadNum(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Вау, это, уверен, не причинило слишком большого вреда! Всего несколько дополнительных строк делают всю работу.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, соберите этот код в вашу программу и испытайте ее. Вы увидите, что она теперь работает и для переменных и для констант как допустимых выражений.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Аддитивные выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы следовали за этой серией с самого начала, я уверен вы знаете, что будет дальше. Мы расширим форму выражения для поддержки сначала аддитивных выражений, затем мультипликативных, а затем общих выражений со скобками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хорошо, что мы уже имеем модель для работы с этими более сложными выражениями. Все, что мы должны сделать, это удостовериться, что все процедуры, вызываемые Expression, (Term, Factor и т.д.) всегда возвращают идентификатор типа. Если мы сделаем это, то структура программы едва ли вообще изменится.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первый шаг прост: мы должны переименовать нашу существующую версию Expression в Term, как мы делали много раз раньше и создать новую версию Expression:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := Unop\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Typ := Add(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Typ := Subtract(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, как в этой подпрограмме каждый вызов процедуры стал вызовом функции и как локальная переменная Typ модифицируется при каждом проходе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание также на новый вызов функции Unop, которая позволяет нам работать с ведущим унарным минусом. Это изменение не является необходимым... мы все еще можем использовать форму более похожую на ту, что мы использовали ранее. Я решил представить Unop как отдельную подпрограмму потому что позднее это позволит производить несколько лучший код, чем мы делали. Другими словами, я смотрю вперед на проблему оптимизации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для этой версии, тем не менее, мы сохраним тот же самый примитивный старый код, который делает новую подпрограмму тривиальной:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Process a Term with Leading Unary Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Unop: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Clear;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Unop := 'W';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура Push – это подпрограмма генерации кода, которая теперь имеет параметр, указывающий тип:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push Primary onto Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push(Size: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Size, 'D0', '-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте взглянем на функции Add и Subtract. В более старых версиях этих подпрограмм мы позволяем им вызывать подпрограммы генерации кода PopAdd и PopSub. Мы продолжим делать это, что делает сами функции чрезвачайно простыми:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate an Add \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Add(T1: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Add := PopAdd(T1, Term);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Subtract \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Subtract(T1: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Subtract := PopSub(T1, Term);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но простота обманчива, поскольку мы переложили всю логику на PopAdd и PopSub, которые больше не являются просто подпрограммами генерации кода. Они также должны теперь заботиться о необходимых преобразованиях типов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какие это преобразования? Простые: оба аргумента должны иметь тот же самый размер и результат также такой размер. Меньший из двух параметров должен быть «приведен» до размера большего.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но это представляет небольшую проблему. Если переводимый параметр – второй (т.е. в основном регистре D0) мы в отличной форме. Если же нет, мы в затруднении: мы не можем изменить размер данных, которые уже затолкнуты в стек.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение простое, но немного болезненное: мы должны отказаться от этих красивых инструкций «вытолкнуть данные и что-нибудь с ними сделать», заботливо предоставленных Motorola.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Альтернативой является назначение вторичного регистра, в качестве которого я выбрал R7. (Почему не R1? Потому, что для других регистров у меня есть планы на будущее.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первый шаг в этой новой структуре – представить процедуру Pop, аналогичную Push. Эта процедура будет всегда выталкивать верхний элемент стека в D7:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Pop Stack into Secondary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Pop(Size: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move(Size, '(SP)+', 'D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общая идея состоит в том, что все «Pop-Op» подпрограммы могут вызывать ее. Когда это сделано, мы будем иметь оба операнда в регистрах, поэтому мы можем перевести любой нужный нам. Для работы процедуре Convert необходим другой аргумент, имя регистра:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Convert a Data Item from One Type to Another \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Convert(Source, Dest: char; Reg: String);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Source <> Dest then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Source = 'B' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('AND.W #$FF,' + Reg);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Dest = 'L' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L ' + Reg);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая функция выполняет пребразование, но только если текущий тип T1 меньше по размеру, чем желаемый тип T2. Это функция, возвращающая конечный тип, позволяющий нам знать, что она решила:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Promote the Size of a Register Value \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Promote(T1, T2: char; Reg: string): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := T1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if T1 <> T2 then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if (T1 = 'B') or ((T1 = 'W') and (T2 = 'L')) then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T1, T2, Reg);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := T2;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Promote := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, следующая функция приводит два регистра к одному типу:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Force both Arguments to Same Type \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function SameType(T1, T2: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 T1 := Promote(T1, T2, 'D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SameType := Promote(T2, T1, 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти новые подпрограммы дают нам заряд, необходимы нам чтобы разложить PopAdd и PopSub:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate Code to Add Primary to the Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function PopAdd(T1, T2: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Pop(T1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 T2 := SameType(T1, T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenAdd(T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd := T2;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate Code to Subtract Primary from the Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function PopSub(T1, T2: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Pop(T1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 T2 := SameType(T1, T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenSub(T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopSub := T2;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После всех этих приготовлений, в конечном результате нет почти ничего кульминационного. Снова, вы можете видеть что логика совершенно проста. Все что делают эти две подпрограммы – выталкивают вершину стека в D7, приводят два операнда к одному размеру и затем генерируют код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на две новые подпрограммы генерации кода GenAdd и GenSub. Они являются остаточной формой оригинальных PopAdd и PopSub. Т.е. они являются чистыми генераторами кода, производящими сложение и вычитание регистров:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add Top of Stack to Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenAdd(Size: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD.' + Size + ' D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Subtract Primary from Top of Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenSub(Size: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB.' + Size + ' D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG.' + Size + ' D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, я соглашусь с вами: я выдал вам множество подпрограмм с тех пор, как мы в последний раз протестировали код. Но вы должны признать, что каждая новая подпрограмма довольно проста и ясна. Если вам (как и мне) не нравится тестировать так много новых подпрограмм одновременно все в порядке. Вы можете заглушить подпрограммы типа Convert, Promote и SameType так как они не считывают входной поток. Вы не получите корректный код, конечно, но программа должна работать. Затем постепенно расширяйте их.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При тестировании программы не забудьте, что вы сначала должны объявить некоторые переменные а затем начать «тело» программы с "B" в верхнем регистре (для BEGIN). Вы должны обнаружить, что синтаксический анализатор обрабатывает любые аддитивные выражения. Как только все подпрограммы преобразования будет введены, вы должны увидеть, что генерируется правильный код и код для преобразования типов вставляется в нужных местах. Попробуйте смешивать переменные различных размеров а также литералы. Удостоверьтесь, что все работает правильно. Как обычно, хорошо было бы попробовать некоторые ошибочные выражения и посмотреть, как компилятор обрабатывает их.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Почему так много процедур?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту вы можете подумать, что я зашел слишком далеко в смысле глубоко вложенных процедур. В этом несомненно есть большие накладные расходы. Но в моем безумии есть смысл. Как в случае с UnOp, я заглядываю вперед на время, когда мы захотим генерировать лучший код. С таким способом организации кода мы можем достичь этого без значительных изменений в программе Например, в случаях, где значение помещенное в стек не должно преобразовываться, все же лучше использовать инструкцию «вытолкнуть и сложить». Если мы решим проверять такие случаи, мы можем включить дополнительные тесты в PopAdd и PopSub не изменяя что-либо еще.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Мультипликативные выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуры для работы с мультипликативными операторами почти такие же. Фактически, на первом уровне они почти идентичны, так что я просто покажу их здесь без особых фанфар. Первая – наша общая форма для Factor, которая включает подвыражения в скобках:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Expression: char; Forward;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Factor: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = '(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := Load(GetName)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor := LoadNum(GetNum);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Multiply \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Function Multiply(T1: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('*');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Multiply := PopMul(T1, Factor);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize and Translate a Divide \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Divide(T1: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('/');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 DIvide := PopDiv(T1, Factor);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Math Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function Term: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Typ: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Typ := Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Typ := Multiply(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Typ := Divide(Typ);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term := Typ;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти подпрограммы соответствуют аддитивным почти полностью. Как и прежде, сложность изолирована в PopMul и PopDiv. Если вам захочется протестировать программу прежде чем мы займемся ими, вы можете написать их пустые версии, аналогичные PopAdd и PopSub. И снова, код не будет корректным в данный момент, но синтаксический анализатор должен обрабатывать выражения произвольной сложности.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Умножение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы убедились, что сам синтаксический анализатор работает правильно, мы должны выяснить, что необходимо сделать для генерации правильного кода. С этого места дела становятся немного труднее так как правила более сложные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте сперва возьмем случай умножения. Эта операция аналогична «addops» в том, что оба операнда должны быть одного и того же размера. Она отличается в трех важных отношениях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип произведения обычно не такой же как тип двух операндов. Для произведения двух слов мы получаем в результате длинное слово.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 68000 не поддерживает умножение 32 x 32, так что необходим вызов подпрограммы для программного умножения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Он также не поддерживает умножение 8 x 8, поэтому байтовые операнды должны быть переведены до слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Действия, которые мы должны выполнить, лучше всего показывает следующая таблица:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T2 B W L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 B Преобразовать D0 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преобразовать D7 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MULS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = W Преобразовать D0 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MULS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L Преобразовать D0 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR MUL32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 W Преобразовать D7 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MULS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L MULS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L Преобразовать D0 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR MUL32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR MUL32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR MUL32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L JSR MUL32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта таблица показывает действия, предпринимаемые для каждой комбинации типов операндов. Есть три вещи, на которые необходимо обратить внимание: во-первых, мы предполагаем, что существует библиотечная подпрограмма MUL32, которая выполняет 32 x 32 умножение, оставляя 32-битное (не 64) произведение. Если в процессе этого происходит переполнение мы игнорируем его и возвращаем только младшие 32 бита.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Во-вторых, заметьте, что таблица симметрична. Наконец, обратите внимание, что произведение это всегда длинное слово, за исключением случая когда оба операнда байты. (Стоит заметить, между прочим, что это означает что результатом многих выражений будет длинное слово, нравится нам это или нет. Возможно идея перевода всех их заранее не была уж такой возмутительной, в конце концов!)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь ясно, что мы должны будем генерировать различный код для 16-разрядного и 32-разрядного умножения. Для этого лучше всего иметь отдельные подпрограммы генерации кода для этих двух случаев:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply Top of Stack by Primary (Word) \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenMult;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS D7,D0')\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply Top of Stack by Primary (Long) \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenLongMult;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('JSR MUL32');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исследование кода ниже для PopMul должно убедить вас, что условия в таблице выполнены:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate Code to Multiply Primary by Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function PopMul(T1, T2: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var T: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Pop(T1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 T := SameType(T1, T2);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T, 'W', 'D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T, 'W', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if T = 'L' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenLongMult\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenMult;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if T = 'B' then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopMul := 'W'\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopMul:= 'L';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, подпрограмма начинается совсем как PopAdd. Два аргумента приводятся к тому же самому типу. Два вызова Convert заботятся о случаях, когда оба операнда – байты. Сами данные переводятся до слова, но подпрограмма помнит тип чтобы назначать корректный тип результату. В заключение мы вызываем одну из двух подпрограмм генерации кода и затем назначаем тип результата. Не слишком сложно, действительно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я полагаю, что сейчас вы уже тестируете программу. Попробуйте все комбинации размеров операндов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Деление\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Случай с делением совсем не так симметричен. У меня также есть для вас некоторые плохие новости:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все современные 16-разрядные процессоры поддерживают целочисленное деление. Спецификации изготовителей описывают эту операцию как 32 x 16 бит деление, означающее, что вы можете разделить 32-разрядное делимое на 16-разрядный делитель. Вот плохая новость:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Они вам лгут!!!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы не верите в это, попробуйте разделить любое большое 32-разрядное число (это означает, что оно имеет ненулевые биты в старших 16 разрядах) на целое число 1. Вы гарантированно получите исключение переполнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблема состоит в том, что эта команда в действительности требует, чтобы получаемое частное вписывалось в 16-разрядный результат. Этого не случится, если делитель достаточно большой. Когда любое число делится на единицу, частное будет конечно тем же самым, что и делимое.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С начала времен (ну во всяком случае компьютерных) архитекторы ЦПУ предусматривали этот маленький подводный камень в схеме деления. Это обеспечивает некоторую симметрию, так как это своего рода инверсия способа каким работает умножение. Но так как единица – это совершенно допустимое (и довольно частое) число для использования в качестве делителя, делению, реализованному аппаратно, требуется некоторая помощь от программистов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подразумевает следующее:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тип частного всегда должен быть того же самого типа, что и делимое. Он независим от делителя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несмотря на то, что ЦПУ поддерживает деление длинного слова, аппаратно предоставленной инструкции можно доверить только делимые байт и слово. Для делимых типа длинное слово нам необходима другая библиотечная подпрограмма, которая может возвращать длинный результат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это похоже на работу для другой таблицы, для суммирования требуемых действий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T2 B W L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 B Преобразовать D0 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DIVS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = B Преобразовать D0 в W\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DIVS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = W Преобразовать D0 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR DIV32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 W Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DIVS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = B Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 DIVS\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = W Преобразовать D0 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR DIV32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR DIV32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = B Преобразовать D7 в L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 JSR DIV32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = W JSR DIV32\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Result = L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Вы можете задаться вопросом, почему необходимо выполнять 32-разрядное деление, когда делимое, скажем, всего лишь байт. Так как число битов в результате может быть только столько, сколько и в делимом, зачем беспокоиться? Причина в том, что если делитель – длинное слово и в нем есть какие-либо установленные старшие разряды, результат деления должен быть равен нулю. Мы не смогли бы получить его, если мы используем только младшее слово делителя)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий код предоставляет корректную функцию для PopDiv:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Generate Code to Divide Stack by the Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function PopDiv(T1, T2: char): char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Pop(T1);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T1, 'L', 'D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if (T1 = 'L') or (T2 = 'L') then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T2, 'L', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenLongDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopDiv := 'L';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Convert(T2, 'W', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GenDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopDiv := T1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Две подпрограммы генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Top of Stack by Primary (Word) \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D0,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Move('W', 'D7', 'D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Top of Stack by Primary (Long) \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GenLongDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('JSR DIV32');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, мы предполагаем, что DIV32 оставляет результат (длинное слово) в D0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ОК, установите новые процедуры деления. Сейчас у вас должна быть возможность генерировать код для любого вида арифметических выражений. Погоняйте ее!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Завершение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец-то, в этой главе мы узнали как работать с переменными (и литералами) различных типов. Как вы можете видеть, это не было слишком сложно. Фактически, в каком-то отношении большая часть кода выглядит даже еще проще, чем это было в более ранних программах. Только операторы умножения и деления требуют небольших размышлений и планирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основная идея, которая облегчила нам жизнь, – идея преобразования процедур типа Expression в функции, возвращающие тип результата. Как только это было сделано, мы смогли сохранить ту же самую общую структуру компилятора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не буду притворяться, что мы охватили каждый одиночный аспект этой проблемы. Я удобно проигнорировал беззнаковую арифметику. Из того, что мы сделали, я думаю вы можете видеть, что их включение не добавляет никаких дополнительных проблем, просто дополнительные проверки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я так же игнорировал логические операторы And, Or и т.д. Оказывается, их довольно легко обрабатывать. Все логические операторы – побитовые операции, так что они симметричны и, следовательно, работают в том же самом режиме, что и PopAdd. Однако, имеется одно отличие: если необходимо расширить длину слова для логической переменной, расширение должно быть сделано как число без знака. Числа с плавающей точкой, снова, являются простыми для обработки... просто еще несколько процедур, которые будут добавлены в run-time библиотеку или, возможно, инструкции для математического сопроцессора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно более важно, что я также отделил проблему контроля соответствия типов, в противоположность преобразованию. Другими словами, мы разрешили операции между переменными всех комбинаций типов. Вообще, это не будет верным... конечно вы не захотите прибавить целое число, например, к строке. Большинство языков также не позволят вам смешивать символьные и целочисленные переменные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова, в действительности в этом случае нет никаких новых проблем для рассмотрения. Мы уже проверяем типы двух операндов... в основном эти проверки выполняются в процедурах типа SameType. Довольно просто включить вызов обработчика ошибок если типы двух операндов несовместимы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В общем случае мы можем рассматривать каждый одиночный оператор как обрабатываемый отдельной процедурой, в зависимости от типа двух операндов. Это просто, хотя и утомительно, реализовать просто создав таблицу переходов с типами операндов как индексами. В Паскале эквивалентная операция включала бы вложенные операторы Case. Некторые из вызываемых процедур могли бы тогда быть простыми подпрограммами обработки ошибок, в то время как другие могли бы выполнять любые виды преобразований, необходимые нам. При добавлении нами типов, число процедур будет возрастать в геометрической прогрессии, но это все равно не неприемлемо большое число процедур.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сдесь же мы свернули такую таблицу переходов в гораздо меньшее количество процедур, просто используя симметрию и другие упрощающие правила.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Приводить или не приводить\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае, если до вас еще не дошло, уверен дойдет, что TINY и KISS возможно не будут строго типизированными языками, так как я разрешил автоматическое смешивание и преобразование почти любых типов. Что поднимает следующий вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это действительно то, что мы хотим сделать?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ зависит от того, какого рода язык вам нужен и как вы хотели чтобы он себя вел. Мы не обращались к проблеме того, когда разрешить или когда запретить использование операций, включающих различные типы данных. Другими словами, какова должна быть семантика нашего компилятора? Хотим ли мы выполнять автоматическое преобразование типов для всех случаев, в некоторых случаях или не выполнять совсем?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте приостановимся здесь, чтобы подумать об этом немного больше. В этом нам поможет небольшой исторический обзор.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Fortran II поддерживал только два простых типа данных: Integer и Real. Он разрешал неявное преобразование типов между real и integer типами во время присваивания, но не в выражениях. Все элементы данных (включая литеральные константы) справа оператора присваивания должны были быть одинакового типа. Это довольно сильно облегчало дела... гораздо проще, чем то, что мы делали здесь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это было изменено в Fortran IV для поддержки «смешанной» арифметики. Если выражение имело любые real элементы, все они преобразовывались в real и само выражение было real. Для полноты, предоставлялись функции для явного преобразования из одного типа в другой, чтобы вы могли привести выражение в любой тип.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это вело к двум вещам: код, который был проще для написания и код, который был менее эффективен. Из-за это неаккуратные программисты должны были писать выражения с простыми константами типа 0 и 1, которые компилятор должен был покорно компилировать для преобразования во время выполнения. Однако, система работала довольно хорошо, что показывало что неявное преобразование типов – Хорошая Вещъ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Си – также слабо типизированный язык, хотя он поддерживает большее количество типов. C не будет жаловаться, если вы например попытаетесь прибавить символ к целому числу. Частично, в этом помогает соглашение Си о переводе каждого символа в число когда оно загружается или передается в списке параметров. Это совсем немного упрощает преобразование. Фактически, в подмножестве компиляторов Си, которые не поддерживают длинные или с плавающей точкой числа мы возвращаемся к нашей первой нехитрой попытке: каждая переменная получает одинаковое представление как только загружается в регистр. Жизнь становится значительно проще!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предельным языком в направлении автоматического преобразования типов является PL/I. Этот язык поддерживает большое количество типов данных, и вы можете свободно смешивать их все. Если неявное преобразование Fortran казалось хорошим, то таковое в PL/I было бы Небесами, но оно скорее оказалось Адом! Проблема состояла в том, что с таким большим количеством типов данных должно сущестовать большое количество различных преобразований и, соответственно, большое количество правил того, как смешиваемые операнды должны преобразовываться. Эти правила стали настолько сложными, что никто не мог запомнить какие они! Множество ошибок в программах на PL/I имели отношение к непредвиденным и нежелательным преобразованиям типов. Слишком хорошо тоже нехорошо!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Паскаль, с другой стороны, является языком, который «строго типизирован», что означает, что вы вообще не можете смешивать типы даже если они отличаются только именем, хотя они и имеют тот же самый базовый тип! Никлаус Вирт сделал Паскаль строго типизированным чтобы помочь программисту избежать проблем и эти ограничения действительно защитили многих программистов от самих себя, потому что компилятор предохранял его от глупых ошибок. Лучше находить ошибки при компиляции, чем на этапе отладки. Те же самые ограничения могут также вызвать расстройства когда вам действительно нужно смешивать типы и они заставляют бывших C-программистов лезть на стену.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Даже в этом случае, Паскаль разрешает некоторые неявные преобразования. Вы можете присвоить целое значение вещественному. Вы можете также смешивать целые и вещественные типы в выражениях типа Real. Целые числа будут автоматически приведены к вещественным, как и в Fortran. (и с теми же самыми скрытыми накладными расходами во время выполнения).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы не можете, однако, преобразовывать наоборот из вещественного в целое без применения явной функции преобразования Trunc. Теория здесь в том, что так как числовое значение вещественного числа обязательно будет изменено при преобразованиии (дробная часть будет потеряна), это не должно быть сделано в «секрете» от вас.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В духе строгого контроля типов Паскаль не позволит вам смешивать Char и Integer переменные без применения явных функций приведения Chr и Ord.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Turbo Pascal также включает типы Byte, Word и LongInt. Первые два в основном то же самое, что и беззнаковое целое. В Turbo они могут быть свободно смешаны с переменными типа Integer и Turbo автоматически выполнит преобразование. Однако существуют проверки времени выполнения, предохряняющие вас от переполнения или иного способа получения неправильного ответа. Заметьте, что вы все еще не можете смешивать типы Byte и Char, даже при том, что они имеют то же самое внутреннее представление.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пределом среди строго типизированных языков является Ada, который не рязрешает никаких невных преобразований типов вообще, и также не разрешает смешанную арифметику. Позиция Jean Ichbiah в том, что преобразования стоят времени выполнения и вам нельзя позволить платить такую цену на скрытый манер. Вынуждая программиста явно запрашивать преобразование типов вы делаете более очевидным то, что здесь могут быть вовлечены затраты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я использовал другой язык со строгим контролем типов, небольшой восхитительный язык, названный Whimsical, от Джона Спрея. Хотя Whimsical предназначен быть языком системного программирования, он также требует каждый раз явного преобразования. В нем никогда не выполняются никакие автоматические преобразования, даже те, которые поддерживаются в Паскале.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой подход имеет некоторые преимущества: компилятор никогда не должен предполагать, что делать: программист всегда говорит ему точно, что он хочет. В результате, появляется почти однозначное соответствие между исходным кодом и компилированным кодом, и компилятор Джона производил очень компактный код.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, я иногда находил явные преобразования болезненными. Если я хочу, например, прибавить единицу к символу, или сложить ее с маской, необходимо выполнить массу преобразований. Если я сделаю это неправильно единственным сообщением об ошибке будет «Типы не совместимы». Как это случается, специфическая реализация Джоном этого языка в его компиляторе не сообщает вам точно, какие типы несовместимы... он только сообщает вам, в какой строке произошла ошибка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я должен признать, что большинство моих ошибок с этим компилятором были ошибками такого типа, и я потратил много времени с компилятором Whimsical, пытаясь всего-лишь выяснить в каком месте строки я ее допустил. Единственный реальный способ исправить ошибку это продолжать исправления до тех пор, пока что-нибудь не заработает.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что мы должны сделать в TINY и KISS? Для первого я имею ответ: TINY будет поддерживать только типы Char и Integer и мы будем использовать прием C непосредственно переводя Char в Integer. Это означает, что компилятор TINY будет значительно проще, чем то, что мы уже сделали. Необходимость преобразования типов в выражении спорна, так как ни одно из них не требуется! Так как длинное слово не будет поддерживаться, нам также будут не нужны подпрограммы MUL32 и DIV32, ни логики для выяснения когда их вызывать. Мне это нравится!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 KISS, с другой стороны будет поддерживать тип Long.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Должен ли он поддерживать и знаковую и беззнаковую арифметику? Ради простоты я предпочел бы нет. Это добавляет совсем немного сложности в преобразования типов. Даже Никлаус Вирт удалили беззнаковые числа (Cardinal) из его нового языка Оберон, с тем аргументом, что 32-разрядного целого числа в любом случае должно быть достаточно всем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но KISS предполагается быть языком системного программирования, что означает, что у нас должна быть возможность выполнять любые действия, которые могут быть выполнены на ассемблере. Так как 68000 поддерживает обе разновидности целых чисел, я полагаю что KISS тоже должен. Мы видели, что логические операции должны быть способны расширять целые числа беззнаковым способом, поэтому процедуры беззнакового преобразования нужны в любом случае.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Заключение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На этом завершается наш урок по преобразованиям типов. Жаль, что вы должны были так долго ждать его, но, надеюсь, вы чувствуете, что он того стоил.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нескольких следующих главах мы расширим простые типы, включив поддержку массивов и указателей и посмотрим, что делать со строками. Это позволит довольно успешно завершить основную часть этой серии. После этого я дам вам новые версии компиляторов TINY и KISS, а затем мы начнем рассматривать вопросы оптимизации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидимся.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Назад в будущее\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Могло ли действительно пройти четыре года с тех пор, как я написал четырнадцатую главу этой серии? Действительно ли возможно, что шесть долгих лет прошли с тех пор как я начал ее? Забавно, как летит время когда вы весело его проводите, не так ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я не буду тратить много времени на извинения; просто подчеркну, что это случилось, и приоритеты меняются. За четыре года, начиная с четырнадцатой главы, я сумел стать уволенным, развестись, получить нервный срыв, начал новую каръеру как писатель, начал другую как консультант, двигался, работал на две системы реального времени и вырастил четырнадцать птенцов, трех голубей, шесть опоссумов и утку. Некоторое время синтаксический анализ исходного кода был не слишком высоко в моем списке приоритетов. Не написал ни одной вещи бесплатно, только за деньги. Но я пытаюсь быть верным и понимаю и чувствую свою ответственность перед вами, читателями, закончить то, что начал. Как сказала черепаха в одной из старых историй моего сына, я возможно медленная, но я надежная. Я уверен, что есть люди, стремящиеся увидеть последнюю катушку этого фильма, и я собираюсь дать им ее. Так что, если вы один из тех, кто ждал более или менее терпеливо, что из этого получится, благодарю за ваше терпение. Я приношу извинения за задержку. Давайте продолжим.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Новое начало, старое направление\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подобно многим другим вещам, языки программирования и стили програмирования изменяются со временем. В 1994 году кажется немного анахроничным программировать на Turbo Pascal, когда остальной мир кажется сходит с ума по C++. Также кажется немного странным программировать в классическом стиле, когда остальной мир переключился на объектно-ориентированные методы. Однако, несмотря на четырехлетнюю паузу, было бы слишком тяжело сейчас переключиться, скажем, на C++ с объектной ориентацией. Во всяком случае, Pascal все еще не только мощный язык программирования (фактически больше, чем когда либо), но это и замечательная среда для обучения. Си – известно трудный для чтения язык... он часто был обвиняем, наряду с Forth, как «язык только для записи». Когда я программирую на C++ я трачу по крайней мере 50% своего времени на борьбу с синтаксисом языка а не с концепциями. Сбивающие с толку «&» или "*" могут не только изменить функционирование программы, но также и ее правильность. Наоборот, код Паскаля обычно совершенно ясен и прост для чтения даже если вы не знаете языка. Что вы видите, то вы почти всегда и получите, и мы можем сконцентрироваться на концепциях, а не тонкостях реализации. Я сказал в начале, что целью этой обучающей серии была не генерация самого быстрого в мире компилятора, а изучение основ технологии компиляции, с наименьшими затратами времени на борьбу с синтаксисом языка или другими аспектами реализации программного обеспечения. Наконец, так как многое из того, что мы делаем в этом курсе, составляет программное экспериментирование, важно иметь компилятор и связанную с ним среду, который компилирует быстро и без суеты. По моему мнению наиболее значимым мерилом времени при разработке программного обеспечения является скорость цикла редактирование/компиляция/тестирование. В этом отделе Turbo Pascal – король. Скорость компиляции блестяще быстрая, и продолжает становиться быстрее с каждым выпуском (как им это удается?). Несмотря на крупные усовершенствования в быстродействии компиляции C за последние годы, даже Borland-овский самый быстрый компилятор C/C++ все еще не сравним с Turbo Pascal. Далее, редактор, встроенный в его IDE, средство make, и даже их превосходный умный компоновщик, все дополняют друг друга чтобы получить замечательную среду для быстрой разработки. По всем этим причинам, я собираюсь придерживаться Паскаля в продолжении этой серии. Мы будем использовать Turbo Pascal for Windows, один из компиляторов, предоставляемый Borland Pascal with Objects, версия 7.0. Если у вас нет этого компилятора не волнуйтесь... ничего из того, что мы делаем здесь не будет рассчитано на то, что вы имеете последнюю версию. Использование Windows версии сильно помогает мне, позволяя использовать Clipboard для копирования кода из редактора компилятора в эти документы. Она также должна помочь вам по крайней мере копировать код в обратном направлении.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я думал долго и трудно о том, надо ли представить нашему обсуждению объекты. Я большой защитник объектно-ориентированных методов для всех применений и такие методы определенно имеют свое место в технологии компиляции. Фактически, я написал несколько статей только на эти темы (ссылки 1-3). Но архитектура компилятора, основанного на объектно-ориентированных подходах, значительно отличается от архитектуры более классического компилятора, который мы строим. Кроме того, коней на переправе не меняют. Как я сказал, изменяются стили программирования. Кто знает, может быть пройдут еще шесть лет прежде чем мы закончим эти дела, и если мы будем изменять код каждый раз при изменении стиля программирования мы можем никогда не закончить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так что теперь, по крайней мере, я определился продолжать классический стиль в Pascal, хотя мы действительно могли бы обсуждать объекты и объектную ориентацию по ходу дела. Аналогично, целевой машиной останется семейство Motorola 68000. Из всех решений, которые буду приняты здесь, это было самым простым. Хотя я знаю, что многие из вас хотели бы видеть код для 80x86, 68000 является, вообще-то, даже более популярным как платформа для встроенных систем, и это то применение ради которого это все изначально и начиналось. Компилируя для PC, платформы MSDOS, мы должны были бы иметь дело со всеми проблемами системных вызовов DOS, форматов компоновщика DOS, файловой системы PC и аппаратными средствами и всеми другие осложнениями среды DOS. Встроенная система, с другой стороны, должна выполняться автономно и я всегда представлял, что для такого вида применений, как альтернатива ассемблеру, язык подобный KISS процветал бы. В любом случае, кто хочет иметь дело с архитектурой 80x86 если они не должны?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из возможностей Turbo Pascal которую я собираюсь серьезно использовать это модули. В прошлом мы должны были делать компромиссы между размером кода, сложностью и функциональными возможностями программы. Многое из нашей работы было по природе компьютерным экспериментированием, рассматриванием только одного аспекта технологии компиляции в один момент времени. Мы делали это чтобы избежать возни с большими программами, исследуя только простые понятия. В процессе, мы заново изобретали колесо и заново программировали те же самые функции больше раз, чем я могу сосчитать. Модули Turbo предоставляют замечательный способ получить функциональность и простоту одновременно: вы пишете многократно используемый код и вызываете его в одной строке. Ваша тестовая программа остается маленькой, но она может делать мощные вещи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из возможностей модулей Turbo Pascal – их блок инициализации. Как в пакете Ada, любой код в основном блоке begin-end модуля выполняется когда программа инициализирована. Как вы увидите позже, это иногда дает нам хорошее упрощение кода. Наша процедура Init, которая была с нами начиная с Главы 1, полностью исчезает когда мы используем модули. Различные подпрограммы в Cradle, другие ключевые возможности нашего подхода, будут распределены по модулям.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Концепция модулей, конечно, ничем не отличается от модулей Си. Однако в C (и C++) интерфейс между модулями происходит через операторы include препроцессора и заголовочные файлы. Как кто-то, кто читал множество прогрограмм других людей на C, я всегда находил это довольно сбивающим с толку. Всегда кажется, что любая структура данных, о который вы бы хотели знать, находится в каком-то другом файле. Модули Turbo проще по той причине, за которую они критикуются некоторыми: интерфейсы функций и их реализации включены в тот же самый файл. В то время, когда эта организация может создать проблемы с защитой кода, она также уменьшает количество файлов наполовину, что не в два раза хуже. Связывание объектных файлов также просто, потому что компилятор Turbo заботится об этом без необходимости в файлах типа make или других механизмах.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Начинаем заново?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Четыре года назад, в Главе 14, я обещал вам, что наши дни повторного изобретения колеса и написания одних и тех же программ на каждом уроке, прошли и что с этого момента мы будем придерживаться более завершенных программ, к которым мы должны просто добавлять новые возможности. Я все еще собираюсь сдержать это обещание; это одна из основных целей использования модулей. Однако, из-за прошествия длительного времени с главы 14, естественно хотелось бы сделать по крайней мере небольшой обзор и в любом случае мы окажемся перед необходимостью сделать довольно обширные изменения кода, чтобы выполнить переход к модулям. Кроме того, если откровенно, после всего этого времени я не могу помнить всех хороших идей, которые я имел в моей голове четыре года назад. Для меня лучший способ вспомнить их – заново пройти некоторые шаги, которые привели нас к Главе 14. Так что я надеюсь, что вы поймете и смиритесь со мной когда мы возвратимся к своим корням, в некотором смысле, и перестроим ядро программы, распределяя подпрограммы по различным модулям, и вытащим сами себя назад к точке где мы были многие луны тому назад. Как всегда бывало, вы увидите все мои ошибки и смены направлений в реальном режиме времени. Пожалуйста, будьте терпеливы... мы доберемся до новых вещей раньше чем вы успеете оглянуться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как в нашем новом подходе мы собираемся использовать множественные модули, мы должны обратиться к проблеме управления файлами. Если вы проследовали через все другие разделы этой обучающей серии, вы знаете, что поскольку наша программа развивается, мы заменяем старые, более простые модули на более совершенные. Это приводит нас к проблеме контроля версий. Почти обязательно будут возникать ситуации, когда мы будем перекрывать простой файл (модуль), но позднее захотим иметь его снова. Данный случай воплощен в нашей склонности к использованию односимвольных имен переменных, ключевых слов и т.д. для проверки основных понятий не захлебываясь в деталях лексического анализатора. Благодаря использованию модулей мы будем намного меньше делать это в будущем. Однако, я не только предполагаю, но я уверен, что мы будем должны сохранять некоторые старые версии файлов для специальных целей, даже при том, что они заменяются более новыми, более совершенными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для решения этой проблемы я предлагаю, чтобы вы создали различные каталоги с различными версиями модулей. Если мы сделаем это правильно, код в каждом каталоге останется само-непротиворечивым. Я в порядке эксперимента создал четыре каталога: SINGLE (для односимвольных экспериментов), MULTI (для, конечно, многосимвольной версии), TINY и KISS.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достаточно сказано о философии и деталях. Давайте продолжим восстановление программы.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Модуль INPUT\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ключевой концепцией, которую мы использовали начиная с первого дня, была идея входного потока с одним предсказывающим символом. Все подпрограммы синтаксического анализа проверяют этот символ, не изменяя его, чтобы решить, что они должны делать дальше. (Сравните этот подход с подходом C/Unix, использующим getchar и unget, и я думаю вы согласитесь, что наш подход проще). Мы начнем нашу экскурсию в будущее перенеся эту концепцию в нашу новую модульную организацию. Первый модуль, соответствующе названный Input, показан ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Input;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Look: char; \{ Lookahead character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar; \{ Read new character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Read New Character From Input Stream \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Read(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Unit Initialization \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, здесь нет ничего очень заумного и конечно ничего сложного, так как он состоит только из одной процедуры. Но мы уже можем видеть как использование модулей дает нам преимущества. Обратите внимание на выполнимый код в блоке инициализации. Этот код «запускает помпу» входного потока для нас, нечто такое мы всегда делали раньше вставляя вызовы GetChar в процедуру Init. На этот раз вызов происходит без каких-либо специальных обращений к ней с нашей стороны, за исключением самого модуля. Как я предсказывал ранее, этот механизм сделает нашу жизнь в будущем значительно проще. Я полагаю это одна из наиболее полезных возможностей Turbo Pascal и я буду сильно на нее полагаться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скопируйте этот модуль в IDE вашего компилятора и откомпилируйте его. Чтобы проверить программу, конечно, нам всегда нужна основная программа. Я использовал следующую, действительно сложную тестовую программу, которую позже мы разовьем в главную для нашего компилятора:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses WinCRT, Input;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на использование предоставляемого Borland модуля WinCRT. Этот модуль необходим, если вы предполагаете использовать стандартные подпрограммы ввода/вывода Паскаля Read, ReadLn, Write и WriteLn, которые мы конечно предполагаем использовать. Если вы забудете включить этот модуль в раздел «uses» вы получите действительно причудливое и непонятное сообщение во время выполнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте также, что мы можем обращаться к предсказывающему символу даже при том, что он не объявлен в основной программе. Все переменные, объявленные в разделе interface модуля, являются глобальными, но они скрыты от любопытных глаз; в какой-то степени мы получаем чуточку сокрытия информации. Конечно, если бы мы писали в объектно-ориентированном стиле, мы не должны были бы позволять обращаться к внутренним переменным модуля снаружи. Но хотя модули Turbo имеют много общего с объектами, мы не собираемся здесь реализовывать объектно ориентированный дизайн или код, так что мы используем Look соответствующее.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Продолжим и сохраним тестовую программу как Main.pas. Чтобы сделать жизнь проще когда файлов будет становиться все больше и больше, вам возможно захотелось бы использовать возможность объявить этот файл как Primary файл компилятора. Таким способом вы можете выполнять программу из любого файла. Иначе, если вы нажимете Cntl-F9 для компиляции и выполнения одного из модулей, вы получите сообщение об ошибке. Вы устанавливаете primary-файл используя главное подменю «Compile» в Turbo IDE.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я тороплюсь отметить, как я делал раньше, что функционально модуль Input является, и всегда был, макетом настоящей версии. В серийной версии компилятора входной поток будет, конечно, скорее исходить из файла, а не клавиатуры. И это почти обязательно включает буферизацию строки, по крайней мере, и более вероятно, довольно большой текстовый буфер для поддержки эффективного дискового ввода/вывода. Хорошая сторона модулей в том, что как и с объектами мы можем делать код модуля таким простым или таким сложным как нам угодно. До тех пор, пока интерфейс, встроенный в общедоступные процедуры и предсказывающий символ не изменяются, остальная часть программы абсолютно незатрагивается. И так как модули компилируются, а не просто включаются, время необходимое для связывания их вместе практически равно нулю. Снова, результат таков, что мы можем получить все преимущества сложной реализации без необходимости возиться с кодом как лишним багажом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующих главах я предполагаю предоставить полноценный IDE для компилятора KISS используя настоящее Windows приложение, сгенерированное с помощью среды разработки Borland OWL. Сейчас, тем не менее, мы удовлетворим мое первое правило: Делать Это Проще.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Модуль OUTPUT\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, каждая приличная программа должна выводить результат и наша не исключение. Наши подпрограммы вывода включают функции Emit. Код для соответствующего модуля показан дальше:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Output;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string); \{ Emit an instruction \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string); \{ Emit an instruction line \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 const TAB = ^I;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Emit an Instruction \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Emit(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Write(TAB, s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Emit an Instruction, Followed By a Newline \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure EmitLn(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Emit(s);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Заметьте, что этот модуль не имеет раздела инициализации, так что он не требует блока begin.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проверьте этот модуль с помощью следующей основной программы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Test;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses WinCRT, Input, Output, Scanner, Parser;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn('MAIN:");\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('Hello, world!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увидели ли вы что-либо, что удивило вас? Вы возможно были удивлены видеть, что вам было необходимо что-то набрать даже хотя основная программа не требует никакого ввода. Дело в разделе инициализации модуля Input, который все еще требует поместить что-либо в предсказывающий символ. Жаль, нет никакого способа выйти из этого, или скорее, мы не хотим выходить. За исключением простых тестовых случаев, как этот, нам всегда будет необходим допустимый предсказывающий символ, так что самое лучшее, что мы можем сделать с этой «проблемой» это... ничего.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно более удивительно то что символ TAB не имеет никакого эффекта; наша строка «инструкций» начинается с первой колонки так же как и фальшивая метка... Правильно: WinCRT не поддерживает табуляцию. У нас проблема.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть несколько способов, с помощью которых мы можем решить эту проблему. Один из вариантов того что мы можем сделать – просто игнорировать ее. Каждый ассемблер, который я когда либо использовал, резервируют колонку 1 для меток и взбунтуется когда увидит, что в ней начинаются инструкции. Так что, по крайней мере, мы должны сдвинуть инструкции на одну колонку чтобы сделать ассемблер счастливым. Это достаточно просто сделать: просто измените в процедуре Emit строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Write(TAB, s);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 на\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Write(' ', s);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я должен признать что сталкивался с этой проблемой раньше и находил себя меняющим свое мнение так часто как хамелеон меняет цвет. Для наших целей, 99% которых будет проверка выходного кода при выводе на CRT, было бы хорошо видеть аккуратно сгруппированный «объектный» код. Строка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SUB1: MOVE #4,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 просто выглядит более опрятно, чем отличающийся, но функционально идентичный код:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 SUB1: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE #4,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В тестовой версии моего кода я включил более сложную версию процедуры PostLabel, которая позволяет избежать размещения меток на раздельных строках, задерживая печать метки чтобы она оказалась на той же самой строке, что и связанная инструкция. Не позднее чем час назад, моя версия модуля Output предоставляла полную поддержку табуляции с использованием внутренней переменной счетчика столбцов и подпрограммы для ее управления. Я имел некоторый довольно изящный код для поддержки механизма табуляции с минимальным увеличением кода. Было ужасное искушение показать вам эту «красивую» версию, единственно чтобы покрасоваться элегантностью.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, код «элегантной» версии был значительно более сложным и большим. После этого у меня появилась вторая мысль. Несмотря на наше желание видеть красивый вывод, неизбежный факт то, что две версии MAIN: фрагменты кода, показанные выше функционально идентичны; ассемблер, который является конечной целью кода, не интересует какую версию он получает, за исключением того, что красивая версия будет содержать больше символов, следовательно будет использовать больше дискового пространства и дольше ассемблироваться. Но красивая версия не только генерирует больше кода, но дает больший выходной файл, с гораздо большим количество пустых символов чем минимально необходимо. Когда вы посмотрите на это с такой стороны, то не трудно будет решить какой подход использовать, не так ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То что наконец решило для меня этот вопрос было напоминанием считаться с моей первой заповедью: KISS. Хотя я был довольно горд всеми своими изящными приемчиками для реализации табуляции, я напомнил себе, что перефразируя сенатора Барри Голдватера, элегантность в поисках сложности не является достоинством. Другой мудрый человек однажды написал: «Любой идиот может разработать Роллс-Ройс. Требуется гений, чтобы разработать VW». Так что изящная, дружественная табуляции версия Output в прошлом, и то, что вы видите, это простая компактная VW версия.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Модуль ERROR\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш следующий набор подпрограмм обрабатывает ошибки. Чтобы освежить вашу память мы возьмем подход, заданный Borland в Turbo Pascal – останавливаться на первой ошибке. Это не только значительно упрощает наш код, полностью устраняя назойливую проблему восстановления после ошибок, но это также имеет намного больший смысл, по моему мнению, в интерактивной среде. Я знаю, что это может быть крайней позицией, но я считаю практику сообщать обо всех ошибках в программе анахронизмом, пережитком со времен пакетной обработки. Пришло время прекратить такую практику. Так вот.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем оригинальном Cradle мы имели две процедуры обработки ошибок: Error, которая не останавливалась, и Abort, которая останавливалась. Но я не думаю, что мы когда-либо найдем применение процедуре, которая не останавливается, так что в новом, тощем и скромном модуле Errors, показанном ниже, процедура Error занимает место Abort.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Errors;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write error Message and Halt \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Error(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 WriteLn(^G, 'Error: ', s, '.');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Halt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Write «<something> Expected» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expected(s: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error(s + ' Expected');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Как обычно, вот программа для проверки:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Test;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses WinCRT, Input, Output, Errors;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы заметили, что строка «uses» в нашей основной программе становится длиннее? Это нормально. В конечной версии основная программа будет вызывать процедуры только из нашего синтаксического анализатора, так что раздел uses будет иметь только пару записей. Но сейчас возможно самое лучшее включить все модули, чтобы мы могли протестировать процедуры в них.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Лексический и синтаксический анализ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Классическая архитектура компилятора основана на отдельных модулях для лексического анализатора, который предоставляет лексемы языка, и синтаксического анализатора, который пытается определить смысл токенов как синтаксических элементов. Если вы еще не забыли что мы делали в более ранних главах, вы вспомните, что мы не делали ничего подобного. Поскольку мы используем предсказывающий синтаксический анализатор, мы можем почти всегда сказать, какой элемент языка следует дальше, всего-лишь исследуя предсказывающий символ. Следовательно, нам не нужно предварительно выбирать токен, как делал бы сканер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но даже хотя здесь и нет функциональной процедуры, названной «Scanner», все еще имеет смысл отделить функции лексического анализа от функций синтаксического анализа. Так что я создал еще два модуля, названных, достаточно удивительно, Scanner и Parser. Модуль Scanner содержит все подпрограммы, известные как распознаватели. Некоторые из них, такие как IsAlpha, являются чисто булевыми подпрограммами, которые оперируют только предсказывающим символом. Другие подпрограммы собирают токены, такие как идентификаторы и числовые константы. Модуль Parser будет содержать все подпрограммы, составляющие синтаксический анализатор с рекурсивным спуском. Общим правилом должно быть то, что модуль Parser содержит всю специфическую для языка информацию; другими словами, синтаксис языка должен полностью содержаться в Parser. В идеальном мире это правило должно быть верным в той степени, что мы можем изменять компилятор для компиляции различных языков просто заменяя единственный модуль Parser.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На практике, дела почти никогда не бывают такими чистыми. Все есть небольшая «утечка» синтаксических правил также и в сканер. К примеру, правила составления допустимого идентификатора или константы могут меняться от языка к языку. В некоторых языках правила о комментариях разрешают им быть отфильтрованными в сканере, в то время как другие не разрешают. Так что на практике оба модуля вероятно придут к тому, что будут иметь языко-зависимые компоненты, но изменения, необходимые для сканнера, должны быть относительно тривиальными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь вспомните, что мы использовали две версии подпрограмм лексического анализатора: одна, которая поддерживала только односимвольные токены, которую мы использовали в ряде наших тестов, и другая, которая предоставляет полную поддержку многосимвольных токенов. Теперь, когда мы разделяем нашу программу на модули, я не ожидаю многого от использования односимвольной версии, но не потребуется многого, чтобы предусмотреть их обе. Я создал две версии модуля Scanner. Первая, названная Scanner1, содержит односимвольную версию подпрограмм распознавания:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Scanner1;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses Input, Errors;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNumber: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Numeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alphanumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlnum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlnum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addition Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+','-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Multiplication Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*','/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match One Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := UpCase(Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNumber: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNumber := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий фрагмент кода основной программы обеспечивает хорошую проверку лексического анализатора. Для краткости я включил здесь только выполнимый код; остальное тоже самое. Не забудьте, тем не менее, добавить имя Scanner1 в раздел «uses»:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Write(GetName);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Match('=');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Write(GetNumber);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Match('+');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 WriteLn(GetName);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот код распознает все предложения вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x=0+y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где x и y могут быть любыми односимвольными именами переменных и 0 любой цифрой. Код должен отбросить все другие предложения и выдать осмысленное сообщение об ошибке. Если это произошло, тогда вы в хорошей форме и мы можем продолжать.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Модуль SCANNER\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая, и намного более важная, версия лексического анализатора, та которая обрабатывает многосимвольные токены, которые должны иметь все настоящие языки. Только две функции, GetName и GetNumber отличаются в этих двух модулях, но только чтобы убедиться, что здесь нет никаких ошибок, я воспроизвел здесь весь модуль. Это модуль Scanner:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Scanner;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses Input, Errors;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlNum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNumber: longint;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alpha Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlpha(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlpha := UpCase(c) in ['A'..'Z'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Numeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsDigit(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsDigit := c in ['0'..'9'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Alphanumeric Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAlnum(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAlnum := IsAlpha(c) or IsDigit(c);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize an Addition Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+','-'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Recognize a Multiplication Operator \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsMulop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsMulop := c in ['*','/'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Match One Character \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Match(x: char);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look = x then GetChar\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else Expected('''' + x + '''');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get an Identifier \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetName: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var n: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsAlpha(Look) then Expected('Name');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAlnum(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := n + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetName := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNumber: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var n: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := '';\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := n + Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNumber := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таже самая тестовая программа проверит также и этот сканер. Просто измените раздел «uses» для использования Scanner вместо Scanner1. Теперь у вас должна быть возможность набирать многосимвольные имена и числа.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Решения, решения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несмотря на относительную простоту обоих сканеров, много идей вошло в них и много решений было сделано. Я хотел бы поделиться этими мыслями с вами сейчас чтобы вы могли принимать свои собственные решения, соответствующие вашему приложению. Сначала заметьте, что обе версии GetName переводят входные символы в верхний регистр. Очевидно, здесь было принято проектное решение, и это один из тех случаев, когда синтаксис языка распределяется по лексическому анализатору. В языке Си регистр символов имеет значение. Для такого языка мы, очевидно, не сможем преобразовывать символы в верхний регистр. Дизайн, который я использую, предполагает язык, подобный Pascal, в котором регистр символов не имеет значения. Для таких языков проще идти вперед и преобразовывать все идентификаторы в верхний регистр в лексическом анализаторе, так что мы не должны волноваться позднее, когда вы сравниваем строки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы могли бы даже пойти дальше и преобразовывать символы в верхний регистр прямо когда они заходят, в GetChar. Этот метод также работает, и я использовал его в прошлом, но он слишком ограничивающий. В частности, он также преобразует символы, которые могут быть частью строк в кавычках, что не является хорошей идеей. Так что если вы вообще собираетесь преобразовывать символы в верхний регистр, GetName подходящее место сделать это.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что функция GetNumber в этом сканере возвращает строку, так же как и GetName. Это одна из тех вещей, относительно которых я колебался почти что ежедневно, и последнее колебание было всего десять минут назад. Альтернативный подход и подход, который я использовал много раз в прошлых главах возвращает целочисленный результат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оба подхода имеют свои преимущества. Так как мы выбираем число, метод, который немедленно приходит на ум – возвращать его как целое число. Но имейте ввиду, что возможно число будет использоваться в операторе вывода который возвращает его во внешний мир. Кто-то, или мы или код, скрытый внутри оператора вывода, окажется перед необходимостью снова преобразовывать число обратно в строку. Turbo Pascal включает такие подпрограммы преобразования строк, но зачем использовать их если мы не должны? Зачем преобразовывать число из строковой в целочисленную форму только для того, чтобы конвертировать его обратно в генераторе кода, всего несколько операторов спустя?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме того, как вы скоро увидите, нам будет необходимо временное место для хранения токена, который мы извлекли. Если мы обрабатываем числа в их строковой форме, мы можем сохранять значение и переменной и числа в той же самой строке. В противном случае мы должны создать вторую, целочисленную переменную.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, мы обнаружим, что обработка числа как строки фактически уничтожает любую возможность дальнейшей оптимизации. Когда мы доберемся до точки, где мы начнем заниматься генерацией кода, мы столкнемся со случаями, в которых мы выполняем вычисления с константами. Для таких случаев действительно глупо генерировать код, выполняющий арифметику с константами во время выполнения. Гораздо лучше позволить синтаксическому анализатору выполнять арифметику во время компиляции и просто кодировать результат. Чтобы сделать это нам необходимо сохранять константы как целые числа а не строки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В конце концов обратно к строковому подходу меня склонило энергичное тестирование KISS, плюс напоминание самому себе, что мы тщательно избегаем проблем эффективности кода. Одна из вещей, которые заставляют нашу нехитрую схему синтаксического анализа работать, без сложностей «настоящего» компилятора, это то, что мы прямо сказали что мы не затрагиваем эффективность кода. Это дает нам массу свободы выполнять работу простейшим путем а не эффективнейшим, и эту свободу мы должны стремиться не потерять, не смотря на призывы к эффективности звучащие в наших ушах. В дополнение к тому, что я большой сторонник философии KISS я также защитник «ленивого программирования», что в этом контексте означает не программировать что-либо пока вы не нуждаетесь в этом. Как говорит П. Дж. Плоджер «никогда не откладывайте на завтра то, что вы можете отложить насовсем». Годами писался код, предоставлявший возможности, которые не были никогда использованы. Я научился этому сам на горьком опыте. Так что вывод таков: мы не будем конвертировать в целое число потому, что это нам не нужно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для тех из вас, что все еще думает, что нам может быть нужна целочисленная версия (и действительно она может нам понадобиться), вот она:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Get a Number (integer version) \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function GetNumber: longint;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var n: longint;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := 0;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if not IsDigit(Look) then Expected('Integer');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsDigit(Look) do begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 n := 10 * n + (Ord(Look) – Ord('0'));\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetNumber := n;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы могли бы отложить ее, как я предполагаю, на черный день.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Синтаксический анализ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту мы распределили все подпрограммы, составляющие наш Cradle, в модули, которые мы можем вытаскивать когда они необходимы. Очевидно, они будут развиваться дальше когда мы снова продолжим процесс восстановления, но большая часть их содержимого и несомненно архитектура, которую они подразумевают, определена. Остается воплотить синтаксис языка в модуль синтаксического анализа. Мы не будем делать многого из этого в этой главе, но я хочу сделать немного просто чтобы оставить вас с хорошим чувством, что мы все еще знаем что делаем. Так что прежде, чем мы продолжим давай сгенерируем синтаксический анализатор достаточный только для обработки одиночного показателя в выражении. В процессе мы также обнаружим, что по необходимости создали также модуль генератора кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Помните самую первую главу этой серии? Мы считывали целочисленное значение, скажем n, и генерировали код для его загрузки в регистр D0 через move:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE #n,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Немного погодя, мы повторили этот процесс для переменной,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X(PC),D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а затем для показателя, который может быть и константой и переменной. В память о прошлом, давайте повторим этот процесс Определите следующий новый модуль:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit Parser;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses Input, Scanner, Errors, CodeGen;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConstant(GetNumber);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как вы можете видеть, этот модуль вызывает процедуру LoadConstant, которая фактически выполняет вывод ассемблерного кода. Модуль также использует новый модуль CodeGen. Этот шаг представляет последнее главное изменение в нашей архитектуре с более ранних глав: перемещение машино-зависимого кода в отдельный модуль. Если я дойду до конца, вне CodeGen не будет ни одной строчки кода, которая указывала бы на то, что мы нацелены на процессор 68000. И это то место, которое показывает, что моя цель достижима.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для тех из вас, кто желает, чтобы я использовал архитектуру 80x86 (или любую другую) вместо 68000, вот мой ответ: просто замените CodeGen на подходящий для вашего ЦПУ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока наш генератор кода содержит только одну процедуру. Вот этот модуль:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit CodeGen;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses Output;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConstant(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load the Primary Register with a Constant \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConstant(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + n + ',D0' );\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Скопируйте и откомпилируйте этот модуль и выполните следующую основную программу:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 program Main;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses WinCRT, Input, Output, Errors, Scanner, Parser;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот он, сгенерированный код, такой как мы и надеялись.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, я надеюсь, вы можете начать видеть преимущества модульной архитектуры нашего нового проекта. Здесь мы имеем основную программу длиной всего пять строк. Это все, что нам нужно видеть, если мы не захотим видеть больше. И пока все эти модули сидят здесь терпеливо ожидая когда смогут послужить нам. Наше преимущество в том, что мы имеем простой и короткий код, но мощных союзников. Что остается сделать, это расширить модули до уровня возможностей более ранних глав. Мы сделаем это в следующей главе, но прежде, чем я закончу, давайте закончим синтаксический анализ показателя только для того, чтобы убедить себя, что мы знаем как. Конечная версия CodeGen включает новую процедуру LoadVariable:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 unit CodeGen;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 interface\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 uses Output;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConstant(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVariable(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 implementation\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load the Primary Register with a Constant \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadConstant(n: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE #' + n + ',D0' );\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Load a Variable to the Primary Register \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure LoadVariable(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE ' + Name + '(PC),D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сам модуль Parser не изменяется, но мы имеем более сложную версию процедуры Factor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConstant(GetNumber)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look)then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVariable(GetName)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error('Unrecognized character ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь, без изменений основной программы, вы должны обнаружить, что программа обрабатывает и переменный и постоянный показатель. К этому моменту наша архитектура почти завершена; у нас есть модули, выполняющие всю грязную работу и достаточно кода в синтаксическом анализаторе и генераторе кода чтобы продемонстрировать что все работает. Остается расширить модули которые мы определили, в особенности синтаксический анализатор и генератор кода, для поддержки более сложных синтаксических элементов, которые составляют настоящий язык. Так как мы делали это много раз прежде в предыдущих главах, не должно занять у нас много времени вернуться назад к тому месту, где мы были до долгого перерыва. Мы продолжим этот процесс в Главе 16, которая скоро появится. Увидимся.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Ссылки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Crenshaw, J.W., «Object-Oriented Design of Assemblers and Compilers,» Proc. Software Development '91 Conference, Miller Freeman, San Francisco, CA, February 1991, pp. 143-155.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Crenshaw, J.W., «A Perfect Marriage,» Computer Language, Volume 8, #6, June 1991, pp. 44-55.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Crenshaw, J.W., «Syntax-Driven Object-Oriented Design,» Proc. 1991 Embedded Systems Conference, Miller Freeman, San Francisco, CA, September 1991, pp. 45-60.\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Конструирование модулей\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Введение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта обучающая серия обещает стать возможно одной из самых долгоиграющих мини-серий в истории, конкурирующей только с задержкой на Томе IV Кнута. Начатая в 1988, эта серия вошла в четырехлетнюю паузу в 1990, когда «заботы мира сего», изменения в приоритетах и интересах и необходимость зарабатывать на жизнь казалось забросили ее после Главы 14. Долготерпевшие из вас были наконец вознаграждены весной прошлого года долгожданной Главой 15. В ней я начал попытку поставить серию обратно на рельсы и по ходу дела сделать ее проще для достижения цели, которая состоит в том, чтобы обеспечить вас не только достаточным пониманием трудных тем теории компиляции, но также достаточными инструментами в виде фиксированных подпрограмм и концепций, так чтобы вы были способны продолжать самостоятельно и стали достаточно опытными для того, чтобы создавать свои собственные синтаксические анализаторы и трансляторы. Из-за этой длинной паузы я подумал что следует вернуться назад и повторно рассмотреть концепции, которые мы до этого охватили а также заново сделать некоторые части программы. В прошлом мы никогда сильно не касались разработки программных инструментов промышленного качества... в конце концов я пытался обучать (и обучаться) концепциям, а не промышленной практике. Чтобы сделать это я старался давать вам не законченные компиляторы и анализаторы, а только те отрывки кода, которые иллюстрировали частные случаи, которые мы рассматривали в текущий момент.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я все еще верю, что это хороший способ изучения любого вопроса; никто не захочет вносить в изменения в программу в 100,000 строк только для того чтобы попробовать новую идею. Но идея работы с обрывками кода а не полными программами также имеет свои недостатки из-за которых мы писали те же самые фрагменты кода много раз. Хотя было полностью доказано, что повторение является хорошим способом обучения новым идеям, также правда и то, что оно может быть не слишком хорошей вещью. Ко времени, когда я завершил Главу 14, я казалось достиг пределов своих способностей манипулировать множеством файлов и множественными версиями тех же самых программ. Кто знает, может быть это одна из причин, по которым я кажется выдохся в то время.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К счастью, более поздние версии Borland Turbo Pascal позволяют нам получить и съесть свой кусок пирога. Используя их концепцию раздельно компилируемых модулей мы все еще можем писать маленькие подпрограммы и функции и сохранять наши основные и тестовые программы маленькими и простыми. Но, однажды написанный, код в модулях Паскаля будет всегда там для нашего использования и его связывание абсолютно безболезненно и прозрачно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как к настоящему времени большинство из вас программируют на C или C++, я знаю, что вы подумаете: Borland с их Turbo Pascal конечно не изобретали понятие раздельно компилируемых модулей. И, конечно, вы правы. Но если вы не использовали TP в последнее время или когда либо, вы можете не понять насколько безболезненный весь этот процесс. Даже в C или C++ вы все еще должны формировать make файл, или вручную, или сообщая компилятору как это сделать. Вы должны также перечислить, используя утверждение «extern» или заголовочные файлы, функции, которые вы хотите импортировать. В TP вы не должны даже делать этого. Вам необходимы только имена модулей, которые вы желаете использовать, и все их процедуры автоматически становятся доступны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 У меня нет намерения заниматься здесь дебатами на тему войн языков, так что я не буду затрагивать эту тему в дальнейшем. Даже я больше не использую Pascal в своей работе... я использую C на работе и С++ для своих статей в Embedded Systems Programming и других журналах. Поверьте мне, когда я намеревался возродить эту серию, я думал долго и интенсивно о переключении и языка и целевой системы на те, которые мы все используем в эти дни, C/C++ и архитектуру PC и возможно также и объектно-ориентированные методы. В конце концов я понял, что это вызовет больше беспорядка, чем сам перерыв. И в конце концов, Pascal все еще остается одним из лучших возможных языков для обучения, не говоря о промышленном программировании. Наконец, TP все еще компилирует на скорости света, гораздо быстрее чем конкурирующие C/C++ компиляторы. А интеллектуальный компоновщик Borland, использованный в TP но не в их продуктах C++ не имеет аналогов. Кроме того, что он намного быстрее, чем Microsoft-совместимые компоновщики, Borland-овский интеллектульный компоновщик отберет неиспользуемые процедуры и элементы данных даже вплоть до вырезания их из определенных объектов если они не нужны. Один из редких моментов нашей жизни, когда мы не должны идти на компромисс между полнотой и эффективностью. Когда мы пишем модуль TP мы можем сделать его настолько полным как нам нравится, включая любые функции и элементы данных которые, как мы думаем, могут нам когда-либо понадобиться, уверенные, что это не будет создавать ненужного раздутия кода в откомпилированной выполнимой программе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главное в действительности в следующем: используя механизм модулей TP мы можем иметь все преимущества и удобства написания маленьких, на вид автономных тестовых программ, без необходимости постоянно переписывать необходимые функции поддержки. Однажды написанные, модули TP сидят там, тихонько ожидая возможности выполнить свой долг и дать нам необходимую поддержку, когда будет необходимо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя этот принцип, в Главе 15 я намеревался минимизировать нашу тенденцию заново изобретать колесо, организуя наш код в отдельные модули Turbo Pascal, каждый из которых содержит различные части компилятора. Мы завершили со следующими модулями:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Input\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Output\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Errors\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Scanner\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Parser\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 CodeGen\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый из этих модулей обслуживает разные функции и изолирует специфические области функциональных возможностей. Модули Input и Output, как подразумевают их имена, обеспечивают ввод/вывод символьного потока и важнейший предсказывающий символ, на котором основан наш предсказывающий синтаксический анализатор. Модуль Errors конечно обеспечивает стандартную обработку ошибок. Модуль Scanner содержит все наши булевы функции типа IsAlpha и подпрограммы GetName и GetNumber, которые обрабатывают многосимвольные токены.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два модуля, с которыми мы будем в основном работать и те, которые больше всего представляют индивидуальность нашего компилятора – это Parser и CodeGen. Теоретически модуль Parser должен изолировать все аспекты компилятора, которые зависят от синтаксиса компилируемого языка (хотя, как мы видели последний раз, небольшое количество этого синтаксиса перетекает в Scanner). Аналогично, модуль генератора кода, CodeGen, содержит весь код, зависящий от целевой машины. В этой главе мы продолжим разработку функций в этих двух важнейших модулях.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Совсем как классический?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем мы продолжим, однако, я думаю что должен разъяснить связи между модулями и функциональные возможности этих модулей. Те из вас, кто знаком с теорией компиляции как обучавшиеся в университетах, конечно распознают имена Scanner, Parser и CodeGen, все из которых являются компонентами классической реализации компилятора. Вы можете думать, что я отказался от своих обязательств по отношению к философии KISS и отдрейфовал к более стандартной архитектуре чем мы имели. Более пристальный взгляд, однако, должен убедить вас, что хотя имена схожи, функциональность совершенно различна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вместе, сканер и парсер классической реализации составляют так называемый «front end», а генератор кода «back end». Подпрограммы «front end» обрабатывают языкозависимые, связанные с синтаксисом аспекты исходного языка, в то время как генератор кода, или «back end», работает с зависимыми от целевой машины частями проблемы. В классических компиляторах два конца (ends) сообщаются через файл инструкций, написанный на промежуточном языке (IL).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как правило, классический сканер это одиночная процедура, оперирующая как сопроцедура с синтаксическим анализатором. Она «токенизирует» исходный файл, считывая его символ за символом, распознавая элементы языка, транслируя их в токены и передавая их синтаксическому анализатору. Вы можете думать о синтаксическом анализаторе как об абстрактной машине, выполняющей «op кода», которыми являются токены. Точно также, синтаксический анализатор генерирует «op кода» второй абстрактной машины, которая механизирует IL. Как правило, IL файл записывается на диск синтаксическим анализатором и считывается снова генератором кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша организация совершенно другая. Мы не имеем лексического анализатора в классическом смысле; наш модуль Scanner, хотя и имеет схожее имя, не является одиночной процедурой или сопроцедурой, а просто набором раздельных подпрограмм, которые вызываются синтаксическим анализатором когда необходимо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично, классический генератор кода, «back end», в своем роде тоже транслятор, считывающий «исходный» IL файл и выдающий объектный файл. Наш генератор кода не работает таким способом. В нашем компиляторе нет никакого промежуточного языка; каждая конструкция в синтаксисе исходного языка преобразуется в ассемблер как только она распознана синтаксическим анализатором. Подобно Scanner, модуль CodeGen состоит из индивидуальных процедур, которые вызываются синтаксическим анализатором когда необходимо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Философия «кодируй как только найдешь» не может производить самый эффективный код в мире – например, мы не обеспечили (пока!) удобное место для оптимизатора – но она несомненно упрощает компилятор, не правда ли?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И этот наблюдение заставляет меня повторить снова то, как нам удавалось сводить функции компилятора к таким сравнительно простым условиям. Я набрался красноречивости на эту тему в прошлых главах, поэтому здесь я не буду слишком ее трогать. Однако, из-за времени, прошедшего с этих последних монологов, я надеюсь что вы предоставите мне совсем немного времени напомнить себе, так же как и вам, как мы попали сюда. Мы дошли до этого применяя несколько принципов, которые создатели коммерческих компилятором редко имеют роскошь использовать. Вот они:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Философия KISS – никогда не делай сложные вещи без причины.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ленивое кодирование – Никогда не откладывай на завтра то, что можешь отложить навсегда. (П. Дж. Плоджер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Скептицизм – упрамо отказывайтесь делать что-либо только потому, что это всегда делалось таким способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Принятие неэффективного кода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отклонение произвольных ограничений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда я сделал обзор истории конструирования компиляторов, я узнал, что практически каждый промышленный компилятор в истории страдал из-за предналоженных условий, которые сильно влияли на его дизайн. Первоначальный компилятор Fortran Джона Бэкуса должен был конкурировать с ассемблером и следовательно был вынужден производить чрезвычайно эффективный код. Компиляторы IBM для мини ЭВМ 70-х должны были выполняться в очень небольших объемах ОЗУ тогда доступных – таких небольших как 4k. Ранние компиляторы Ada должны были компилировать себя. Бринч Хансен решил, что его компилятор Паскаля, разработанный для IBM PC должен выполняться на 64k машинах. Компиляторы, разработанные на курсах Computer Science должны были компилировать широкий диапазон языков и следовательно требовали LALR синтаксических анализаторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В каждом из этих случаев эти предвзятые ограничения буквально доминировали над проектом компилятора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хороший пример – компилятор Бринч Хансена, описанный в его превосходной книге «Brinch Hansen on Pascal Compilers» (строго рекомендую). Хотя его компилятор один из самых ясных и незатемненных реализаций компилятора, что я видел, одно решение, компилировать большие файлы в небольшом ОЗУ, полностью управляло дизайном и он закончил не на одном а многих промежуточных файлах, как и управляющими ими программах для их записи и считывания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Временами, архитектуры, возникающие из таких решений, находили свое место в учениях компьютерной науки и принимались на веру. По мнению одного человека, пришло время чтобы они были критически пересмотрены. Условия, требования, среды, которые вели к классическим архитектурам не такие же, какие мы имеем сейчас. Нет никакой причины полагать, что решения тоже должны быть те же самыми.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой обучающей серии мы следовали по шагам таких пионеров в мире маленьких компиляторов для PC как Леор Золман, Рон Каин и Джеймс Хендрих, тех кто не знал достаточно теорию компиляции чтобы знать, что они «не могли делать это таким способом». Мы решительно отказались принимать произвольные ограничения, а скорее делали так, как было проще В результате мы развили архитектуру, которая, хотя и совершенно отлична от классической, делает работу простым и прямым способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я закончу эти философствования обзором понятия промежуточного языка. Хотя я отметил перед этим, что мы не имеем его в нашем компиляторе, это не совсем точно; у нас он есть, или по крайней мере мы развиваем его, в том смысле, что мы определяем функции генерации кода для вызова из парсера. В сущности, каждый вызов процедуры генерации кода можно рассматривать как инструкцию на промежуточном языке. Если мы когда либо найдем необходимым формализировать промежуточный язык, вот способ, которым бы мы сделали это: выдать кода из синтаксического анализатора, представляющие собой вызовы процедур генератора кода, а затем обработать каждый код вызывая эти процедуры в отдельном проходе, реализованном в «back end». Откровенно говоря, я не вижу, что мы когда либо найдем потребность в таком подходе, но это связь, если вы решите следовать ему, между классическим и текущим подходами.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Расширение синтаксического анализатора\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя я обещал вам где-то в Главе 14, что мы никогда снова не будем переписывать каждую одиночную функцию заново, я начал делать это с Главы 15. Единственная причина: эта длинная пауз между двумя главами делала обзор кажущимся чрезвычайно оправданным... даже необходимым и для вас и для меня. Более важно, решение собрать процедуры в модули заставило нас взглянуть на каждую из них снова, хотели мы этого или нет. И, наконец, откровенно говоря, за последние четыре года у меня появились некоторые новые идеи, которые гарантировали свежий взгляд на некоторые старые вещи. Когда я сперва начал эту серию я был искренне поражен и обрадован, узнав насколько простыми могут быть сделаны подпрограммы анализа. Но в этот последний раз я удивил сам себя снова и был способен делать их точно также, но даже немного проще.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако, из-за тотального переписывания модулей синтаксического анализа я не был только способен включить многого в последнюю главу. Из-за этого наш герой, синтаксический анализатор, когда мы последний раз его видели, был только тенью себя прежнего, содержащий только код, достаточный для анализа и обработки показателя состоящего или из переменной или константы. Основным достижением этой текущей главы должно стать восстановление синтаксического анализатора в его прежней славе. В этом процессе, я надеюсь, вы будете терпеливы, если мы иногда будем рассматривать основы, с которые мы имели дело и давно уже прошли.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала, давайте позаботимся о проблеме, к которой мы обращались прежде: наша текущая версия процедуры Factor, как мы оставили ее в Главе 15, не может обрабатывать отрицательные параметры. Чтобы исправить это мы представим процедуру SignedFactor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor with Optional Sign \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Sign: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Sign := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Sign = '-' then Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что эта процедура вызывает новую подпрограмму генерации кода Negate:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Negate Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('NEG D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Здесь и в других местах в этой серии я собираюсь только показывать вам новые подпрограммы. Я рассчитываю, что вы поместите их в соответствующий модуль, который вы должны без проблем определить. Не забывайте добавлять заголовок процедуры в раздел interface модуля.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В основной программе просто измените вызов процедуры Factor на SignedFactor и протестируйте код. Разве не хорошо компоновщик Turbo и средство make поддерживают все детали?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Да, я знаю, код не очень эффективен. Если мы введем число -3 будет сгенерирован такой код:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE #3,D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 NEG D0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что действительно, действительно грубо. Мы можем сделать лучше, конечно, просто предварительно добавив знак минус к строке, передаваемой в LoadConstant, но это добавляет несколько строк кода в SignedFactor и здесь я применяю философию KISS очень агрессивно. Более того, сказать правду, я думаю что подсознательно наслаждаюсь генерацией «действительно грубого» кода, так как я могу иметь удовольствие наблюдать как он будет становиться драматически лучше, когда мы примемся за методы оптимизации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большинство из вас никогда не слышало о Джоне Спрее, поэтому позвольте мне представить его вам здесь. Джон из Новой Зеландии и преподает информатику в одном из ее университетов. Джон написал компилятор для Motorola 6809, основанный на восхитительном, Паскаль-подобном языке собственной разработки, названном «Whimsical». Позднее он перенес компилятор на 68000 и некоторое время это был единственный компилятор, который я имел для своей доморощенной системы на 68000.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К слову сказать, один из моих стандартных тестов для любого компилятора – изучение того, как компилятор работает с пустой программой типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 program main;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мой тест измеряет время, требуемое на компиляцию и связывание и размер сгенерированного объектного файла. Бесспорный проигравший в этом тесте – компилятор DEC C для VAX, который тратит 60 секунд на компиляцию на VAX 11/780 и генерирует объектный файл 50k. Компилятор Джона бесспорно сейчас, в будущем и навсегда король по части размера кода. Для данной пустой программе Whimsical генерирует точно два байта, реализуя одну инструкцию:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 RET\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Устанавливая опцию компилятора генерировать include файл а не автономную программу, Джон может даже урезать этот размер с двух байт до нуля! Несколько трудно добиться нулевого обьектного файла, вы не согласны?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Само собой разумеется, что я рассматриваю Джона как эксперта в оптимизации кода и мне нравится что он однажды сказал: «Лучший способ оптимизации – не оптимизировать вообще, а изначально производить хороший код». Слова, по которым стоит жить. Когда мы начнем оптимизацию мы будем следовать уведомлению Джона и нашим первым шагом будет не добавление щелевого оптимизатора или другого постфактного устройства, но улучшение качества выдаваемого кода перед оптимизацией. Поэтому пометьте SignedFactor как первого хорошего кандидата на внимание и пока оставим его.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Термы и выражения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я уверен вы знаете, что будет дальше. Мы должны еще раз создать остальные процедуры, которые реализуют синтаксический анализ выражений по методу рекурсивного спуска. Все мы знаем, что иерархия процедур для арифметических выражений такая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показатель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако сейчас давайте продолжим разработку по шагам и рассмотрим выражения только с аддитивными термами. Код для реализации выражений, включающих возможно первый терм со знаком, показан ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура вызывает две другие процедуры для обработки операций:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Addition Operation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('+');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Subtraction Operation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('-');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти три процедуры Push, PopAdd и PopSub – новые подпрограммы генерации кода. Как подразумевает имя, процедура Push генерирует код для помещения основного регистра (D0 в нашей реализации для 68000) в стек. PopAdd и PopSub выталкивают вершину стека и прибавляют или вычитают ее из основного регистра. Код показан ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Push Primary to Stack \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,-(SP)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Add TOS to Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopAdd;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('ADD (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Subtract TOS from Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopSub;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('SUB (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавьте эти подпрограммы в Parser и CodeGen и измените основную программу для вызова Expression. Вуаля!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий шаг, конечно, это добавление возможности работы с мульпликативными термами. С этой целью мы добавим процедуру Term и процедуры генерации кода PopMul и PopDiv. Эти процедуры генерации кода показаны ниже:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Multiply TOS by Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopMul;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MULS (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Divide Primary by TOS \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopDiv;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE (SP)+,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EXT.L D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('DIVS D0,D7');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D7,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я должен признать, что подпрограмма деления немного перегружена, но с этим ничего нельзя поделать. К сожалению, хотя процессор 68000 позволяет выполнять деление используя вершину стека (TOS), он требует аргументы в неправильном порядке, подобно тому как для вычитания. Поэтому наше единственное спасение в том чтобы вытолкнуть стек в рабочий регистр (D7), выполнить там деление, и затем поместить результат обратно в наш основной регистр D0. Обратите внимание на использование знаковых операций умножения и деления. Этим неявно подразумевается что все наши переменные будут 16-разрядными целыми числами со знаком. Это решение затронет нас позднее, когда мы начнем рассматривать множественные типы данных, преобразования типов и т.п.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша процедура Term это практически аналог Expression и выглядит так:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Term \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsMulop(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '*': Multiply;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '/': Divide;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш следующий шаг – изменение некоторых имен. SignedFactor теперь становится SignedTerm а вызовы Factor в Expression, Add, Subtract и SignedTerm заменяются на вызов Term:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Term with Optional Leading Sign \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure SignedTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Sign: char;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Sign := Look;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if IsAddop(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 GetChar;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Sign = '-' then Negate;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 ...\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Expression \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если память мне не изменяет мы однажды уже имели и процедуру SignedFactor и SignedTerm. У меня были причины сделать так в то время... они имели отношение к обработке булевой алгебры и, в частности, булевой функции «not». Но, конечно, для арифметических операций дублирование не нужно. В выражении типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –x*y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очевидно, что знак идет со всем термом x*y а не просто с показателем x и таким способом Expression и закодирован.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Протестируйте этот новый код, выполнив Main. Она все еще вызывает Expression, так что теперь вы должны быть способны работать с выражениями, содержащими любую из четырех арифметических операций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наше последнее дело, относительно выражений, это модификация процедуры Factor для разрешения выражений в скобках. Используя рекурсивный вызов Expression мы можем уменьшить необходимый код практически до нуля. Пять строк, добавленные в Factor, выполнят эту работу:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look ='(' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('(');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match(')');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsDigit(Look) then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadConstant(GetNumber)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else if IsAlpha(Look)then\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 LoadVariable(GetName)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Error('Unrecognized character ' + Look);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этому моменту ваш «компилятор» должен уметь обрабатывать любые допустимые выражения, которые вы ему подбросите. Еще лучше, что он должен отклонить все недопустимые!\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Присваивания\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока мы здесь, мы могли бы также написать код для работы с операциями присваивания. Этот код должен только запомнить имя конечной переменной, где мы должны сохранить результат выражения, вызвать Expression, затем сохранить число. Процедура показана дальше:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate an Assignment Statement \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Assignment;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 var Name: string;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Name := GetName;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('=');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 StoreVariable(Name);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Присваивание вызывает еще одну подпрограмму генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Store the Primary Register to a Variable \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure StoreVariable(Name: string);\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('LEA ' + Name + '(PC),A0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('MOVE D0,(A0)');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь измените вызов в Main на вызов Assignment и вы должны увидеть полную операцию присваивания, обрабатываемую правильно. Довольно хорошо, не правда ли? И безболезненно также.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В прошлом мы всегда старались показывать БНФ уравнения для определения синтаксиса, который мы разрабатываем. Я не сделал этого здесь и давно пора это сделать. Вот эти БНФ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <variable> | <constant> | '(' <expression> ')'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <signed_term> ::= [<addop>] <term>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <factor> (<mulop> <factor>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <signed_term> (<addop> <term>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <assignment> ::= <variable> '=' <expression>\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Булева алгебра\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующий шаг, как мы изучили несколько раз до этого, это добавление булевой алгебры. В прошлом этот шаг по крайней мере удваивал количество кода, который мы должны были написать. Когда я прошел эти шаги в своем уме, я обнаружил, что отклоняюсь все больше и больше от того, что мы делали в предыдущих главах. Чтобы освежить вашу память, я отметил, что Паскаль обрабатывает булевы операторы в значительной степени идентично способу, которым он обрабатывает арифметические операторы. Булево «and» имеет тот же самый уровень приоритета, что и умножение, а «or» то же что сложение. Си, с другой стороны, устанавливает их на различных уровнях приоритета, которые занимают 17 уровней. В нашей более ранней работе я выбрал что-то среднее, с семью уровнями. В результате, мы закончили на чем-то называющемся булевыми выражениями, соответствующим в большинстве деталей арифметическим выражениям, но на другом уровне приоритета. Все это, как оказалось, возникло потому, что мне не хотелось помещать скобки вокруг булевых выражений в утверждениях типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IF (c >= 'A') and (c <= 'Z') then ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При взгляде назад, это кажется довольно мелкой причиной для добавления многих уровней сложности в синтаксический анализатор. Возможно более существенно то, что я не уверен что был даже способен избежать скобок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы оттолкнуться, давайте начнем заново, применяя более Паскаль-подобный подход и просто обрабатывая булевы операторы на том же самом уровне приоритетов что и арифметические. Мы увидим, куда это нас приведет. Если это окажется тупиком, мы всегда сможем возвратиться к предыдущему подходу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сперва, мы добавим в Expression операторы «уровня сложения». Это легко сделать; во первых, измените функцию IsAddop в модуле Scanner чтобы включить два дополнительных оператора: '|' для «или» и "~" для «исключающее или»:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 function IsAddop(c: char): boolean;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 IsAddop := c in ['+','-', '|', '~'];\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем, мы должны включить анализ операторов в процедуру Expression:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure Expression;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 SignedTerm;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 while IsAddop(Look) do\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 case Look of\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '+': Add;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '-': Subtract;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '|': _Or;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 '~': _Xor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Символы подчеркивания необходимы, конечно, потому что «or» and «xor» являются зарезервированными словами Turbo Pascal).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем процедуры _Or and _Xor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Subtraction Operation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure _Or;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('|');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Subtraction Operation \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure _Xor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('~');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Push;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Term;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И, наконец, новые процедуры генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Or TOS with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopOr;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('OR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Exclusive-Or TOS with Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure PopXor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR (SP)+,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь давайте протестируем транслятор (вы возможно захотите изменить вызов в Main обратно на вызов Expression просто чтобы избежать необходимости набирать каждый раз «x=» для присваивания).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пока все хорошо. Синтаксический анализатор четко обрабатывает выражения вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x|y~z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К сожалению, он также не делает ничего для того, чтобы защитить нас от смешивания булевой и арифметической алгебры. Он радостно сгенерирует код для:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a+b)*(c~d)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы говорили об этом немного в прошлом. Вообще, правила какие операции допустимы а какие нет не могут быть применены самим синтаксическим анализатором, потому что они не являются частью синтаксиса языка, а скорее его семантики. Компилятор, который не разрешает смешанные выражения такого вида должен распознать, что c и d являются булевыми переменными а не числовыми и передумать об их умножении на следующем шаге. Но такая «охрана» не может быть выполнена синтаксическим анализатором; она должна быть обработана где-то между синтаксическим анализатором и генератором кода. Мы пока не в таком положении, чтобы устанавливать такие правила, потом что у нас нет способа ни объявления типов ни таблицы идентификаторов для сохранения в ней типов. Так что, для того что у нас на данный момент работает, синтаксический анализатор делает точно то, что он предназначен делать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В любом случае, уверены ли мы, что не хотим разрешить операции над смешанными типами? Некоторое время назад мы приняли решение (или по крайней мере я принял) чтобы принимать значение 0000 как логическую «ложь» и -1 или FFFFh как логическую «истину». Хорошо в этом выборе то, что побитовые операции работают точно таким же способом, что и логические. Другими словами, когда мы выполняем операцию с одним битом логической переменной, мы делаем это над всеми из них. Это означает, что мы не должны делать различия между логическими и поразрядными операциями, как это сделано в C операторами & и &&, и | и ||. Уменьшение числа операторов наполовину конечно не выглядит совсем плохим.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С точки зрения данных в памяти, конечно, компьютер и компилятор не слишком интересуются представляет ли число FFFFh логическую истину или число -1. Должны ли мы? Я думаю что нет. Я могу придумать множество примеров (хотя они могут быть рассмотрены как «мудреный» код) где возможность смешивать типы могла бы пригодиться. Пример, функция дельты Дирака, которая могла бы быть закодирована в одной простой строке:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –(x=0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или функция абсолютного значения (определенно сложный код!):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x*(1+2*(x<0))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пожалуйста, заметьте, что я не защищаю программирование подобным образом как стиль жизни. Я почти обязательно написал бы эти функции в более читаемой форме, используя IF, только для того, чтобы защитить от запутывания того, кто будет сопровождать программу в будущем. Все же возникает моральный вопрос: Имеем ли мы право осуществлять наши идеи о хорошей практике кодирования на программисте, написав язык так, чтобы он не смог сделать что-нибудь не так? Это то, что сделал Никлаус Вирт во многих местах Паскаля и Паскаль критиковался за это – как не такой «прощающий» как Си.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересная параллель представлена в примере дизайна Motorola 68000. Хотя Motorola громко хвастается об ортогональности их набора инструкций, факт то, что он является далеко не ортогональным. К примеру, вы можете считать переменную по ее адресу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X,D0 (где X это имя переменной)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 но вы не можете записать ее таким же образом. Для записи вы должны загрузить в регистр адреса адрес X. То же самое остается истиной и для PC-относительной адресации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE X(PC),DO (допустимо)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,X(PC) (недопустимо)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда вы начинаете спрашивать, как возникло такое неортогональное поведение, вы находите, что кто-то в Motorola имел некоторые теории о том, как должно писаться программное обеспечение. В частности, в этом случае они решили, что самомодифицирующийся код, который вы можете реализовать, используя PC-относительные записи – Плохая Вещъ. Следовательно, они разработали процессор, запрещающий это. К сожалению, по ходу дела они также запретили все записи в форме, показанной выше, даже полезные. Заметьте, что это было не что-то, сделанное по умолчанию. Должна была быть сделана дополнительная дизайнерская работа, добавлены дополнительные ограничения для уничтожения естественной ортогональности набора инструкций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из уроков, которым я научился в жизни: Если у вас есть два выбора и вы не можете решить которому их них последовать, иногда самое лучшее – не делать ничего. Зачем добавлять дополнительные ограничители в процессор, чтобы осуществить чужие представления о хорошей практике программирования? Оставьте эти инструкции и позвольте программистам поспорить что такое хорошая практика программирования. Точно так же, почему мы должны добавлять дополнительный код в наш синтаксический анализатор для проверки и предупреждения условий, которые пользователь мог бы предпочесть использовать? Я предпочел бы оставить компилятор простым и позволить программным экспертам спорить, должна ли такая практика использоваться или нет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это служит как объяснение моего решения как избежать смешанной арифметики: я не буду ее избегать. Для языка, предназначенного для системного программирования, чем меньше правил, тем лучше. Если вы не согласны, и хотите выполнять проверку на такие условия, мы сможем сделать это, когда у нас будет таблица идентификаторов.\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Булево «AND»\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С это небольшой философией, мы можем приступить к оператору «and», который пойдет в процедуру Term. К настоящему времени вы возможно сможете сделать это без меня, но в любом случае вот код:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Scanner:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 function IsMulop(c: char): boolean;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 IsMulop := c in ['*','/', '&'];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в Parser:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 procedure Term;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Factor;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 while IsMulop(Look) do\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 case Look of\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 '*': Multiply;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 '/': Divide;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 '&': _And;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{ Parse and Translate a Boolean And Operation \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 procedure _And;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Match('&');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Push;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Factor;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 PopAnd;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и в CodeGen:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{ And Primary with TOS \}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 procedure PopAnd;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 begin\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EmitLn('AND (SP)+,D0');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 end;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \{–\}\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ваш синтаксический анализатор теперь должен быть способен обрабатывать почти любые виды логических выражений а также (если вы хотите) и смешанные выражения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Почему не «все виды логических выражений»? Потому что пока мы не имели дела с логическим оператором «not» и с ним все становится сложнее. Логический оператор «not» кажется на первый взгляд идентичным в своем поведении унарному минусу, поэтому моей первой мыслью было позволить оператору исключающего или, '~', дублировать унарный «not». Это не работало. При моей первой попытке процедура SignedTerm просто съедала мой '~' потому что символ проходил проверку на addop но SignedTerm игнорировал все addop за исключением "-". Было бы достаточно просто добавить другую строку в SignedTerm, но это все равно не решит проблему, потому что, заметьте, Expression принимает терм со знаком только для первого аргумента.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Математически, выражение типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –a * -b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет небольшой или совсем никакого смысла и синтаксический анализатор должен отметить его как ошибку. Но то же самое выражение, использующее логическое «not», имеет точный смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not a and not b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае с этими унарными операторами выбор заставить их работать таким же самым способом кажется исскуственным принуждением, жертвованием примлемым поведением на алтаре простоты реализуемости. Хотя я полностью за сохранение реализации настолько простой, насколько возможно, я не думаю, что мы должны делать это за счет приемлемости. Исправления подобные этому, приведут к потере основной детали, которая заключается в том, чтобы логическое «not» просто не является тем же самым что унарный минус. Рассмотрим исключающее «or», которое обычно записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a~b ::= (a and not b) or (not a and b)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы разрешим «not» изменять весь терм, последний терм в круглых скобках интерпретировался бы как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not(a and b)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что совсем не то же самое. Так что ясно, что о логическом «not» нужно думать как о связанном с показателем а не термом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Идея перегрузки оператор '~' не имеет смысла и с математической точки зрения. Применение унарного минуса эквивалентно вычитанию из нуля:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 –x <=> 0-x\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фактически, в одной из моих более простых версий Expression я реагировал на ведущий addop просто предзагружая нуль, затем обрабатывая оператор как если бы это был двоичный оператор. Но «not» это не эквивалент исключающему или с нулем... которое просто возвратит исходное число. Вместо этого, это исключающее или с FFFFh или -1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Короче говоря, кажущаяся близость между унарным «not» и унарным минусом разваливается при более близком исследованиии. «not» изменяет показатель а не терм и он не имеет отношения ни к унарному минусу, ни исключающему или. Следовательно, он заслуживает своего собственного символа для вызова. Какой символ лучше, чем очевидный, также используемый в Си символ "!"? Используя правила того как мы думаем должен вести себя «not», мы должны быть способны закодировать исключающее или (предполагая что это нам когда-нибудь понадобится) в очень естественной форме:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a & !b | !a & b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание, что никаких круглых скобок не требуется – выбранные нам уровни приоритета автоматически заботятся обо всем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если вы продолжаете учитывать уровни приоритета, это определение помещает '!' на вершину кучи. Уровни становятся:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 !\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 – (унарный)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *, /, &\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +, -, |, ~\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассматривая этот список, конечно не трудно увидеть, почему мы имели проблему при использовании '~' как символа «not»!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так, как мы механизируем эти правила? Таким же самым способом, как мы сделали с SignedTerm, но на уровне показателя. Мы определим процедуру NotFactor:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Parse and Translate a Factor with Optional «Not» \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotFactor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 if Look ='!' then begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Match('!');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Notit;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 else\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Factor;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и вызовем ее из всех мест, где мы прежде вызывали Factor, т.е. из Term, Multiply, Divide и _And. Обратите внимание на новую процедуру генерации кода:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{ Bitwise Not Primary \}\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 procedure NotIt;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 begin\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 EmitLn('EOR #-1,D0');\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 end;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \{–\}\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Испытайте ее сейчас с несколькими простыми случаями. Фактически, попробуйте пример с исключающим или:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a&!b|!a&b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вы должны получить код (без комментариев, конечно):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE A(PC),DO ; load a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; push it\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE B(PC),DO ; load b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EOR #-1,D0 ; not it\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AND (SP)+,D0 ; and with a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; push result\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE A(PC),DO ; load a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 EOR #-1,D0 ; not it\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE D0,-(SP) ; push it\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 MOVE B(PC),DO ; load b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AND (SP)+,D0 ; and with !a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 OR (SP)+,D0 ; or with first term\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это точно то, что мы хотели получить. Так что, по крайней мере, и для арифметических и для логических операторов наш новый приоритет и новый, более тонкий синтаксис, поддерживают друг друга. Даже специфическое, но допустимое выражение с ведущим addop:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~x\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет смысл. SignedTerm игнорирует ведущий '~' как и должно быть, так как выражение эквивалентно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 0~x,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что эквивалентно x.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда мы взглянем на созданные нами БНФ, мы обнаружим, что наша булева алгебра добавляет теперь только одну дополнительную строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <not_factor> ::= [!] <factor>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <factor> ::= <variable> | <constant> | '(' <expression> ')'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <signed_term> ::= [<addop>] <term>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <term> ::= <not_factor> (<mulop> <not_factor>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <expression> ::= <signed_term> (<addop> <term>)*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <assignment> ::= <variable> '=' <expression>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это большое улучшение предыдущих достижений. Будет ли сохраняться наша удача когда мы примемся за операторы отношений? Мы выясним это скоро, но мы должы будем дождаться следующей главы. У нас выдалась подходящая пауза и я хочу выдать эту главу в ваши руки. Уже прошел год с выпуска Главы 15. Я боюсь признаться, что вся эта текущая глава была готова уже давно, за исключением операторов отношений. Но эта информация совсем не дает вам ничего хорошего, сидя на моем жестком диске, и удерживая ее пока пока операторы отношений не будут сделаны, я не давал ее в ваши руки все это время. Пришло время выдать ее чтобы вы смогли получить из нее что-нибудь ценное. Кроме того, имеется большое количество серъезных философских вопросов, связанных с операторами отношений, и я предпочел бы сохранить их для отдельной главы, где я смог бы сделать это корректно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Развлекайтесь с новой более тонкой арифметикой и логическим анализом, а я скоро увижу вас с отношениями.\par
\par
\par

\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net" }}{\fldrslt \ul бесплатной электронной библиотеке BooksCafe.Net}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net/comment/krenshou_dzhek-davayte_sozdadim_kompilyator-5714.html" }}{\fldrslt \ul Оставить отзыв о книге}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://bookscafe.net/author/krenshou_dzhek-1664.html" }}{\fldrslt \ul Все книги автора}}
\par

}
